(() => {
	var t = {
			1511: (t, e, n) => {
				t.exports = n(3363);
			},
			116: (t, e, n) => {
				t.exports = n(1955);
			},
			8914: (t, e, n) => {
				t.exports = n(6279);
			},
			1643: (t, e, n) => {
				t.exports = n(9373);
			},
			2991: (t, e, n) => {
				t.exports = n(1798);
			},
			3798: (t, e, n) => {
				t.exports = n(4604);
			},
			1942: (t, e, n) => {
				t.exports = n(3383);
			},
			368: (t, e, n) => {
				t.exports = n(7396);
			},
			3978: (t, e, n) => {
				t.exports = n(1910);
			},
			4074: (t, e, n) => {
				t.exports = n(9427);
			},
			9649: (t, e, n) => {
				t.exports = n(2857);
			},
			4310: (t, e, n) => {
				t.exports = n(9534);
			},
			6902: (t, e, n) => {
				t.exports = n(3059);
			},
			875: (t, e, n) => {
				t.exports = n(7460);
			},
			1068: (t, e, n) => {
				t.exports = n(1895);
			},
			3032: (t, e, n) => {
				t.exports = n(7989);
			},
			3592: (t, e, n) => {
				t.exports = n(7385);
			},
			8363: (t, e, n) => {
				t.exports = n(1522);
			},
			9996: (t, e, n) => {
				t.exports = n(2209);
			},
			5238: (t, e, n) => {
				t.exports = n(1493);
			},
			189: (t, e, n) => {
				t.exports = n(6094);
			},
			4341: (t, e, n) => {
				t.exports = n(3685);
			},
			4889: (t, e, n) => {
				t.exports = n(4303);
			},
			9542: (t, e, n) => {
				t.exports = n(5122);
			},
			9798: (t, e, n) => {
				t.exports = n(9531);
			},
			1446: (t, e, n) => {
				t.exports = n(6600);
			},
			3327: (t, e, n) => {
				t.exports = n(9759);
			},
			3109: (t, e, n) => {
				t.exports = n(5666);
			},
			1416: (t, e, n) => {
				"use strict";
				var i = n(9798);
				function r(t, e, n, r, a, s, o) {
					try {
						var l = t[s](o),
							c = l.value;
					} catch (t) {
						return void n(t);
					}
					l.done ? e(c) : i.resolve(c).then(r, a);
				}
				function a(t) {
					return function () {
						var e = this,
							n = arguments;
						return new i(function (i, a) {
							var s = t.apply(e, n);
							function o(t) {
								r(s, i, a, o, l, "next", t);
							}
							function l(t) {
								r(s, i, a, o, l, "throw", t);
							}
							o(void 0);
						});
					};
				}
				function s(t, e) {
					if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
				}
				var o = n(4341);
				function l(t, e) {
					for (var n = 0; n < e.length; n++) {
						var i = e[n];
						(i.enumerable = i.enumerable || !1), (i.configurable = !0), "value" in i && (i.writable = !0), o(t, i.key, i);
					}
				}
				function c(t, e, n) {
					return e && l(t.prototype, e), n && l(t, n), t;
				}
				var u = n(3032),
					h = n.n(u),
					d = n(3109),
					p = n.n(d),
					f = n(1068),
					m = n.n(f),
					v = n(189),
					g = n(9542);
				function b(t, e) {
					return (b =
						g ||
						function (t, e) {
							return (t.__proto__ = e), t;
						})(t, e);
				}
				function x(t, e) {
					if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
					(t.prototype = v(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } })), e && b(t, e);
				}
				var y = n(1446),
					_ = n(3327);
				function w(t) {
					return (w =
						"function" == typeof y && "symbol" == typeof _
							? function (t) {
									return typeof t;
							  }
							: function (t) {
									return t && "function" == typeof y && t.constructor === y && t !== y.prototype ? "symbol" : typeof t;
							  })(t);
				}
				function M(t, e) {
					if (e && ("object" === w(e) || "function" == typeof e)) return e;
					if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
					return (function (t) {
						if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
						return t;
					})(t);
				}
				var S = n(4889);
				function T(t) {
					return (T = g
						? S
						: function (t) {
								return t.__proto__ || S(t);
						  })(t);
				}
				const E = 0,
					C = 1,
					P = 2,
					A = 0,
					L = 1,
					R = 2,
					D = 3,
					O = 100,
					z = 301,
					I = 302,
					k = 303,
					N = 304,
					V = 306,
					B = 307,
					F = 1e3,
					U = 1001,
					H = 1002,
					G = 1003,
					W = 1004,
					j = 1005,
					X = 1006,
					q = 1008,
					Y = 1009,
					Z = 1012,
					K = 1014,
					J = 1015,
					Q = 1016,
					$ = 1020,
					tt = 1022,
					et = 1023,
					nt = 1026,
					it = 1027,
					rt = 2300,
					at = 2301,
					st = 2302,
					ot = 2400,
					lt = 2401,
					ct = 2402,
					ut = 2500,
					ht = 3e3,
					dt = 3001,
					pt = 3007,
					ft = 3002,
					mt = 7680,
					vt = 35044,
					gt = 35048,
					bt = "300 es";
				class xt {
					addEventListener(t, e) {
						void 0 === this._listeners && (this._listeners = {});
						const n = this._listeners;
						void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e);
					}
					hasEventListener(t, e) {
						if (void 0 === this._listeners) return !1;
						const n = this._listeners;
						return void 0 !== n[t] && -1 !== n[t].indexOf(e);
					}
					removeEventListener(t, e) {
						if (void 0 === this._listeners) return;
						const n = this._listeners[t];
						if (void 0 !== n) {
							const t = n.indexOf(e);
							-1 !== t && n.splice(t, 1);
						}
					}
					dispatchEvent(t) {
						if (void 0 === this._listeners) return;
						const e = this._listeners[t.type];
						if (void 0 !== e) {
							t.target = this;
							const n = e.slice(0);
							for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
							t.target = null;
						}
					}
				}
				let yt = 1234567;
				const _t = Math.PI / 180,
					wt = 180 / Math.PI,
					Mt = [];
				for (let t = 0; t < 256; t++) Mt[t] = (t < 16 ? "0" : "") + t.toString(16);
				const St = "undefined" != typeof crypto && "randomUUID" in crypto;
				function Tt() {
					if (St) return crypto.randomUUID().toUpperCase();
					const t = (4294967295 * Math.random()) | 0,
						e = (4294967295 * Math.random()) | 0,
						n = (4294967295 * Math.random()) | 0,
						i = (4294967295 * Math.random()) | 0;
					return (Mt[255 & t] + Mt[(t >> 8) & 255] + Mt[(t >> 16) & 255] + Mt[(t >> 24) & 255] + "-" + Mt[255 & e] + Mt[(e >> 8) & 255] + "-" + Mt[((e >> 16) & 15) | 64] + Mt[(e >> 24) & 255] + "-" + Mt[(63 & n) | 128] + Mt[(n >> 8) & 255] + "-" + Mt[(n >> 16) & 255] + Mt[(n >> 24) & 255] + Mt[255 & i] + Mt[(i >> 8) & 255] + Mt[(i >> 16) & 255] + Mt[(i >> 24) & 255]).toUpperCase();
				}
				function Et(t, e, n) {
					return Math.max(e, Math.min(n, t));
				}
				function Ct(t, e) {
					return ((t % e) + e) % e;
				}
				function Pt(t, e, n) {
					return (1 - n) * t + n * e;
				}
				function At(t) {
					return 0 == (t & (t - 1)) && 0 !== t;
				}
				function Lt(t) {
					return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
				}
				function Rt(t) {
					return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
				}
				var Dt = Object.freeze({
					__proto__: null,
					DEG2RAD: _t,
					RAD2DEG: wt,
					generateUUID: Tt,
					clamp: Et,
					euclideanModulo: Ct,
					mapLinear: function (t, e, n, i, r) {
						return i + ((t - e) * (r - i)) / (n - e);
					},
					inverseLerp: function (t, e, n) {
						return t !== e ? (n - t) / (e - t) : 0;
					},
					lerp: Pt,
					damp: function (t, e, n, i) {
						return Pt(t, e, 1 - Math.exp(-n * i));
					},
					pingpong: function (t, e = 1) {
						return e - Math.abs(Ct(t, 2 * e) - e);
					},
					smoothstep: function (t, e, n) {
						return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t);
					},
					smootherstep: function (t, e, n) {
						return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
					},
					randInt: function (t, e) {
						return t + Math.floor(Math.random() * (e - t + 1));
					},
					randFloat: function (t, e) {
						return t + Math.random() * (e - t);
					},
					randFloatSpread: function (t) {
						return t * (0.5 - Math.random());
					},
					seededRandom: function (t) {
						return void 0 !== t && (yt = t % 2147483647), (yt = (16807 * yt) % 2147483647), (yt - 1) / 2147483646;
					},
					degToRad: function (t) {
						return t * _t;
					},
					radToDeg: function (t) {
						return t * wt;
					},
					isPowerOfTwo: At,
					ceilPowerOfTwo: Lt,
					floorPowerOfTwo: Rt,
					setQuaternionFromProperEuler: function (t, e, n, i, r) {
						const a = Math.cos,
							s = Math.sin,
							o = a(n / 2),
							l = s(n / 2),
							c = a((e + i) / 2),
							u = s((e + i) / 2),
							h = a((e - i) / 2),
							d = s((e - i) / 2),
							p = a((i - e) / 2),
							f = s((i - e) / 2);
						switch (r) {
							case "XYX":
								t.set(o * u, l * h, l * d, o * c);
								break;
							case "YZY":
								t.set(l * d, o * u, l * h, o * c);
								break;
							case "ZXZ":
								t.set(l * h, l * d, o * u, o * c);
								break;
							case "XZX":
								t.set(o * u, l * f, l * p, o * c);
								break;
							case "YXY":
								t.set(l * p, o * u, l * f, o * c);
								break;
							case "ZYZ":
								t.set(l * f, l * p, o * u, o * c);
								break;
							default:
								console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r);
						}
					},
				});
				class Ot {
					constructor(t = 0, e = 0) {
						(this.x = t), (this.y = e);
					}
					get width() {
						return this.x;
					}
					set width(t) {
						this.x = t;
					}
					get height() {
						return this.y;
					}
					set height(t) {
						this.y = t;
					}
					set(t, e) {
						return (this.x = t), (this.y = e), this;
					}
					setScalar(t) {
						return (this.x = t), (this.y = t), this;
					}
					setX(t) {
						return (this.x = t), this;
					}
					setY(t) {
						return (this.y = t), this;
					}
					setComponent(t, e) {
						switch (t) {
							case 0:
								this.x = e;
								break;
							case 1:
								this.y = e;
								break;
							default:
								throw new Error("index is out of range: " + t);
						}
						return this;
					}
					getComponent(t) {
						switch (t) {
							case 0:
								return this.x;
							case 1:
								return this.y;
							default:
								throw new Error("index is out of range: " + t);
						}
					}
					clone() {
						return new this.constructor(this.x, this.y);
					}
					copy(t) {
						return (this.x = t.x), (this.y = t.y), this;
					}
					add(t, e) {
						return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : ((this.x += t.x), (this.y += t.y), this);
					}
					addScalar(t) {
						return (this.x += t), (this.y += t), this;
					}
					addVectors(t, e) {
						return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
					}
					addScaledVector(t, e) {
						return (this.x += t.x * e), (this.y += t.y * e), this;
					}
					sub(t, e) {
						return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : ((this.x -= t.x), (this.y -= t.y), this);
					}
					subScalar(t) {
						return (this.x -= t), (this.y -= t), this;
					}
					subVectors(t, e) {
						return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
					}
					multiply(t) {
						return (this.x *= t.x), (this.y *= t.y), this;
					}
					multiplyScalar(t) {
						return (this.x *= t), (this.y *= t), this;
					}
					divide(t) {
						return (this.x /= t.x), (this.y /= t.y), this;
					}
					divideScalar(t) {
						return this.multiplyScalar(1 / t);
					}
					applyMatrix3(t) {
						const e = this.x,
							n = this.y,
							i = t.elements;
						return (this.x = i[0] * e + i[3] * n + i[6]), (this.y = i[1] * e + i[4] * n + i[7]), this;
					}
					min(t) {
						return (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), this;
					}
					max(t) {
						return (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), this;
					}
					clamp(t, e) {
						return (this.x = Math.max(t.x, Math.min(e.x, this.x))), (this.y = Math.max(t.y, Math.min(e.y, this.y))), this;
					}
					clampScalar(t, e) {
						return (this.x = Math.max(t, Math.min(e, this.x))), (this.y = Math.max(t, Math.min(e, this.y))), this;
					}
					clampLength(t, e) {
						const n = this.length();
						return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
					}
					floor() {
						return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
					}
					ceil() {
						return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
					}
					round() {
						return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
					}
					roundToZero() {
						return (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)), (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)), this;
					}
					negate() {
						return (this.x = -this.x), (this.y = -this.y), this;
					}
					dot(t) {
						return this.x * t.x + this.y * t.y;
					}
					cross(t) {
						return this.x * t.y - this.y * t.x;
					}
					lengthSq() {
						return this.x * this.x + this.y * this.y;
					}
					length() {
						return Math.sqrt(this.x * this.x + this.y * this.y);
					}
					manhattanLength() {
						return Math.abs(this.x) + Math.abs(this.y);
					}
					normalize() {
						return this.divideScalar(this.length() || 1);
					}
					angle() {
						return Math.atan2(-this.y, -this.x) + Math.PI;
					}
					distanceTo(t) {
						return Math.sqrt(this.distanceToSquared(t));
					}
					distanceToSquared(t) {
						const e = this.x - t.x,
							n = this.y - t.y;
						return e * e + n * n;
					}
					manhattanDistanceTo(t) {
						return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
					}
					setLength(t) {
						return this.normalize().multiplyScalar(t);
					}
					lerp(t, e) {
						return (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this;
					}
					lerpVectors(t, e, n) {
						return (this.x = t.x + (e.x - t.x) * n), (this.y = t.y + (e.y - t.y) * n), this;
					}
					equals(t) {
						return t.x === this.x && t.y === this.y;
					}
					fromArray(t, e = 0) {
						return (this.x = t[e]), (this.y = t[e + 1]), this;
					}
					toArray(t = [], e = 0) {
						return (t[e] = this.x), (t[e + 1] = this.y), t;
					}
					fromBufferAttribute(t, e, n) {
						return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), (this.x = t.getX(e)), (this.y = t.getY(e)), this;
					}
					rotateAround(t, e) {
						const n = Math.cos(e),
							i = Math.sin(e),
							r = this.x - t.x,
							a = this.y - t.y;
						return (this.x = r * n - a * i + t.x), (this.y = r * i + a * n + t.y), this;
					}
					random() {
						return (this.x = Math.random()), (this.y = Math.random()), this;
					}
					*[Symbol.iterator]() {
						yield this.x, yield this.y;
					}
				}
				Ot.prototype.isVector2 = !0;
				class zt {
					constructor() {
						(this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]), arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
					}
					set(t, e, n, i, r, a, s, o, l) {
						const c = this.elements;
						return (c[0] = t), (c[1] = i), (c[2] = s), (c[3] = e), (c[4] = r), (c[5] = o), (c[6] = n), (c[7] = a), (c[8] = l), this;
					}
					identity() {
						return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
					}
					copy(t) {
						const e = this.elements,
							n = t.elements;
						return (e[0] = n[0]), (e[1] = n[1]), (e[2] = n[2]), (e[3] = n[3]), (e[4] = n[4]), (e[5] = n[5]), (e[6] = n[6]), (e[7] = n[7]), (e[8] = n[8]), this;
					}
					extractBasis(t, e, n) {
						return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
					}
					setFromMatrix4(t) {
						const e = t.elements;
						return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this;
					}
					multiply(t) {
						return this.multiplyMatrices(this, t);
					}
					premultiply(t) {
						return this.multiplyMatrices(t, this);
					}
					multiplyMatrices(t, e) {
						const n = t.elements,
							i = e.elements,
							r = this.elements,
							a = n[0],
							s = n[3],
							o = n[6],
							l = n[1],
							c = n[4],
							u = n[7],
							h = n[2],
							d = n[5],
							p = n[8],
							f = i[0],
							m = i[3],
							v = i[6],
							g = i[1],
							b = i[4],
							x = i[7],
							y = i[2],
							_ = i[5],
							w = i[8];
						return (r[0] = a * f + s * g + o * y), (r[3] = a * m + s * b + o * _), (r[6] = a * v + s * x + o * w), (r[1] = l * f + c * g + u * y), (r[4] = l * m + c * b + u * _), (r[7] = l * v + c * x + u * w), (r[2] = h * f + d * g + p * y), (r[5] = h * m + d * b + p * _), (r[8] = h * v + d * x + p * w), this;
					}
					multiplyScalar(t) {
						const e = this.elements;
						return (e[0] *= t), (e[3] *= t), (e[6] *= t), (e[1] *= t), (e[4] *= t), (e[7] *= t), (e[2] *= t), (e[5] *= t), (e[8] *= t), this;
					}
					determinant() {
						const t = this.elements,
							e = t[0],
							n = t[1],
							i = t[2],
							r = t[3],
							a = t[4],
							s = t[5],
							o = t[6],
							l = t[7],
							c = t[8];
						return e * a * c - e * s * l - n * r * c + n * s * o + i * r * l - i * a * o;
					}
					invert() {
						const t = this.elements,
							e = t[0],
							n = t[1],
							i = t[2],
							r = t[3],
							a = t[4],
							s = t[5],
							o = t[6],
							l = t[7],
							c = t[8],
							u = c * a - s * l,
							h = s * o - c * r,
							d = l * r - a * o,
							p = e * u + n * h + i * d;
						if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
						const f = 1 / p;
						return (t[0] = u * f), (t[1] = (i * l - c * n) * f), (t[2] = (s * n - i * a) * f), (t[3] = h * f), (t[4] = (c * e - i * o) * f), (t[5] = (i * r - s * e) * f), (t[6] = d * f), (t[7] = (n * o - l * e) * f), (t[8] = (a * e - n * r) * f), this;
					}
					transpose() {
						let t;
						const e = this.elements;
						return (t = e[1]), (e[1] = e[3]), (e[3] = t), (t = e[2]), (e[2] = e[6]), (e[6] = t), (t = e[5]), (e[5] = e[7]), (e[7] = t), this;
					}
					getNormalMatrix(t) {
						return this.setFromMatrix4(t).invert().transpose();
					}
					transposeIntoArray(t) {
						const e = this.elements;
						return (t[0] = e[0]), (t[1] = e[3]), (t[2] = e[6]), (t[3] = e[1]), (t[4] = e[4]), (t[5] = e[7]), (t[6] = e[2]), (t[7] = e[5]), (t[8] = e[8]), this;
					}
					setUvTransform(t, e, n, i, r, a, s) {
						const o = Math.cos(r),
							l = Math.sin(r);
						return this.set(n * o, n * l, -n * (o * a + l * s) + a + t, -i * l, i * o, -i * (-l * a + o * s) + s + e, 0, 0, 1), this;
					}
					scale(t, e) {
						const n = this.elements;
						return (n[0] *= t), (n[3] *= t), (n[6] *= t), (n[1] *= e), (n[4] *= e), (n[7] *= e), this;
					}
					rotate(t) {
						const e = Math.cos(t),
							n = Math.sin(t),
							i = this.elements,
							r = i[0],
							a = i[3],
							s = i[6],
							o = i[1],
							l = i[4],
							c = i[7];
						return (i[0] = e * r + n * o), (i[3] = e * a + n * l), (i[6] = e * s + n * c), (i[1] = -n * r + e * o), (i[4] = -n * a + e * l), (i[7] = -n * s + e * c), this;
					}
					translate(t, e) {
						const n = this.elements;
						return (n[0] += t * n[2]), (n[3] += t * n[5]), (n[6] += t * n[8]), (n[1] += e * n[2]), (n[4] += e * n[5]), (n[7] += e * n[8]), this;
					}
					equals(t) {
						const e = this.elements,
							n = t.elements;
						for (let t = 0; t < 9; t++) if (e[t] !== n[t]) return !1;
						return !0;
					}
					fromArray(t, e = 0) {
						for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
						return this;
					}
					toArray(t = [], e = 0) {
						const n = this.elements;
						return (t[e] = n[0]), (t[e + 1] = n[1]), (t[e + 2] = n[2]), (t[e + 3] = n[3]), (t[e + 4] = n[4]), (t[e + 5] = n[5]), (t[e + 6] = n[6]), (t[e + 7] = n[7]), (t[e + 8] = n[8]), t;
					}
					clone() {
						return new this.constructor().fromArray(this.elements);
					}
				}
				function It(t) {
					if (0 === t.length) return -1 / 0;
					let e = t[0];
					for (let n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);
					return e;
				}
				zt.prototype.isMatrix3 = !0;
				Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;
				function kt(t) {
					return document.createElementNS("http://www.w3.org/1999/xhtml", t);
				}
				let Nt;
				class Vt {
					static getDataURL(t) {
						if (/^data:/i.test(t.src)) return t.src;
						if ("undefined" == typeof HTMLCanvasElement) return t.src;
						let e;
						if (t instanceof HTMLCanvasElement) e = t;
						else {
							void 0 === Nt && (Nt = kt("canvas")), (Nt.width = t.width), (Nt.height = t.height);
							const n = Nt.getContext("2d");
							t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), (e = Nt);
						}
						return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", 0.6)) : e.toDataURL("image/png");
					}
				}
				let Bt = 0;
				class Ft extends xt {
					constructor(t = Ft.DEFAULT_IMAGE, e = Ft.DEFAULT_MAPPING, n = 1001, i = 1001, r = 1006, a = 1008, s = 1023, o = 1009, l = 1, c = 3e3) {
						super(),
							Object.defineProperty(this, "id", { value: Bt++ }),
							(this.uuid = Tt()),
							(this.name = ""),
							(this.image = t),
							(this.mipmaps = []),
							(this.mapping = e),
							(this.wrapS = n),
							(this.wrapT = i),
							(this.magFilter = r),
							(this.minFilter = a),
							(this.anisotropy = l),
							(this.format = s),
							(this.internalFormat = null),
							(this.type = o),
							(this.offset = new Ot(0, 0)),
							(this.repeat = new Ot(1, 1)),
							(this.center = new Ot(0, 0)),
							(this.rotation = 0),
							(this.matrixAutoUpdate = !0),
							(this.matrix = new zt()),
							(this.generateMipmaps = !0),
							(this.premultiplyAlpha = !1),
							(this.flipY = !0),
							(this.unpackAlignment = 4),
							(this.encoding = c),
							(this.version = 0),
							(this.onUpdate = null),
							(this.isRenderTargetTexture = !1);
					}
					updateMatrix() {
						this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
					}
					clone() {
						return new this.constructor().copy(this);
					}
					copy(t) {
						return (
							(this.name = t.name),
							(this.image = t.image),
							(this.mipmaps = t.mipmaps.slice(0)),
							(this.mapping = t.mapping),
							(this.wrapS = t.wrapS),
							(this.wrapT = t.wrapT),
							(this.magFilter = t.magFilter),
							(this.minFilter = t.minFilter),
							(this.anisotropy = t.anisotropy),
							(this.format = t.format),
							(this.internalFormat = t.internalFormat),
							(this.type = t.type),
							this.offset.copy(t.offset),
							this.repeat.copy(t.repeat),
							this.center.copy(t.center),
							(this.rotation = t.rotation),
							(this.matrixAutoUpdate = t.matrixAutoUpdate),
							this.matrix.copy(t.matrix),
							(this.generateMipmaps = t.generateMipmaps),
							(this.premultiplyAlpha = t.premultiplyAlpha),
							(this.flipY = t.flipY),
							(this.unpackAlignment = t.unpackAlignment),
							(this.encoding = t.encoding),
							this
						);
					}
					toJSON(t) {
						const e = void 0 === t || "string" == typeof t;
						if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
						const n = {
							metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" },
							uuid: this.uuid,
							name: this.name,
							mapping: this.mapping,
							repeat: [this.repeat.x, this.repeat.y],
							offset: [this.offset.x, this.offset.y],
							center: [this.center.x, this.center.y],
							rotation: this.rotation,
							wrap: [this.wrapS, this.wrapT],
							format: this.format,
							type: this.type,
							encoding: this.encoding,
							minFilter: this.minFilter,
							magFilter: this.magFilter,
							anisotropy: this.anisotropy,
							flipY: this.flipY,
							premultiplyAlpha: this.premultiplyAlpha,
							unpackAlignment: this.unpackAlignment,
						};
						if (void 0 !== this.image) {
							const i = this.image;
							if ((void 0 === i.uuid && (i.uuid = Tt()), !e && void 0 === t.images[i.uuid])) {
								let e;
								if (Array.isArray(i)) {
									e = [];
									for (let t = 0, n = i.length; t < n; t++) i[t].isDataTexture ? e.push(Ut(i[t].image)) : e.push(Ut(i[t]));
								} else e = Ut(i);
								t.images[i.uuid] = { uuid: i.uuid, url: e };
							}
							n.image = i.uuid;
						}
						return e || (t.textures[this.uuid] = n), n;
					}
					dispose() {
						this.dispatchEvent({ type: "dispose" });
					}
					transformUv(t) {
						if (300 !== this.mapping) return t;
						if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
							switch (this.wrapS) {
								case F:
									t.x = t.x - Math.floor(t.x);
									break;
								case U:
									t.x = t.x < 0 ? 0 : 1;
									break;
								case H:
									1 === Math.abs(Math.floor(t.x) % 2) ? (t.x = Math.ceil(t.x) - t.x) : (t.x = t.x - Math.floor(t.x));
							}
						if (t.y < 0 || t.y > 1)
							switch (this.wrapT) {
								case F:
									t.y = t.y - Math.floor(t.y);
									break;
								case U:
									t.y = t.y < 0 ? 0 : 1;
									break;
								case H:
									1 === Math.abs(Math.floor(t.y) % 2) ? (t.y = Math.ceil(t.y) - t.y) : (t.y = t.y - Math.floor(t.y));
							}
						return this.flipY && (t.y = 1 - t.y), t;
					}
					set needsUpdate(t) {
						!0 === t && this.version++;
					}
				}
				function Ut(t) {
					return ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement) || ("undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement) || ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap) ? Vt.getDataURL(t) : t.data ? { data: Array.prototype.slice.call(t.data), width: t.width, height: t.height, type: t.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
				}
				(Ft.DEFAULT_IMAGE = void 0), (Ft.DEFAULT_MAPPING = 300), (Ft.prototype.isTexture = !0);
				class Ht {
					constructor(t = 0, e = 0, n = 0, i = 1) {
						(this.x = t), (this.y = e), (this.z = n), (this.w = i);
					}
					get width() {
						return this.z;
					}
					set width(t) {
						this.z = t;
					}
					get height() {
						return this.w;
					}
					set height(t) {
						this.w = t;
					}
					set(t, e, n, i) {
						return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this;
					}
					setScalar(t) {
						return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
					}
					setX(t) {
						return (this.x = t), this;
					}
					setY(t) {
						return (this.y = t), this;
					}
					setZ(t) {
						return (this.z = t), this;
					}
					setW(t) {
						return (this.w = t), this;
					}
					setComponent(t, e) {
						switch (t) {
							case 0:
								this.x = e;
								break;
							case 1:
								this.y = e;
								break;
							case 2:
								this.z = e;
								break;
							case 3:
								this.w = e;
								break;
							default:
								throw new Error("index is out of range: " + t);
						}
						return this;
					}
					getComponent(t) {
						switch (t) {
							case 0:
								return this.x;
							case 1:
								return this.y;
							case 2:
								return this.z;
							case 3:
								return this.w;
							default:
								throw new Error("index is out of range: " + t);
						}
					}
					clone() {
						return new this.constructor(this.x, this.y, this.z, this.w);
					}
					copy(t) {
						return (this.x = t.x), (this.y = t.y), (this.z = t.z), (this.w = void 0 !== t.w ? t.w : 1), this;
					}
					add(t, e) {
						return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : ((this.x += t.x), (this.y += t.y), (this.z += t.z), (this.w += t.w), this);
					}
					addScalar(t) {
						return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this;
					}
					addVectors(t, e) {
						return (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), (this.w = t.w + e.w), this;
					}
					addScaledVector(t, e) {
						return (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), (this.w += t.w * e), this;
					}
					sub(t, e) {
						return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), (this.w -= t.w), this);
					}
					subScalar(t) {
						return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this;
					}
					subVectors(t, e) {
						return (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), (this.w = t.w - e.w), this;
					}
					multiply(t) {
						return (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), (this.w *= t.w), this;
					}
					multiplyScalar(t) {
						return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this;
					}
					applyMatrix4(t) {
						const e = this.x,
							n = this.y,
							i = this.z,
							r = this.w,
							a = t.elements;
						return (this.x = a[0] * e + a[4] * n + a[8] * i + a[12] * r), (this.y = a[1] * e + a[5] * n + a[9] * i + a[13] * r), (this.z = a[2] * e + a[6] * n + a[10] * i + a[14] * r), (this.w = a[3] * e + a[7] * n + a[11] * i + a[15] * r), this;
					}
					divideScalar(t) {
						return this.multiplyScalar(1 / t);
					}
					setAxisAngleFromQuaternion(t) {
						this.w = 2 * Math.acos(t.w);
						const e = Math.sqrt(1 - t.w * t.w);
						return e < 1e-4 ? ((this.x = 1), (this.y = 0), (this.z = 0)) : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)), this;
					}
					setAxisAngleFromRotationMatrix(t) {
						let e, n, i, r;
						const a = 0.01,
							s = 0.1,
							o = t.elements,
							l = o[0],
							c = o[4],
							u = o[8],
							h = o[1],
							d = o[5],
							p = o[9],
							f = o[2],
							m = o[6],
							v = o[10];
						if (Math.abs(c - h) < a && Math.abs(u - f) < a && Math.abs(p - m) < a) {
							if (Math.abs(c + h) < s && Math.abs(u + f) < s && Math.abs(p + m) < s && Math.abs(l + d + v - 3) < s) return this.set(1, 0, 0, 0), this;
							e = Math.PI;
							const t = (l + 1) / 2,
								o = (d + 1) / 2,
								g = (v + 1) / 2,
								b = (c + h) / 4,
								x = (u + f) / 4,
								y = (p + m) / 4;
							return t > o && t > g ? (t < a ? ((n = 0), (i = 0.707106781), (r = 0.707106781)) : ((n = Math.sqrt(t)), (i = b / n), (r = x / n))) : o > g ? (o < a ? ((n = 0.707106781), (i = 0), (r = 0.707106781)) : ((i = Math.sqrt(o)), (n = b / i), (r = y / i))) : g < a ? ((n = 0.707106781), (i = 0.707106781), (r = 0)) : ((r = Math.sqrt(g)), (n = x / r), (i = y / r)), this.set(n, i, r, e), this;
						}
						let g = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (h - c) * (h - c));
						return Math.abs(g) < 0.001 && (g = 1), (this.x = (m - p) / g), (this.y = (u - f) / g), (this.z = (h - c) / g), (this.w = Math.acos((l + d + v - 1) / 2)), this;
					}
					min(t) {
						return (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), (this.z = Math.min(this.z, t.z)), (this.w = Math.min(this.w, t.w)), this;
					}
					max(t) {
						return (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), (this.z = Math.max(this.z, t.z)), (this.w = Math.max(this.w, t.w)), this;
					}
					clamp(t, e) {
						return (this.x = Math.max(t.x, Math.min(e.x, this.x))), (this.y = Math.max(t.y, Math.min(e.y, this.y))), (this.z = Math.max(t.z, Math.min(e.z, this.z))), (this.w = Math.max(t.w, Math.min(e.w, this.w))), this;
					}
					clampScalar(t, e) {
						return (this.x = Math.max(t, Math.min(e, this.x))), (this.y = Math.max(t, Math.min(e, this.y))), (this.z = Math.max(t, Math.min(e, this.z))), (this.w = Math.max(t, Math.min(e, this.w))), this;
					}
					clampLength(t, e) {
						const n = this.length();
						return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
					}
					floor() {
						return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), (this.z = Math.floor(this.z)), (this.w = Math.floor(this.w)), this;
					}
					ceil() {
						return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), (this.z = Math.ceil(this.z)), (this.w = Math.ceil(this.w)), this;
					}
					round() {
						return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), (this.z = Math.round(this.z)), (this.w = Math.round(this.w)), this;
					}
					roundToZero() {
						return (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)), (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)), (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)), (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)), this;
					}
					negate() {
						return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), (this.w = -this.w), this;
					}
					dot(t) {
						return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
					}
					lengthSq() {
						return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
					}
					length() {
						return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
					}
					manhattanLength() {
						return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
					}
					normalize() {
						return this.divideScalar(this.length() || 1);
					}
					setLength(t) {
						return this.normalize().multiplyScalar(t);
					}
					lerp(t, e) {
						return (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), (this.z += (t.z - this.z) * e), (this.w += (t.w - this.w) * e), this;
					}
					lerpVectors(t, e, n) {
						return (this.x = t.x + (e.x - t.x) * n), (this.y = t.y + (e.y - t.y) * n), (this.z = t.z + (e.z - t.z) * n), (this.w = t.w + (e.w - t.w) * n), this;
					}
					equals(t) {
						return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
					}
					fromArray(t, e = 0) {
						return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), (this.w = t[e + 3]), this;
					}
					toArray(t = [], e = 0) {
						return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), (t[e + 3] = this.w), t;
					}
					fromBufferAttribute(t, e, n) {
						return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), (this.x = t.getX(e)), (this.y = t.getY(e)), (this.z = t.getZ(e)), (this.w = t.getW(e)), this;
					}
					random() {
						return (this.x = Math.random()), (this.y = Math.random()), (this.z = Math.random()), (this.w = Math.random()), this;
					}
					*[Symbol.iterator]() {
						yield this.x, yield this.y, yield this.z, yield this.w;
					}
				}
				Ht.prototype.isVector4 = !0;
				class Gt extends xt {
					constructor(t, e, n = {}) {
						super(),
							(this.width = t),
							(this.height = e),
							(this.depth = 1),
							(this.scissor = new Ht(0, 0, t, e)),
							(this.scissorTest = !1),
							(this.viewport = new Ht(0, 0, t, e)),
							(this.texture = new Ft(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding)),
							(this.texture.isRenderTargetTexture = !0),
							(this.texture.image = { width: t, height: e, depth: 1 }),
							(this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps),
							(this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null),
							(this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : X),
							(this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
							(this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer),
							(this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null);
					}
					setTexture(t) {
						(t.image = { width: this.width, height: this.height, depth: this.depth }), (this.texture = t);
					}
					setSize(t, e, n = 1) {
						(this.width === t && this.height === e && this.depth === n) || ((this.width = t), (this.height = e), (this.depth = n), (this.texture.image.width = t), (this.texture.image.height = e), (this.texture.image.depth = n), this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
					}
					clone() {
						return new this.constructor().copy(this);
					}
					copy(t) {
						return (this.width = t.width), (this.height = t.height), (this.depth = t.depth), this.viewport.copy(t.viewport), (this.texture = t.texture.clone()), (this.texture.image = { ...this.texture.image }), (this.depthBuffer = t.depthBuffer), (this.stencilBuffer = t.stencilBuffer), (this.depthTexture = t.depthTexture), this;
					}
					dispose() {
						this.dispatchEvent({ type: "dispose" });
					}
				}
				Gt.prototype.isWebGLRenderTarget = !0;
				(class extends Gt {
					constructor(t, e, n) {
						super(t, e);
						const i = this.texture;
						this.texture = [];
						for (let t = 0; t < n; t++) this.texture[t] = i.clone();
					}
					setSize(t, e, n = 1) {
						if (this.width !== t || this.height !== e || this.depth !== n) {
							(this.width = t), (this.height = e), (this.depth = n);
							for (let i = 0, r = this.texture.length; i < r; i++) (this.texture[i].image.width = t), (this.texture[i].image.height = e), (this.texture[i].image.depth = n);
							this.dispose();
						}
						return this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this;
					}
					copy(t) {
						this.dispose(), (this.width = t.width), (this.height = t.height), (this.depth = t.depth), this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), (this.depthBuffer = t.depthBuffer), (this.stencilBuffer = t.stencilBuffer), (this.depthTexture = t.depthTexture), (this.texture.length = 0);
						for (let e = 0, n = t.texture.length; e < n; e++) this.texture[e] = t.texture[e].clone();
						return this;
					}
				}.prototype.isWebGLMultipleRenderTargets = !0);
				class Wt extends Gt {
					constructor(t, e, n) {
						super(t, e, n), (this.samples = 4);
					}
					copy(t) {
						return super.copy.call(this, t), (this.samples = t.samples), this;
					}
				}
				Wt.prototype.isWebGLMultisampleRenderTarget = !0;
				class jt {
					constructor(t = 0, e = 0, n = 0, i = 1) {
						(this._x = t), (this._y = e), (this._z = n), (this._w = i);
					}
					static slerp(t, e, n, i) {
						return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(t, e, i);
					}
					static slerpFlat(t, e, n, i, r, a, s) {
						let o = n[i + 0],
							l = n[i + 1],
							c = n[i + 2],
							u = n[i + 3];
						const h = r[a + 0],
							d = r[a + 1],
							p = r[a + 2],
							f = r[a + 3];
						if (0 === s) return (t[e + 0] = o), (t[e + 1] = l), (t[e + 2] = c), void (t[e + 3] = u);
						if (1 === s) return (t[e + 0] = h), (t[e + 1] = d), (t[e + 2] = p), void (t[e + 3] = f);
						if (u !== f || o !== h || l !== d || c !== p) {
							let t = 1 - s;
							const e = o * h + l * d + c * p + u * f,
								n = e >= 0 ? 1 : -1,
								i = 1 - e * e;
							if (i > Number.EPSILON) {
								const r = Math.sqrt(i),
									a = Math.atan2(r, e * n);
								(t = Math.sin(t * a) / r), (s = Math.sin(s * a) / r);
							}
							const r = s * n;
							if (((o = o * t + h * r), (l = l * t + d * r), (c = c * t + p * r), (u = u * t + f * r), t === 1 - s)) {
								const t = 1 / Math.sqrt(o * o + l * l + c * c + u * u);
								(o *= t), (l *= t), (c *= t), (u *= t);
							}
						}
						(t[e] = o), (t[e + 1] = l), (t[e + 2] = c), (t[e + 3] = u);
					}
					static multiplyQuaternionsFlat(t, e, n, i, r, a) {
						const s = n[i],
							o = n[i + 1],
							l = n[i + 2],
							c = n[i + 3],
							u = r[a],
							h = r[a + 1],
							d = r[a + 2],
							p = r[a + 3];
						return (t[e] = s * p + c * u + o * d - l * h), (t[e + 1] = o * p + c * h + l * u - s * d), (t[e + 2] = l * p + c * d + s * h - o * u), (t[e + 3] = c * p - s * u - o * h - l * d), t;
					}
					get x() {
						return this._x;
					}
					set x(t) {
						(this._x = t), this._onChangeCallback();
					}
					get y() {
						return this._y;
					}
					set y(t) {
						(this._y = t), this._onChangeCallback();
					}
					get z() {
						return this._z;
					}
					set z(t) {
						(this._z = t), this._onChangeCallback();
					}
					get w() {
						return this._w;
					}
					set w(t) {
						(this._w = t), this._onChangeCallback();
					}
					set(t, e, n, i) {
						return (this._x = t), (this._y = e), (this._z = n), (this._w = i), this._onChangeCallback(), this;
					}
					clone() {
						return new this.constructor(this._x, this._y, this._z, this._w);
					}
					copy(t) {
						return (this._x = t.x), (this._y = t.y), (this._z = t.z), (this._w = t.w), this._onChangeCallback(), this;
					}
					setFromEuler(t, e) {
						if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
						const n = t._x,
							i = t._y,
							r = t._z,
							a = t._order,
							s = Math.cos,
							o = Math.sin,
							l = s(n / 2),
							c = s(i / 2),
							u = s(r / 2),
							h = o(n / 2),
							d = o(i / 2),
							p = o(r / 2);
						switch (a) {
							case "XYZ":
								(this._x = h * c * u + l * d * p), (this._y = l * d * u - h * c * p), (this._z = l * c * p + h * d * u), (this._w = l * c * u - h * d * p);
								break;
							case "YXZ":
								(this._x = h * c * u + l * d * p), (this._y = l * d * u - h * c * p), (this._z = l * c * p - h * d * u), (this._w = l * c * u + h * d * p);
								break;
							case "ZXY":
								(this._x = h * c * u - l * d * p), (this._y = l * d * u + h * c * p), (this._z = l * c * p + h * d * u), (this._w = l * c * u - h * d * p);
								break;
							case "ZYX":
								(this._x = h * c * u - l * d * p), (this._y = l * d * u + h * c * p), (this._z = l * c * p - h * d * u), (this._w = l * c * u + h * d * p);
								break;
							case "YZX":
								(this._x = h * c * u + l * d * p), (this._y = l * d * u + h * c * p), (this._z = l * c * p - h * d * u), (this._w = l * c * u - h * d * p);
								break;
							case "XZY":
								(this._x = h * c * u - l * d * p), (this._y = l * d * u - h * c * p), (this._z = l * c * p + h * d * u), (this._w = l * c * u + h * d * p);
								break;
							default:
								console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
						}
						return !1 !== e && this._onChangeCallback(), this;
					}
					setFromAxisAngle(t, e) {
						const n = e / 2,
							i = Math.sin(n);
						return (this._x = t.x * i), (this._y = t.y * i), (this._z = t.z * i), (this._w = Math.cos(n)), this._onChangeCallback(), this;
					}
					setFromRotationMatrix(t) {
						const e = t.elements,
							n = e[0],
							i = e[4],
							r = e[8],
							a = e[1],
							s = e[5],
							o = e[9],
							l = e[2],
							c = e[6],
							u = e[10],
							h = n + s + u;
						if (h > 0) {
							const t = 0.5 / Math.sqrt(h + 1);
							(this._w = 0.25 / t), (this._x = (c - o) * t), (this._y = (r - l) * t), (this._z = (a - i) * t);
						} else if (n > s && n > u) {
							const t = 2 * Math.sqrt(1 + n - s - u);
							(this._w = (c - o) / t), (this._x = 0.25 * t), (this._y = (i + a) / t), (this._z = (r + l) / t);
						} else if (s > u) {
							const t = 2 * Math.sqrt(1 + s - n - u);
							(this._w = (r - l) / t), (this._x = (i + a) / t), (this._y = 0.25 * t), (this._z = (o + c) / t);
						} else {
							const t = 2 * Math.sqrt(1 + u - n - s);
							(this._w = (a - i) / t), (this._x = (r + l) / t), (this._y = (o + c) / t), (this._z = 0.25 * t);
						}
						return this._onChangeCallback(), this;
					}
					setFromUnitVectors(t, e) {
						let n = t.dot(e) + 1;
						return n < Number.EPSILON ? ((n = 0), Math.abs(t.x) > Math.abs(t.z) ? ((this._x = -t.y), (this._y = t.x), (this._z = 0), (this._w = n)) : ((this._x = 0), (this._y = -t.z), (this._z = t.y), (this._w = n))) : ((this._x = t.y * e.z - t.z * e.y), (this._y = t.z * e.x - t.x * e.z), (this._z = t.x * e.y - t.y * e.x), (this._w = n)), this.normalize();
					}
					angleTo(t) {
						return 2 * Math.acos(Math.abs(Et(this.dot(t), -1, 1)));
					}
					rotateTowards(t, e) {
						const n = this.angleTo(t);
						if (0 === n) return this;
						const i = Math.min(1, e / n);
						return this.slerp(t, i), this;
					}
					identity() {
						return this.set(0, 0, 0, 1);
					}
					invert() {
						return this.conjugate();
					}
					conjugate() {
						return (this._x *= -1), (this._y *= -1), (this._z *= -1), this._onChangeCallback(), this;
					}
					dot(t) {
						return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
					}
					lengthSq() {
						return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
					}
					length() {
						return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
					}
					normalize() {
						let t = this.length();
						return 0 === t ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1)) : ((t = 1 / t), (this._x = this._x * t), (this._y = this._y * t), (this._z = this._z * t), (this._w = this._w * t)), this._onChangeCallback(), this;
					}
					multiply(t, e) {
						return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t);
					}
					premultiply(t) {
						return this.multiplyQuaternions(t, this);
					}
					multiplyQuaternions(t, e) {
						const n = t._x,
							i = t._y,
							r = t._z,
							a = t._w,
							s = e._x,
							o = e._y,
							l = e._z,
							c = e._w;
						return (this._x = n * c + a * s + i * l - r * o), (this._y = i * c + a * o + r * s - n * l), (this._z = r * c + a * l + n * o - i * s), (this._w = a * c - n * s - i * o - r * l), this._onChangeCallback(), this;
					}
					slerp(t, e) {
						if (0 === e) return this;
						if (1 === e) return this.copy(t);
						const n = this._x,
							i = this._y,
							r = this._z,
							a = this._w;
						let s = a * t._w + n * t._x + i * t._y + r * t._z;
						if ((s < 0 ? ((this._w = -t._w), (this._x = -t._x), (this._y = -t._y), (this._z = -t._z), (s = -s)) : this.copy(t), s >= 1)) return (this._w = a), (this._x = n), (this._y = i), (this._z = r), this;
						const o = 1 - s * s;
						if (o <= Number.EPSILON) {
							const t = 1 - e;
							return (this._w = t * a + e * this._w), (this._x = t * n + e * this._x), (this._y = t * i + e * this._y), (this._z = t * r + e * this._z), this.normalize(), this._onChangeCallback(), this;
						}
						const l = Math.sqrt(o),
							c = Math.atan2(l, s),
							u = Math.sin((1 - e) * c) / l,
							h = Math.sin(e * c) / l;
						return (this._w = a * u + this._w * h), (this._x = n * u + this._x * h), (this._y = i * u + this._y * h), (this._z = r * u + this._z * h), this._onChangeCallback(), this;
					}
					slerpQuaternions(t, e, n) {
						this.copy(t).slerp(e, n);
					}
					random() {
						const t = Math.random(),
							e = Math.sqrt(1 - t),
							n = Math.sqrt(t),
							i = 2 * Math.PI * Math.random(),
							r = 2 * Math.PI * Math.random();
						return this.set(e * Math.cos(i), n * Math.sin(r), n * Math.cos(r), e * Math.sin(i));
					}
					equals(t) {
						return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
					}
					fromArray(t, e = 0) {
						return (this._x = t[e]), (this._y = t[e + 1]), (this._z = t[e + 2]), (this._w = t[e + 3]), this._onChangeCallback(), this;
					}
					toArray(t = [], e = 0) {
						return (t[e] = this._x), (t[e + 1] = this._y), (t[e + 2] = this._z), (t[e + 3] = this._w), t;
					}
					fromBufferAttribute(t, e) {
						return (this._x = t.getX(e)), (this._y = t.getY(e)), (this._z = t.getZ(e)), (this._w = t.getW(e)), this;
					}
					_onChange(t) {
						return (this._onChangeCallback = t), this;
					}
					_onChangeCallback() {}
				}
				jt.prototype.isQuaternion = !0;
				class Xt {
					constructor(t = 0, e = 0, n = 0) {
						(this.x = t), (this.y = e), (this.z = n);
					}
					set(t, e, n) {
						return void 0 === n && (n = this.z), (this.x = t), (this.y = e), (this.z = n), this;
					}
					setScalar(t) {
						return (this.x = t), (this.y = t), (this.z = t), this;
					}
					setX(t) {
						return (this.x = t), this;
					}
					setY(t) {
						return (this.y = t), this;
					}
					setZ(t) {
						return (this.z = t), this;
					}
					setComponent(t, e) {
						switch (t) {
							case 0:
								this.x = e;
								break;
							case 1:
								this.y = e;
								break;
							case 2:
								this.z = e;
								break;
							default:
								throw new Error("index is out of range: " + t);
						}
						return this;
					}
					getComponent(t) {
						switch (t) {
							case 0:
								return this.x;
							case 1:
								return this.y;
							case 2:
								return this.z;
							default:
								throw new Error("index is out of range: " + t);
						}
					}
					clone() {
						return new this.constructor(this.x, this.y, this.z);
					}
					copy(t) {
						return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
					}
					add(t, e) {
						return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
					}
					addScalar(t) {
						return (this.x += t), (this.y += t), (this.z += t), this;
					}
					addVectors(t, e) {
						return (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this;
					}
					addScaledVector(t, e) {
						return (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this;
					}
					sub(t, e) {
						return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
					}
					subScalar(t) {
						return (this.x -= t), (this.y -= t), (this.z -= t), this;
					}
					subVectors(t, e) {
						return (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this;
					}
					multiply(t, e) {
						return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
					}
					multiplyScalar(t) {
						return (this.x *= t), (this.y *= t), (this.z *= t), this;
					}
					multiplyVectors(t, e) {
						return (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this;
					}
					applyEuler(t) {
						return (t && t.isEuler) || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Yt.setFromEuler(t));
					}
					applyAxisAngle(t, e) {
						return this.applyQuaternion(Yt.setFromAxisAngle(t, e));
					}
					applyMatrix3(t) {
						const e = this.x,
							n = this.y,
							i = this.z,
							r = t.elements;
						return (this.x = r[0] * e + r[3] * n + r[6] * i), (this.y = r[1] * e + r[4] * n + r[7] * i), (this.z = r[2] * e + r[5] * n + r[8] * i), this;
					}
					applyNormalMatrix(t) {
						return this.applyMatrix3(t).normalize();
					}
					applyMatrix4(t) {
						const e = this.x,
							n = this.y,
							i = this.z,
							r = t.elements,
							a = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
						return (this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * a), (this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * a), (this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * a), this;
					}
					applyQuaternion(t) {
						const e = this.x,
							n = this.y,
							i = this.z,
							r = t.x,
							a = t.y,
							s = t.z,
							o = t.w,
							l = o * e + a * i - s * n,
							c = o * n + s * e - r * i,
							u = o * i + r * n - a * e,
							h = -r * e - a * n - s * i;
						return (this.x = l * o + h * -r + c * -s - u * -a), (this.y = c * o + h * -a + u * -r - l * -s), (this.z = u * o + h * -s + l * -a - c * -r), this;
					}
					project(t) {
						return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
					}
					unproject(t) {
						return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
					}
					transformDirection(t) {
						const e = this.x,
							n = this.y,
							i = this.z,
							r = t.elements;
						return (this.x = r[0] * e + r[4] * n + r[8] * i), (this.y = r[1] * e + r[5] * n + r[9] * i), (this.z = r[2] * e + r[6] * n + r[10] * i), this.normalize();
					}
					divide(t) {
						return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
					}
					divideScalar(t) {
						return this.multiplyScalar(1 / t);
					}
					min(t) {
						return (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), (this.z = Math.min(this.z, t.z)), this;
					}
					max(t) {
						return (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), (this.z = Math.max(this.z, t.z)), this;
					}
					clamp(t, e) {
						return (this.x = Math.max(t.x, Math.min(e.x, this.x))), (this.y = Math.max(t.y, Math.min(e.y, this.y))), (this.z = Math.max(t.z, Math.min(e.z, this.z))), this;
					}
					clampScalar(t, e) {
						return (this.x = Math.max(t, Math.min(e, this.x))), (this.y = Math.max(t, Math.min(e, this.y))), (this.z = Math.max(t, Math.min(e, this.z))), this;
					}
					clampLength(t, e) {
						const n = this.length();
						return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
					}
					floor() {
						return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), (this.z = Math.floor(this.z)), this;
					}
					ceil() {
						return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), (this.z = Math.ceil(this.z)), this;
					}
					round() {
						return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), (this.z = Math.round(this.z)), this;
					}
					roundToZero() {
						return (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)), (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)), (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)), this;
					}
					negate() {
						return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
					}
					dot(t) {
						return this.x * t.x + this.y * t.y + this.z * t.z;
					}
					lengthSq() {
						return this.x * this.x + this.y * this.y + this.z * this.z;
					}
					length() {
						return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
					}
					manhattanLength() {
						return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
					}
					normalize() {
						return this.divideScalar(this.length() || 1);
					}
					setLength(t) {
						return this.normalize().multiplyScalar(t);
					}
					lerp(t, e) {
						return (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), (this.z += (t.z - this.z) * e), this;
					}
					lerpVectors(t, e, n) {
						return (this.x = t.x + (e.x - t.x) * n), (this.y = t.y + (e.y - t.y) * n), (this.z = t.z + (e.z - t.z) * n), this;
					}
					cross(t, e) {
						return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t);
					}
					crossVectors(t, e) {
						const n = t.x,
							i = t.y,
							r = t.z,
							a = e.x,
							s = e.y,
							o = e.z;
						return (this.x = i * o - r * s), (this.y = r * a - n * o), (this.z = n * s - i * a), this;
					}
					projectOnVector(t) {
						const e = t.lengthSq();
						if (0 === e) return this.set(0, 0, 0);
						const n = t.dot(this) / e;
						return this.copy(t).multiplyScalar(n);
					}
					projectOnPlane(t) {
						return qt.copy(this).projectOnVector(t), this.sub(qt);
					}
					reflect(t) {
						return this.sub(qt.copy(t).multiplyScalar(2 * this.dot(t)));
					}
					angleTo(t) {
						const e = Math.sqrt(this.lengthSq() * t.lengthSq());
						if (0 === e) return Math.PI / 2;
						const n = this.dot(t) / e;
						return Math.acos(Et(n, -1, 1));
					}
					distanceTo(t) {
						return Math.sqrt(this.distanceToSquared(t));
					}
					distanceToSquared(t) {
						const e = this.x - t.x,
							n = this.y - t.y,
							i = this.z - t.z;
						return e * e + n * n + i * i;
					}
					manhattanDistanceTo(t) {
						return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
					}
					setFromSpherical(t) {
						return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
					}
					setFromSphericalCoords(t, e, n) {
						const i = Math.sin(e) * t;
						return (this.x = i * Math.sin(n)), (this.y = Math.cos(e) * t), (this.z = i * Math.cos(n)), this;
					}
					setFromCylindrical(t) {
						return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
					}
					setFromCylindricalCoords(t, e, n) {
						return (this.x = t * Math.sin(e)), (this.y = n), (this.z = t * Math.cos(e)), this;
					}
					setFromMatrixPosition(t) {
						const e = t.elements;
						return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
					}
					setFromMatrixScale(t) {
						const e = this.setFromMatrixColumn(t, 0).length(),
							n = this.setFromMatrixColumn(t, 1).length(),
							i = this.setFromMatrixColumn(t, 2).length();
						return (this.x = e), (this.y = n), (this.z = i), this;
					}
					setFromMatrixColumn(t, e) {
						return this.fromArray(t.elements, 4 * e);
					}
					setFromMatrix3Column(t, e) {
						return this.fromArray(t.elements, 3 * e);
					}
					equals(t) {
						return t.x === this.x && t.y === this.y && t.z === this.z;
					}
					fromArray(t, e = 0) {
						return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this;
					}
					toArray(t = [], e = 0) {
						return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
					}
					fromBufferAttribute(t, e, n) {
						return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), (this.x = t.getX(e)), (this.y = t.getY(e)), (this.z = t.getZ(e)), this;
					}
					random() {
						return (this.x = Math.random()), (this.y = Math.random()), (this.z = Math.random()), this;
					}
					randomDirection() {
						const t = 2 * (Math.random() - 0.5),
							e = Math.random() * Math.PI * 2,
							n = Math.sqrt(1 - t ** 2);
						return (this.x = n * Math.cos(e)), (this.y = n * Math.sin(e)), (this.z = t), this;
					}
					*[Symbol.iterator]() {
						yield this.x, yield this.y, yield this.z;
					}
				}
				Xt.prototype.isVector3 = !0;
				const qt = new Xt(),
					Yt = new jt();
				class Zt {
					constructor(t = new Xt(1 / 0, 1 / 0, 1 / 0), e = new Xt(-1 / 0, -1 / 0, -1 / 0)) {
						(this.min = t), (this.max = e);
					}
					set(t, e) {
						return this.min.copy(t), this.max.copy(e), this;
					}
					setFromArray(t) {
						let e = 1 / 0,
							n = 1 / 0,
							i = 1 / 0,
							r = -1 / 0,
							a = -1 / 0,
							s = -1 / 0;
						for (let o = 0, l = t.length; o < l; o += 3) {
							const l = t[o],
								c = t[o + 1],
								u = t[o + 2];
							l < e && (e = l), c < n && (n = c), u < i && (i = u), l > r && (r = l), c > a && (a = c), u > s && (s = u);
						}
						return this.min.set(e, n, i), this.max.set(r, a, s), this;
					}
					setFromBufferAttribute(t) {
						let e = 1 / 0,
							n = 1 / 0,
							i = 1 / 0,
							r = -1 / 0,
							a = -1 / 0,
							s = -1 / 0;
						for (let o = 0, l = t.count; o < l; o++) {
							const l = t.getX(o),
								c = t.getY(o),
								u = t.getZ(o);
							l < e && (e = l), c < n && (n = c), u < i && (i = u), l > r && (r = l), c > a && (a = c), u > s && (s = u);
						}
						return this.min.set(e, n, i), this.max.set(r, a, s), this;
					}
					setFromPoints(t) {
						this.makeEmpty();
						for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
						return this;
					}
					setFromCenterAndSize(t, e) {
						const n = Jt.copy(e).multiplyScalar(0.5);
						return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
					}
					setFromObject(t) {
						return this.makeEmpty(), this.expandByObject(t);
					}
					clone() {
						return new this.constructor().copy(this);
					}
					copy(t) {
						return this.min.copy(t.min), this.max.copy(t.max), this;
					}
					makeEmpty() {
						return (this.min.x = this.min.y = this.min.z = 1 / 0), (this.max.x = this.max.y = this.max.z = -1 / 0), this;
					}
					isEmpty() {
						return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
					}
					getCenter(t) {
						return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
					}
					getSize(t) {
						return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
					}
					expandByPoint(t) {
						return this.min.min(t), this.max.max(t), this;
					}
					expandByVector(t) {
						return this.min.sub(t), this.max.add(t), this;
					}
					expandByScalar(t) {
						return this.min.addScalar(-t), this.max.addScalar(t), this;
					}
					expandByObject(t) {
						t.updateWorldMatrix(!1, !1);
						const e = t.geometry;
						void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), Qt.copy(e.boundingBox), Qt.applyMatrix4(t.matrixWorld), this.union(Qt));
						const n = t.children;
						for (let t = 0, e = n.length; t < e; t++) this.expandByObject(n[t]);
						return this;
					}
					containsPoint(t) {
						return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z);
					}
					containsBox(t) {
						return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z;
					}
					getParameter(t, e) {
						return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z));
					}
					intersectsBox(t) {
						return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z);
					}
					intersectsSphere(t) {
						return this.clampPoint(t.center, Jt), Jt.distanceToSquared(t.center) <= t.radius * t.radius;
					}
					intersectsPlane(t) {
						let e, n;
						return (
							t.normal.x > 0 ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x)) : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
							t.normal.y > 0 ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y)) : ((e += t.normal.y * this.max.y), (n += t.normal.y * this.min.y)),
							t.normal.z > 0 ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z)) : ((e += t.normal.z * this.max.z), (n += t.normal.z * this.min.z)),
							e <= -t.constant && n >= -t.constant
						);
					}
					intersectsTriangle(t) {
						if (this.isEmpty()) return !1;
						this.getCenter(ae), se.subVectors(this.max, ae), $t.subVectors(t.a, ae), te.subVectors(t.b, ae), ee.subVectors(t.c, ae), ne.subVectors(te, $t), ie.subVectors(ee, te), re.subVectors($t, ee);
						let e = [0, -ne.z, ne.y, 0, -ie.z, ie.y, 0, -re.z, re.y, ne.z, 0, -ne.x, ie.z, 0, -ie.x, re.z, 0, -re.x, -ne.y, ne.x, 0, -ie.y, ie.x, 0, -re.y, re.x, 0];
						return !!ce(e, $t, te, ee, se) && ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !!ce(e, $t, te, ee, se) && (oe.crossVectors(ne, ie), (e = [oe.x, oe.y, oe.z]), ce(e, $t, te, ee, se)));
					}
					clampPoint(t, e) {
						return e.copy(t).clamp(this.min, this.max);
					}
					distanceToPoint(t) {
						return Jt.copy(t).clamp(this.min, this.max).sub(t).length();
					}
					getBoundingSphere(t) {
						return this.getCenter(t.center), (t.radius = 0.5 * this.getSize(Jt).length()), t;
					}
					intersect(t) {
						return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
					}
					union(t) {
						return this.min.min(t.min), this.max.max(t.max), this;
					}
					applyMatrix4(t) {
						return (
							this.isEmpty() ||
								(Kt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
								Kt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
								Kt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
								Kt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
								Kt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
								Kt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
								Kt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
								Kt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
								this.setFromPoints(Kt)),
							this
						);
					}
					translate(t) {
						return this.min.add(t), this.max.add(t), this;
					}
					equals(t) {
						return t.min.equals(this.min) && t.max.equals(this.max);
					}
				}
				Zt.prototype.isBox3 = !0;
				const Kt = [new Xt(), new Xt(), new Xt(), new Xt(), new Xt(), new Xt(), new Xt(), new Xt()],
					Jt = new Xt(),
					Qt = new Zt(),
					$t = new Xt(),
					te = new Xt(),
					ee = new Xt(),
					ne = new Xt(),
					ie = new Xt(),
					re = new Xt(),
					ae = new Xt(),
					se = new Xt(),
					oe = new Xt(),
					le = new Xt();
				function ce(t, e, n, i, r) {
					for (let a = 0, s = t.length - 3; a <= s; a += 3) {
						le.fromArray(t, a);
						const s = r.x * Math.abs(le.x) + r.y * Math.abs(le.y) + r.z * Math.abs(le.z),
							o = e.dot(le),
							l = n.dot(le),
							c = i.dot(le);
						if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > s) return !1;
					}
					return !0;
				}
				const ue = new Zt(),
					he = new Xt(),
					de = new Xt(),
					pe = new Xt();
				class fe {
					constructor(t = new Xt(), e = -1) {
						(this.center = t), (this.radius = e);
					}
					set(t, e) {
						return this.center.copy(t), (this.radius = e), this;
					}
					setFromPoints(t, e) {
						const n = this.center;
						void 0 !== e ? n.copy(e) : ue.setFromPoints(t).getCenter(n);
						let i = 0;
						for (let e = 0, r = t.length; e < r; e++) i = Math.max(i, n.distanceToSquared(t[e]));
						return (this.radius = Math.sqrt(i)), this;
					}
					copy(t) {
						return this.center.copy(t.center), (this.radius = t.radius), this;
					}
					isEmpty() {
						return this.radius < 0;
					}
					makeEmpty() {
						return this.center.set(0, 0, 0), (this.radius = -1), this;
					}
					containsPoint(t) {
						return t.distanceToSquared(this.center) <= this.radius * this.radius;
					}
					distanceToPoint(t) {
						return t.distanceTo(this.center) - this.radius;
					}
					intersectsSphere(t) {
						const e = this.radius + t.radius;
						return t.center.distanceToSquared(this.center) <= e * e;
					}
					intersectsBox(t) {
						return t.intersectsSphere(this);
					}
					intersectsPlane(t) {
						return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
					}
					clampPoint(t, e) {
						const n = this.center.distanceToSquared(t);
						return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
					}
					getBoundingBox(t) {
						return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
					}
					applyMatrix4(t) {
						return this.center.applyMatrix4(t), (this.radius = this.radius * t.getMaxScaleOnAxis()), this;
					}
					translate(t) {
						return this.center.add(t), this;
					}
					expandByPoint(t) {
						pe.subVectors(t, this.center);
						const e = pe.lengthSq();
						if (e > this.radius * this.radius) {
							const t = Math.sqrt(e),
								n = 0.5 * (t - this.radius);
							this.center.add(pe.multiplyScalar(n / t)), (this.radius += n);
						}
						return this;
					}
					union(t) {
						return de.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(he.copy(t.center).add(de)), this.expandByPoint(he.copy(t.center).sub(de)), this;
					}
					equals(t) {
						return t.center.equals(this.center) && t.radius === this.radius;
					}
					clone() {
						return new this.constructor().copy(this);
					}
				}
				const me = new Xt(),
					ve = new Xt(),
					ge = new Xt(),
					be = new Xt(),
					xe = new Xt(),
					ye = new Xt(),
					_e = new Xt();
				class we {
					constructor(t = new Xt(), e = new Xt(0, 0, -1)) {
						(this.origin = t), (this.direction = e);
					}
					set(t, e) {
						return this.origin.copy(t), this.direction.copy(e), this;
					}
					copy(t) {
						return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
					}
					at(t, e) {
						return e.copy(this.direction).multiplyScalar(t).add(this.origin);
					}
					lookAt(t) {
						return this.direction.copy(t).sub(this.origin).normalize(), this;
					}
					recast(t) {
						return this.origin.copy(this.at(t, me)), this;
					}
					closestPointToPoint(t, e) {
						e.subVectors(t, this.origin);
						const n = e.dot(this.direction);
						return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin);
					}
					distanceToPoint(t) {
						return Math.sqrt(this.distanceSqToPoint(t));
					}
					distanceSqToPoint(t) {
						const e = me.subVectors(t, this.origin).dot(this.direction);
						return e < 0 ? this.origin.distanceToSquared(t) : (me.copy(this.direction).multiplyScalar(e).add(this.origin), me.distanceToSquared(t));
					}
					distanceSqToSegment(t, e, n, i) {
						ve.copy(t).add(e).multiplyScalar(0.5), ge.copy(e).sub(t).normalize(), be.copy(this.origin).sub(ve);
						const r = 0.5 * t.distanceTo(e),
							a = -this.direction.dot(ge),
							s = be.dot(this.direction),
							o = -be.dot(ge),
							l = be.lengthSq(),
							c = Math.abs(1 - a * a);
						let u, h, d, p;
						if (c > 0)
							if (((u = a * o - s), (h = a * s - o), (p = r * c), u >= 0))
								if (h >= -p)
									if (h <= p) {
										const t = 1 / c;
										(u *= t), (h *= t), (d = u * (u + a * h + 2 * s) + h * (a * u + h + 2 * o) + l);
									} else (h = r), (u = Math.max(0, -(a * h + s))), (d = -u * u + h * (h + 2 * o) + l);
								else (h = -r), (u = Math.max(0, -(a * h + s))), (d = -u * u + h * (h + 2 * o) + l);
							else h <= -p ? ((u = Math.max(0, -(-a * r + s))), (h = u > 0 ? -r : Math.min(Math.max(-r, -o), r)), (d = -u * u + h * (h + 2 * o) + l)) : h <= p ? ((u = 0), (h = Math.min(Math.max(-r, -o), r)), (d = h * (h + 2 * o) + l)) : ((u = Math.max(0, -(a * r + s))), (h = u > 0 ? r : Math.min(Math.max(-r, -o), r)), (d = -u * u + h * (h + 2 * o) + l));
						else (h = a > 0 ? -r : r), (u = Math.max(0, -(a * h + s))), (d = -u * u + h * (h + 2 * o) + l);
						return n && n.copy(this.direction).multiplyScalar(u).add(this.origin), i && i.copy(ge).multiplyScalar(h).add(ve), d;
					}
					intersectSphere(t, e) {
						me.subVectors(t.center, this.origin);
						const n = me.dot(this.direction),
							i = me.dot(me) - n * n,
							r = t.radius * t.radius;
						if (i > r) return null;
						const a = Math.sqrt(r - i),
							s = n - a,
							o = n + a;
						return s < 0 && o < 0 ? null : s < 0 ? this.at(o, e) : this.at(s, e);
					}
					intersectsSphere(t) {
						return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
					}
					distanceToPlane(t) {
						const e = t.normal.dot(this.direction);
						if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
						const n = -(this.origin.dot(t.normal) + t.constant) / e;
						return n >= 0 ? n : null;
					}
					intersectPlane(t, e) {
						const n = this.distanceToPlane(t);
						return null === n ? null : this.at(n, e);
					}
					intersectsPlane(t) {
						const e = t.distanceToPoint(this.origin);
						if (0 === e) return !0;
						return t.normal.dot(this.direction) * e < 0;
					}
					intersectBox(t, e) {
						let n, i, r, a, s, o;
						const l = 1 / this.direction.x,
							c = 1 / this.direction.y,
							u = 1 / this.direction.z,
							h = this.origin;
						return (
							l >= 0 ? ((n = (t.min.x - h.x) * l), (i = (t.max.x - h.x) * l)) : ((n = (t.max.x - h.x) * l), (i = (t.min.x - h.x) * l)),
							c >= 0 ? ((r = (t.min.y - h.y) * c), (a = (t.max.y - h.y) * c)) : ((r = (t.max.y - h.y) * c), (a = (t.min.y - h.y) * c)),
							n > a || r > i ? null : ((r > n || n != n) && (n = r), (a < i || i != i) && (i = a), u >= 0 ? ((s = (t.min.z - h.z) * u), (o = (t.max.z - h.z) * u)) : ((s = (t.max.z - h.z) * u), (o = (t.min.z - h.z) * u)), n > o || s > i ? null : ((s > n || n != n) && (n = s), (o < i || i != i) && (i = o), i < 0 ? null : this.at(n >= 0 ? n : i, e)))
						);
					}
					intersectsBox(t) {
						return null !== this.intersectBox(t, me);
					}
					intersectTriangle(t, e, n, i, r) {
						xe.subVectors(e, t), ye.subVectors(n, t), _e.crossVectors(xe, ye);
						let a,
							s = this.direction.dot(_e);
						if (s > 0) {
							if (i) return null;
							a = 1;
						} else {
							if (!(s < 0)) return null;
							(a = -1), (s = -s);
						}
						be.subVectors(this.origin, t);
						const o = a * this.direction.dot(ye.crossVectors(be, ye));
						if (o < 0) return null;
						const l = a * this.direction.dot(xe.cross(be));
						if (l < 0) return null;
						if (o + l > s) return null;
						const c = -a * be.dot(_e);
						return c < 0 ? null : this.at(c / s, r);
					}
					applyMatrix4(t) {
						return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
					}
					equals(t) {
						return t.origin.equals(this.origin) && t.direction.equals(this.direction);
					}
					clone() {
						return new this.constructor().copy(this);
					}
				}
				class Me {
					constructor() {
						(this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
					}
					set(t, e, n, i, r, a, s, o, l, c, u, h, d, p, f, m) {
						const v = this.elements;
						return (v[0] = t), (v[4] = e), (v[8] = n), (v[12] = i), (v[1] = r), (v[5] = a), (v[9] = s), (v[13] = o), (v[2] = l), (v[6] = c), (v[10] = u), (v[14] = h), (v[3] = d), (v[7] = p), (v[11] = f), (v[15] = m), this;
					}
					identity() {
						return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
					}
					clone() {
						return new Me().fromArray(this.elements);
					}
					copy(t) {
						const e = this.elements,
							n = t.elements;
						return (e[0] = n[0]), (e[1] = n[1]), (e[2] = n[2]), (e[3] = n[3]), (e[4] = n[4]), (e[5] = n[5]), (e[6] = n[6]), (e[7] = n[7]), (e[8] = n[8]), (e[9] = n[9]), (e[10] = n[10]), (e[11] = n[11]), (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), (e[15] = n[15]), this;
					}
					copyPosition(t) {
						const e = this.elements,
							n = t.elements;
						return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
					}
					setFromMatrix3(t) {
						const e = t.elements;
						return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this;
					}
					extractBasis(t, e, n) {
						return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
					}
					makeBasis(t, e, n) {
						return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this;
					}
					extractRotation(t) {
						const e = this.elements,
							n = t.elements,
							i = 1 / Se.setFromMatrixColumn(t, 0).length(),
							r = 1 / Se.setFromMatrixColumn(t, 1).length(),
							a = 1 / Se.setFromMatrixColumn(t, 2).length();
						return (e[0] = n[0] * i), (e[1] = n[1] * i), (e[2] = n[2] * i), (e[3] = 0), (e[4] = n[4] * r), (e[5] = n[5] * r), (e[6] = n[6] * r), (e[7] = 0), (e[8] = n[8] * a), (e[9] = n[9] * a), (e[10] = n[10] * a), (e[11] = 0), (e[12] = 0), (e[13] = 0), (e[14] = 0), (e[15] = 1), this;
					}
					makeRotationFromEuler(t) {
						(t && t.isEuler) || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
						const e = this.elements,
							n = t.x,
							i = t.y,
							r = t.z,
							a = Math.cos(n),
							s = Math.sin(n),
							o = Math.cos(i),
							l = Math.sin(i),
							c = Math.cos(r),
							u = Math.sin(r);
						if ("XYZ" === t.order) {
							const t = a * c,
								n = a * u,
								i = s * c,
								r = s * u;
							(e[0] = o * c), (e[4] = -o * u), (e[8] = l), (e[1] = n + i * l), (e[5] = t - r * l), (e[9] = -s * o), (e[2] = r - t * l), (e[6] = i + n * l), (e[10] = a * o);
						} else if ("YXZ" === t.order) {
							const t = o * c,
								n = o * u,
								i = l * c,
								r = l * u;
							(e[0] = t + r * s), (e[4] = i * s - n), (e[8] = a * l), (e[1] = a * u), (e[5] = a * c), (e[9] = -s), (e[2] = n * s - i), (e[6] = r + t * s), (e[10] = a * o);
						} else if ("ZXY" === t.order) {
							const t = o * c,
								n = o * u,
								i = l * c,
								r = l * u;
							(e[0] = t - r * s), (e[4] = -a * u), (e[8] = i + n * s), (e[1] = n + i * s), (e[5] = a * c), (e[9] = r - t * s), (e[2] = -a * l), (e[6] = s), (e[10] = a * o);
						} else if ("ZYX" === t.order) {
							const t = a * c,
								n = a * u,
								i = s * c,
								r = s * u;
							(e[0] = o * c), (e[4] = i * l - n), (e[8] = t * l + r), (e[1] = o * u), (e[5] = r * l + t), (e[9] = n * l - i), (e[2] = -l), (e[6] = s * o), (e[10] = a * o);
						} else if ("YZX" === t.order) {
							const t = a * o,
								n = a * l,
								i = s * o,
								r = s * l;
							(e[0] = o * c), (e[4] = r - t * u), (e[8] = i * u + n), (e[1] = u), (e[5] = a * c), (e[9] = -s * c), (e[2] = -l * c), (e[6] = n * u + i), (e[10] = t - r * u);
						} else if ("XZY" === t.order) {
							const t = a * o,
								n = a * l,
								i = s * o,
								r = s * l;
							(e[0] = o * c), (e[4] = -u), (e[8] = l * c), (e[1] = t * u + r), (e[5] = a * c), (e[9] = n * u - i), (e[2] = i * u - n), (e[6] = s * c), (e[10] = r * u + t);
						}
						return (e[3] = 0), (e[7] = 0), (e[11] = 0), (e[12] = 0), (e[13] = 0), (e[14] = 0), (e[15] = 1), this;
					}
					makeRotationFromQuaternion(t) {
						return this.compose(Ee, t, Ce);
					}
					lookAt(t, e, n) {
						const i = this.elements;
						return Le.subVectors(t, e), 0 === Le.lengthSq() && (Le.z = 1), Le.normalize(), Pe.crossVectors(n, Le), 0 === Pe.lengthSq() && (1 === Math.abs(n.z) ? (Le.x += 1e-4) : (Le.z += 1e-4), Le.normalize(), Pe.crossVectors(n, Le)), Pe.normalize(), Ae.crossVectors(Le, Pe), (i[0] = Pe.x), (i[4] = Ae.x), (i[8] = Le.x), (i[1] = Pe.y), (i[5] = Ae.y), (i[9] = Le.y), (i[2] = Pe.z), (i[6] = Ae.z), (i[10] = Le.z), this;
					}
					multiply(t, e) {
						return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t);
					}
					premultiply(t) {
						return this.multiplyMatrices(t, this);
					}
					multiplyMatrices(t, e) {
						const n = t.elements,
							i = e.elements,
							r = this.elements,
							a = n[0],
							s = n[4],
							o = n[8],
							l = n[12],
							c = n[1],
							u = n[5],
							h = n[9],
							d = n[13],
							p = n[2],
							f = n[6],
							m = n[10],
							v = n[14],
							g = n[3],
							b = n[7],
							x = n[11],
							y = n[15],
							_ = i[0],
							w = i[4],
							M = i[8],
							S = i[12],
							T = i[1],
							E = i[5],
							C = i[9],
							P = i[13],
							A = i[2],
							L = i[6],
							R = i[10],
							D = i[14],
							O = i[3],
							z = i[7],
							I = i[11],
							k = i[15];
						return (
							(r[0] = a * _ + s * T + o * A + l * O),
							(r[4] = a * w + s * E + o * L + l * z),
							(r[8] = a * M + s * C + o * R + l * I),
							(r[12] = a * S + s * P + o * D + l * k),
							(r[1] = c * _ + u * T + h * A + d * O),
							(r[5] = c * w + u * E + h * L + d * z),
							(r[9] = c * M + u * C + h * R + d * I),
							(r[13] = c * S + u * P + h * D + d * k),
							(r[2] = p * _ + f * T + m * A + v * O),
							(r[6] = p * w + f * E + m * L + v * z),
							(r[10] = p * M + f * C + m * R + v * I),
							(r[14] = p * S + f * P + m * D + v * k),
							(r[3] = g * _ + b * T + x * A + y * O),
							(r[7] = g * w + b * E + x * L + y * z),
							(r[11] = g * M + b * C + x * R + y * I),
							(r[15] = g * S + b * P + x * D + y * k),
							this
						);
					}
					multiplyScalar(t) {
						const e = this.elements;
						return (e[0] *= t), (e[4] *= t), (e[8] *= t), (e[12] *= t), (e[1] *= t), (e[5] *= t), (e[9] *= t), (e[13] *= t), (e[2] *= t), (e[6] *= t), (e[10] *= t), (e[14] *= t), (e[3] *= t), (e[7] *= t), (e[11] *= t), (e[15] *= t), this;
					}
					determinant() {
						const t = this.elements,
							e = t[0],
							n = t[4],
							i = t[8],
							r = t[12],
							a = t[1],
							s = t[5],
							o = t[9],
							l = t[13],
							c = t[2],
							u = t[6],
							h = t[10],
							d = t[14];
						return t[3] * (+r * o * u - i * l * u - r * s * h + n * l * h + i * s * d - n * o * d) + t[7] * (+e * o * d - e * l * h + r * a * h - i * a * d + i * l * c - r * o * c) + t[11] * (+e * l * u - e * s * d - r * a * u + n * a * d + r * s * c - n * l * c) + t[15] * (-i * s * c - e * o * u + e * s * h + i * a * u - n * a * h + n * o * c);
					}
					transpose() {
						const t = this.elements;
						let e;
						return (e = t[1]), (t[1] = t[4]), (t[4] = e), (e = t[2]), (t[2] = t[8]), (t[8] = e), (e = t[6]), (t[6] = t[9]), (t[9] = e), (e = t[3]), (t[3] = t[12]), (t[12] = e), (e = t[7]), (t[7] = t[13]), (t[13] = e), (e = t[11]), (t[11] = t[14]), (t[14] = e), this;
					}
					setPosition(t, e, n) {
						const i = this.elements;
						return t.isVector3 ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z)) : ((i[12] = t), (i[13] = e), (i[14] = n)), this;
					}
					invert() {
						const t = this.elements,
							e = t[0],
							n = t[1],
							i = t[2],
							r = t[3],
							a = t[4],
							s = t[5],
							o = t[6],
							l = t[7],
							c = t[8],
							u = t[9],
							h = t[10],
							d = t[11],
							p = t[12],
							f = t[13],
							m = t[14],
							v = t[15],
							g = u * m * l - f * h * l + f * o * d - s * m * d - u * o * v + s * h * v,
							b = p * h * l - c * m * l - p * o * d + a * m * d + c * o * v - a * h * v,
							x = c * f * l - p * u * l + p * s * d - a * f * d - c * s * v + a * u * v,
							y = p * u * o - c * f * o - p * s * h + a * f * h + c * s * m - a * u * m,
							_ = e * g + n * b + i * x + r * y;
						if (0 === _) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
						const w = 1 / _;
						return (
							(t[0] = g * w),
							(t[1] = (f * h * r - u * m * r - f * i * d + n * m * d + u * i * v - n * h * v) * w),
							(t[2] = (s * m * r - f * o * r + f * i * l - n * m * l - s * i * v + n * o * v) * w),
							(t[3] = (u * o * r - s * h * r - u * i * l + n * h * l + s * i * d - n * o * d) * w),
							(t[4] = b * w),
							(t[5] = (c * m * r - p * h * r + p * i * d - e * m * d - c * i * v + e * h * v) * w),
							(t[6] = (p * o * r - a * m * r - p * i * l + e * m * l + a * i * v - e * o * v) * w),
							(t[7] = (a * h * r - c * o * r + c * i * l - e * h * l - a * i * d + e * o * d) * w),
							(t[8] = x * w),
							(t[9] = (p * u * r - c * f * r - p * n * d + e * f * d + c * n * v - e * u * v) * w),
							(t[10] = (a * f * r - p * s * r + p * n * l - e * f * l - a * n * v + e * s * v) * w),
							(t[11] = (c * s * r - a * u * r - c * n * l + e * u * l + a * n * d - e * s * d) * w),
							(t[12] = y * w),
							(t[13] = (c * f * i - p * u * i + p * n * h - e * f * h - c * n * m + e * u * m) * w),
							(t[14] = (p * s * i - a * f * i - p * n * o + e * f * o + a * n * m - e * s * m) * w),
							(t[15] = (a * u * i - c * s * i + c * n * o - e * u * o - a * n * h + e * s * h) * w),
							this
						);
					}
					scale(t) {
						const e = this.elements,
							n = t.x,
							i = t.y,
							r = t.z;
						return (e[0] *= n), (e[4] *= i), (e[8] *= r), (e[1] *= n), (e[5] *= i), (e[9] *= r), (e[2] *= n), (e[6] *= i), (e[10] *= r), (e[3] *= n), (e[7] *= i), (e[11] *= r), this;
					}
					getMaxScaleOnAxis() {
						const t = this.elements,
							e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
							n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
							i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
						return Math.sqrt(Math.max(e, n, i));
					}
					makeTranslation(t, e, n) {
						return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this;
					}
					makeRotationX(t) {
						const e = Math.cos(t),
							n = Math.sin(t);
						return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;
					}
					makeRotationY(t) {
						const e = Math.cos(t),
							n = Math.sin(t);
						return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;
					}
					makeRotationZ(t) {
						const e = Math.cos(t),
							n = Math.sin(t);
						return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
					}
					makeRotationAxis(t, e) {
						const n = Math.cos(e),
							i = Math.sin(e),
							r = 1 - n,
							a = t.x,
							s = t.y,
							o = t.z,
							l = r * a,
							c = r * s;
						return this.set(l * a + n, l * s - i * o, l * o + i * s, 0, l * s + i * o, c * s + n, c * o - i * a, 0, l * o - i * s, c * o + i * a, r * o * o + n, 0, 0, 0, 0, 1), this;
					}
					makeScale(t, e, n) {
						return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
					}
					makeShear(t, e, n, i, r, a) {
						return this.set(1, n, r, 0, t, 1, a, 0, e, i, 1, 0, 0, 0, 0, 1), this;
					}
					compose(t, e, n) {
						const i = this.elements,
							r = e._x,
							a = e._y,
							s = e._z,
							o = e._w,
							l = r + r,
							c = a + a,
							u = s + s,
							h = r * l,
							d = r * c,
							p = r * u,
							f = a * c,
							m = a * u,
							v = s * u,
							g = o * l,
							b = o * c,
							x = o * u,
							y = n.x,
							_ = n.y,
							w = n.z;
						return (i[0] = (1 - (f + v)) * y), (i[1] = (d + x) * y), (i[2] = (p - b) * y), (i[3] = 0), (i[4] = (d - x) * _), (i[5] = (1 - (h + v)) * _), (i[6] = (m + g) * _), (i[7] = 0), (i[8] = (p + b) * w), (i[9] = (m - g) * w), (i[10] = (1 - (h + f)) * w), (i[11] = 0), (i[12] = t.x), (i[13] = t.y), (i[14] = t.z), (i[15] = 1), this;
					}
					decompose(t, e, n) {
						const i = this.elements;
						let r = Se.set(i[0], i[1], i[2]).length();
						const a = Se.set(i[4], i[5], i[6]).length(),
							s = Se.set(i[8], i[9], i[10]).length();
						this.determinant() < 0 && (r = -r), (t.x = i[12]), (t.y = i[13]), (t.z = i[14]), Te.copy(this);
						const o = 1 / r,
							l = 1 / a,
							c = 1 / s;
						return (Te.elements[0] *= o), (Te.elements[1] *= o), (Te.elements[2] *= o), (Te.elements[4] *= l), (Te.elements[5] *= l), (Te.elements[6] *= l), (Te.elements[8] *= c), (Te.elements[9] *= c), (Te.elements[10] *= c), e.setFromRotationMatrix(Te), (n.x = r), (n.y = a), (n.z = s), this;
					}
					makePerspective(t, e, n, i, r, a) {
						void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
						const s = this.elements,
							o = (2 * r) / (e - t),
							l = (2 * r) / (n - i),
							c = (e + t) / (e - t),
							u = (n + i) / (n - i),
							h = -(a + r) / (a - r),
							d = (-2 * a * r) / (a - r);
						return (s[0] = o), (s[4] = 0), (s[8] = c), (s[12] = 0), (s[1] = 0), (s[5] = l), (s[9] = u), (s[13] = 0), (s[2] = 0), (s[6] = 0), (s[10] = h), (s[14] = d), (s[3] = 0), (s[7] = 0), (s[11] = -1), (s[15] = 0), this;
					}
					makeOrthographic(t, e, n, i, r, a) {
						const s = this.elements,
							o = 1 / (e - t),
							l = 1 / (n - i),
							c = 1 / (a - r),
							u = (e + t) * o,
							h = (n + i) * l,
							d = (a + r) * c;
						return (s[0] = 2 * o), (s[4] = 0), (s[8] = 0), (s[12] = -u), (s[1] = 0), (s[5] = 2 * l), (s[9] = 0), (s[13] = -h), (s[2] = 0), (s[6] = 0), (s[10] = -2 * c), (s[14] = -d), (s[3] = 0), (s[7] = 0), (s[11] = 0), (s[15] = 1), this;
					}
					equals(t) {
						const e = this.elements,
							n = t.elements;
						for (let t = 0; t < 16; t++) if (e[t] !== n[t]) return !1;
						return !0;
					}
					fromArray(t, e = 0) {
						for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
						return this;
					}
					toArray(t = [], e = 0) {
						const n = this.elements;
						return (t[e] = n[0]), (t[e + 1] = n[1]), (t[e + 2] = n[2]), (t[e + 3] = n[3]), (t[e + 4] = n[4]), (t[e + 5] = n[5]), (t[e + 6] = n[6]), (t[e + 7] = n[7]), (t[e + 8] = n[8]), (t[e + 9] = n[9]), (t[e + 10] = n[10]), (t[e + 11] = n[11]), (t[e + 12] = n[12]), (t[e + 13] = n[13]), (t[e + 14] = n[14]), (t[e + 15] = n[15]), t;
					}
				}
				Me.prototype.isMatrix4 = !0;
				const Se = new Xt(),
					Te = new Me(),
					Ee = new Xt(0, 0, 0),
					Ce = new Xt(1, 1, 1),
					Pe = new Xt(),
					Ae = new Xt(),
					Le = new Xt(),
					Re = new Me(),
					De = new jt();
				class Oe {
					constructor(t = 0, e = 0, n = 0, i = Oe.DefaultOrder) {
						(this._x = t), (this._y = e), (this._z = n), (this._order = i);
					}
					get x() {
						return this._x;
					}
					set x(t) {
						(this._x = t), this._onChangeCallback();
					}
					get y() {
						return this._y;
					}
					set y(t) {
						(this._y = t), this._onChangeCallback();
					}
					get z() {
						return this._z;
					}
					set z(t) {
						(this._z = t), this._onChangeCallback();
					}
					get order() {
						return this._order;
					}
					set order(t) {
						(this._order = t), this._onChangeCallback();
					}
					set(t, e, n, i = this._order) {
						return (this._x = t), (this._y = e), (this._z = n), (this._order = i), this._onChangeCallback(), this;
					}
					clone() {
						return new this.constructor(this._x, this._y, this._z, this._order);
					}
					copy(t) {
						return (this._x = t._x), (this._y = t._y), (this._z = t._z), (this._order = t._order), this._onChangeCallback(), this;
					}
					setFromRotationMatrix(t, e = this._order, n = !0) {
						const i = t.elements,
							r = i[0],
							a = i[4],
							s = i[8],
							o = i[1],
							l = i[5],
							c = i[9],
							u = i[2],
							h = i[6],
							d = i[10];
						switch (e) {
							case "XYZ":
								(this._y = Math.asin(Et(s, -1, 1))), Math.abs(s) < 0.9999999 ? ((this._x = Math.atan2(-c, d)), (this._z = Math.atan2(-a, r))) : ((this._x = Math.atan2(h, l)), (this._z = 0));
								break;
							case "YXZ":
								(this._x = Math.asin(-Et(c, -1, 1))), Math.abs(c) < 0.9999999 ? ((this._y = Math.atan2(s, d)), (this._z = Math.atan2(o, l))) : ((this._y = Math.atan2(-u, r)), (this._z = 0));
								break;
							case "ZXY":
								(this._x = Math.asin(Et(h, -1, 1))), Math.abs(h) < 0.9999999 ? ((this._y = Math.atan2(-u, d)), (this._z = Math.atan2(-a, l))) : ((this._y = 0), (this._z = Math.atan2(o, r)));
								break;
							case "ZYX":
								(this._y = Math.asin(-Et(u, -1, 1))), Math.abs(u) < 0.9999999 ? ((this._x = Math.atan2(h, d)), (this._z = Math.atan2(o, r))) : ((this._x = 0), (this._z = Math.atan2(-a, l)));
								break;
							case "YZX":
								(this._z = Math.asin(Et(o, -1, 1))), Math.abs(o) < 0.9999999 ? ((this._x = Math.atan2(-c, l)), (this._y = Math.atan2(-u, r))) : ((this._x = 0), (this._y = Math.atan2(s, d)));
								break;
							case "XZY":
								(this._z = Math.asin(-Et(a, -1, 1))), Math.abs(a) < 0.9999999 ? ((this._x = Math.atan2(h, l)), (this._y = Math.atan2(s, r))) : ((this._x = Math.atan2(-c, d)), (this._y = 0));
								break;
							default:
								console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e);
						}
						return (this._order = e), !0 === n && this._onChangeCallback(), this;
					}
					setFromQuaternion(t, e, n) {
						return Re.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Re, e, n);
					}
					setFromVector3(t, e = this._order) {
						return this.set(t.x, t.y, t.z, e);
					}
					reorder(t) {
						return De.setFromEuler(this), this.setFromQuaternion(De, t);
					}
					equals(t) {
						return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
					}
					fromArray(t) {
						return (this._x = t[0]), (this._y = t[1]), (this._z = t[2]), void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this;
					}
					toArray(t = [], e = 0) {
						return (t[e] = this._x), (t[e + 1] = this._y), (t[e + 2] = this._z), (t[e + 3] = this._order), t;
					}
					toVector3(t) {
						return t ? t.set(this._x, this._y, this._z) : new Xt(this._x, this._y, this._z);
					}
					_onChange(t) {
						return (this._onChangeCallback = t), this;
					}
					_onChangeCallback() {}
				}
				(Oe.prototype.isEuler = !0), (Oe.DefaultOrder = "XYZ"), (Oe.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]);
				class ze {
					constructor() {
						this.mask = 1;
					}
					set(t) {
						this.mask = (1 << t) | 0;
					}
					enable(t) {
						this.mask |= (1 << t) | 0;
					}
					enableAll() {
						this.mask = -1;
					}
					toggle(t) {
						this.mask ^= (1 << t) | 0;
					}
					disable(t) {
						this.mask &= ~((1 << t) | 0);
					}
					disableAll() {
						this.mask = 0;
					}
					test(t) {
						return 0 != (this.mask & t.mask);
					}
				}
				let Ie = 0;
				const ke = new Xt(),
					Ne = new jt(),
					Ve = new Me(),
					Be = new Xt(),
					Fe = new Xt(),
					Ue = new Xt(),
					He = new jt(),
					Ge = new Xt(1, 0, 0),
					We = new Xt(0, 1, 0),
					je = new Xt(0, 0, 1),
					Xe = { type: "added" },
					qe = { type: "removed" };
				class Ye extends xt {
					constructor() {
						super(), Object.defineProperty(this, "id", { value: Ie++ }), (this.uuid = Tt()), (this.name = ""), (this.type = "Object3D"), (this.parent = null), (this.children = []), (this.up = Ye.DefaultUp.clone());
						const t = new Xt(),
							e = new Oe(),
							n = new jt(),
							i = new Xt(1, 1, 1);
						e._onChange(function () {
							n.setFromEuler(e, !1);
						}),
							n._onChange(function () {
								e.setFromQuaternion(n, void 0, !1);
							}),
							Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: t }, rotation: { configurable: !0, enumerable: !0, value: e }, quaternion: { configurable: !0, enumerable: !0, value: n }, scale: { configurable: !0, enumerable: !0, value: i }, modelViewMatrix: { value: new Me() }, normalMatrix: { value: new zt() } }),
							(this.matrix = new Me()),
							(this.matrixWorld = new Me()),
							(this.matrixAutoUpdate = Ye.DefaultMatrixAutoUpdate),
							(this.matrixWorldNeedsUpdate = !1),
							(this.layers = new ze()),
							(this.visible = !0),
							(this.castShadow = !1),
							(this.receiveShadow = !1),
							(this.frustumCulled = !0),
							(this.renderOrder = 0),
							(this.animations = []),
							(this.userData = {});
					}
					onBeforeRender() {}
					onAfterRender() {}
					applyMatrix4(t) {
						this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale);
					}
					applyQuaternion(t) {
						return this.quaternion.premultiply(t), this;
					}
					setRotationFromAxisAngle(t, e) {
						this.quaternion.setFromAxisAngle(t, e);
					}
					setRotationFromEuler(t) {
						this.quaternion.setFromEuler(t, !0);
					}
					setRotationFromMatrix(t) {
						this.quaternion.setFromRotationMatrix(t);
					}
					setRotationFromQuaternion(t) {
						this.quaternion.copy(t);
					}
					rotateOnAxis(t, e) {
						return Ne.setFromAxisAngle(t, e), this.quaternion.multiply(Ne), this;
					}
					rotateOnWorldAxis(t, e) {
						return Ne.setFromAxisAngle(t, e), this.quaternion.premultiply(Ne), this;
					}
					rotateX(t) {
						return this.rotateOnAxis(Ge, t);
					}
					rotateY(t) {
						return this.rotateOnAxis(We, t);
					}
					rotateZ(t) {
						return this.rotateOnAxis(je, t);
					}
					translateOnAxis(t, e) {
						return ke.copy(t).applyQuaternion(this.quaternion), this.position.add(ke.multiplyScalar(e)), this;
					}
					translateX(t) {
						return this.translateOnAxis(Ge, t);
					}
					translateY(t) {
						return this.translateOnAxis(We, t);
					}
					translateZ(t) {
						return this.translateOnAxis(je, t);
					}
					localToWorld(t) {
						return t.applyMatrix4(this.matrixWorld);
					}
					worldToLocal(t) {
						return t.applyMatrix4(Ve.copy(this.matrixWorld).invert());
					}
					lookAt(t, e, n) {
						t.isVector3 ? Be.copy(t) : Be.set(t, e, n);
						const i = this.parent;
						this.updateWorldMatrix(!0, !1), Fe.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ve.lookAt(Fe, Be, this.up) : Ve.lookAt(Be, Fe, this.up), this.quaternion.setFromRotationMatrix(Ve), i && (Ve.extractRotation(i.matrixWorld), Ne.setFromRotationMatrix(Ve), this.quaternion.premultiply(Ne.invert()));
					}
					add(t) {
						if (arguments.length > 1) {
							for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
							return this;
						}
						return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), (t.parent = this), this.children.push(t), t.dispatchEvent(Xe)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this);
					}
					remove(t) {
						if (arguments.length > 1) {
							for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
							return this;
						}
						const e = this.children.indexOf(t);
						return -1 !== e && ((t.parent = null), this.children.splice(e, 1), t.dispatchEvent(qe)), this;
					}
					removeFromParent() {
						const t = this.parent;
						return null !== t && t.remove(this), this;
					}
					clear() {
						for (let t = 0; t < this.children.length; t++) {
							const e = this.children[t];
							(e.parent = null), e.dispatchEvent(qe);
						}
						return (this.children.length = 0), this;
					}
					attach(t) {
						return this.updateWorldMatrix(!0, !1), Ve.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), Ve.multiply(t.parent.matrixWorld)), t.applyMatrix4(Ve), this.add(t), t.updateWorldMatrix(!1, !0), this;
					}
					getObjectById(t) {
						return this.getObjectByProperty("id", t);
					}
					getObjectByName(t) {
						return this.getObjectByProperty("name", t);
					}
					getObjectByProperty(t, e) {
						if (this[t] === e) return this;
						for (let n = 0, i = this.children.length; n < i; n++) {
							const i = this.children[n].getObjectByProperty(t, e);
							if (void 0 !== i) return i;
						}
					}
					getWorldPosition(t) {
						return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld);
					}
					getWorldQuaternion(t) {
						return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Fe, t, Ue), t;
					}
					getWorldScale(t) {
						return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Fe, He, t), t;
					}
					getWorldDirection(t) {
						this.updateWorldMatrix(!0, !1);
						const e = this.matrixWorld.elements;
						return t.set(e[8], e[9], e[10]).normalize();
					}
					raycast() {}
					traverse(t) {
						t(this);
						const e = this.children;
						for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t);
					}
					traverseVisible(t) {
						if (!1 === this.visible) return;
						t(this);
						const e = this.children;
						for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t);
					}
					traverseAncestors(t) {
						const e = this.parent;
						null !== e && (t(e), e.traverseAncestors(t));
					}
					updateMatrix() {
						this.matrix.compose(this.position, this.quaternion, this.scale), (this.matrixWorldNeedsUpdate = !0);
					}
					updateMatrixWorld(t) {
						this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), (this.matrixWorldNeedsUpdate = !1), (t = !0));
						const e = this.children;
						for (let n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t);
					}
					updateWorldMatrix(t, e) {
						const n = this.parent;
						if ((!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e)) {
							const t = this.children;
							for (let e = 0, n = t.length; e < n; e++) t[e].updateWorldMatrix(!1, !0);
						}
					}
					toJSON(t) {
						const e = void 0 === t || "string" == typeof t,
							n = {};
						e && ((t = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {} }), (n.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }));
						const i = {};
						function r(e, n) {
							return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
						}
						if (
							((i.uuid = this.uuid),
							(i.type = this.type),
							"" !== this.name && (i.name = this.name),
							!0 === this.castShadow && (i.castShadow = !0),
							!0 === this.receiveShadow && (i.receiveShadow = !0),
							!1 === this.visible && (i.visible = !1),
							!1 === this.frustumCulled && (i.frustumCulled = !1),
							0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
							"{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
							(i.layers = this.layers.mask),
							(i.matrix = this.matrix.toArray()),
							!1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
							this.isInstancedMesh && ((i.type = "InstancedMesh"), (i.count = this.count), (i.instanceMatrix = this.instanceMatrix.toJSON()), null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())),
							this.isScene)
						)
							this.background && (this.background.isColor ? (i.background = this.background.toJSON()) : this.background.isTexture && (i.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && (i.environment = this.environment.toJSON(t).uuid);
						else if (this.isMesh || this.isLine || this.isPoints) {
							i.geometry = r(t.geometries, this.geometry);
							const e = this.geometry.parameters;
							if (void 0 !== e && void 0 !== e.shapes) {
								const n = e.shapes;
								if (Array.isArray(n))
									for (let e = 0, i = n.length; e < i; e++) {
										const i = n[e];
										r(t.shapes, i);
									}
								else r(t.shapes, n);
							}
						}
						if ((this.isSkinnedMesh && ((i.bindMode = this.bindMode), (i.bindMatrix = this.bindMatrix.toArray()), void 0 !== this.skeleton && (r(t.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))), void 0 !== this.material))
							if (Array.isArray(this.material)) {
								const e = [];
								for (let n = 0, i = this.material.length; n < i; n++) e.push(r(t.materials, this.material[n]));
								i.material = e;
							} else i.material = r(t.materials, this.material);
						if (this.children.length > 0) {
							i.children = [];
							for (let e = 0; e < this.children.length; e++) i.children.push(this.children[e].toJSON(t).object);
						}
						if (this.animations.length > 0) {
							i.animations = [];
							for (let e = 0; e < this.animations.length; e++) {
								const n = this.animations[e];
								i.animations.push(r(t.animations, n));
							}
						}
						if (e) {
							const e = a(t.geometries),
								i = a(t.materials),
								r = a(t.textures),
								s = a(t.images),
								o = a(t.shapes),
								l = a(t.skeletons),
								c = a(t.animations);
							e.length > 0 && (n.geometries = e), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), s.length > 0 && (n.images = s), o.length > 0 && (n.shapes = o), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c);
						}
						return (n.object = i), n;
						function a(t) {
							const e = [];
							for (const n in t) {
								const i = t[n];
								delete i.metadata, e.push(i);
							}
							return e;
						}
					}
					clone(t) {
						return new this.constructor().copy(this, t);
					}
					copy(t, e = !0) {
						if (
							((this.name = t.name),
							this.up.copy(t.up),
							this.position.copy(t.position),
							(this.rotation.order = t.rotation.order),
							this.quaternion.copy(t.quaternion),
							this.scale.copy(t.scale),
							this.matrix.copy(t.matrix),
							this.matrixWorld.copy(t.matrixWorld),
							(this.matrixAutoUpdate = t.matrixAutoUpdate),
							(this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
							(this.layers.mask = t.layers.mask),
							(this.visible = t.visible),
							(this.castShadow = t.castShadow),
							(this.receiveShadow = t.receiveShadow),
							(this.frustumCulled = t.frustumCulled),
							(this.renderOrder = t.renderOrder),
							(this.userData = JSON.parse(JSON.stringify(t.userData))),
							!0 === e)
						)
							for (let e = 0; e < t.children.length; e++) {
								const n = t.children[e];
								this.add(n.clone());
							}
						return this;
					}
				}
				(Ye.DefaultUp = new Xt(0, 1, 0)), (Ye.DefaultMatrixAutoUpdate = !0), (Ye.prototype.isObject3D = !0);
				const Ze = new Xt(),
					Ke = new Xt(),
					Je = new Xt(),
					Qe = new Xt(),
					$e = new Xt(),
					tn = new Xt(),
					en = new Xt(),
					nn = new Xt(),
					rn = new Xt(),
					an = new Xt();
				class sn {
					constructor(t = new Xt(), e = new Xt(), n = new Xt()) {
						(this.a = t), (this.b = e), (this.c = n);
					}
					static getNormal(t, e, n, i) {
						i.subVectors(n, e), Ze.subVectors(t, e), i.cross(Ze);
						const r = i.lengthSq();
						return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
					}
					static getBarycoord(t, e, n, i, r) {
						Ze.subVectors(i, e), Ke.subVectors(n, e), Je.subVectors(t, e);
						const a = Ze.dot(Ze),
							s = Ze.dot(Ke),
							o = Ze.dot(Je),
							l = Ke.dot(Ke),
							c = Ke.dot(Je),
							u = a * l - s * s;
						if (0 === u) return r.set(-2, -1, -1);
						const h = 1 / u,
							d = (l * o - s * c) * h,
							p = (a * c - s * o) * h;
						return r.set(1 - d - p, p, d);
					}
					static containsPoint(t, e, n, i) {
						return this.getBarycoord(t, e, n, i, Qe), Qe.x >= 0 && Qe.y >= 0 && Qe.x + Qe.y <= 1;
					}
					static getUV(t, e, n, i, r, a, s, o) {
						return this.getBarycoord(t, e, n, i, Qe), o.set(0, 0), o.addScaledVector(r, Qe.x), o.addScaledVector(a, Qe.y), o.addScaledVector(s, Qe.z), o;
					}
					static isFrontFacing(t, e, n, i) {
						return Ze.subVectors(n, e), Ke.subVectors(t, e), Ze.cross(Ke).dot(i) < 0;
					}
					set(t, e, n) {
						return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
					}
					setFromPointsAndIndices(t, e, n, i) {
						return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;
					}
					setFromAttributeAndIndices(t, e, n, i) {
						return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, n), this.c.fromBufferAttribute(t, i), this;
					}
					clone() {
						return new this.constructor().copy(this);
					}
					copy(t) {
						return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
					}
					getArea() {
						return Ze.subVectors(this.c, this.b), Ke.subVectors(this.a, this.b), 0.5 * Ze.cross(Ke).length();
					}
					getMidpoint(t) {
						return t
							.addVectors(this.a, this.b)
							.add(this.c)
							.multiplyScalar(1 / 3);
					}
					getNormal(t) {
						return sn.getNormal(this.a, this.b, this.c, t);
					}
					getPlane(t) {
						return t.setFromCoplanarPoints(this.a, this.b, this.c);
					}
					getBarycoord(t, e) {
						return sn.getBarycoord(t, this.a, this.b, this.c, e);
					}
					getUV(t, e, n, i, r) {
						return sn.getUV(t, this.a, this.b, this.c, e, n, i, r);
					}
					containsPoint(t) {
						return sn.containsPoint(t, this.a, this.b, this.c);
					}
					isFrontFacing(t) {
						return sn.isFrontFacing(this.a, this.b, this.c, t);
					}
					intersectsBox(t) {
						return t.intersectsTriangle(this);
					}
					closestPointToPoint(t, e) {
						const n = this.a,
							i = this.b,
							r = this.c;
						let a, s;
						$e.subVectors(i, n), tn.subVectors(r, n), nn.subVectors(t, n);
						const o = $e.dot(nn),
							l = tn.dot(nn);
						if (o <= 0 && l <= 0) return e.copy(n);
						rn.subVectors(t, i);
						const c = $e.dot(rn),
							u = tn.dot(rn);
						if (c >= 0 && u <= c) return e.copy(i);
						const h = o * u - c * l;
						if (h <= 0 && o >= 0 && c <= 0) return (a = o / (o - c)), e.copy(n).addScaledVector($e, a);
						an.subVectors(t, r);
						const d = $e.dot(an),
							p = tn.dot(an);
						if (p >= 0 && d <= p) return e.copy(r);
						const f = d * l - o * p;
						if (f <= 0 && l >= 0 && p <= 0) return (s = l / (l - p)), e.copy(n).addScaledVector(tn, s);
						const m = c * p - d * u;
						if (m <= 0 && u - c >= 0 && d - p >= 0) return en.subVectors(r, i), (s = (u - c) / (u - c + (d - p))), e.copy(i).addScaledVector(en, s);
						const v = 1 / (m + f + h);
						return (a = f * v), (s = h * v), e.copy(n).addScaledVector($e, a).addScaledVector(tn, s);
					}
					equals(t) {
						return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
					}
				}
				let on = 0;
				class ln extends xt {
					constructor() {
						super(),
							Object.defineProperty(this, "id", { value: on++ }),
							(this.uuid = Tt()),
							(this.name = ""),
							(this.type = "Material"),
							(this.fog = !0),
							(this.blending = 1),
							(this.side = 0),
							(this.vertexColors = !1),
							(this.opacity = 1),
							(this.format = et),
							(this.transparent = !1),
							(this.blendSrc = 204),
							(this.blendDst = 205),
							(this.blendEquation = O),
							(this.blendSrcAlpha = null),
							(this.blendDstAlpha = null),
							(this.blendEquationAlpha = null),
							(this.depthFunc = 3),
							(this.depthTest = !0),
							(this.depthWrite = !0),
							(this.stencilWriteMask = 255),
							(this.stencilFunc = 519),
							(this.stencilRef = 0),
							(this.stencilFuncMask = 255),
							(this.stencilFail = mt),
							(this.stencilZFail = mt),
							(this.stencilZPass = mt),
							(this.stencilWrite = !1),
							(this.clippingPlanes = null),
							(this.clipIntersection = !1),
							(this.clipShadows = !1),
							(this.shadowSide = null),
							(this.colorWrite = !0),
							(this.precision = null),
							(this.polygonOffset = !1),
							(this.polygonOffsetFactor = 0),
							(this.polygonOffsetUnits = 0),
							(this.dithering = !1),
							(this.alphaToCoverage = !1),
							(this.premultipliedAlpha = !1),
							(this.visible = !0),
							(this.toneMapped = !0),
							(this.userData = {}),
							(this.version = 0),
							(this._alphaTest = 0);
					}
					get alphaTest() {
						return this._alphaTest;
					}
					set alphaTest(t) {
						this._alphaTest > 0 != t > 0 && this.version++, (this._alphaTest = t);
					}
					onBuild() {}
					onBeforeRender() {}
					onBeforeCompile() {}
					customProgramCacheKey() {
						return this.onBeforeCompile.toString();
					}
					setValues(t) {
						if (void 0 !== t)
							for (const e in t) {
								const n = t[e];
								if (void 0 === n) {
									console.warn("THREE.Material: '" + e + "' parameter is undefined.");
									continue;
								}
								if ("shading" === e) {
									console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), (this.flatShading = 1 === n);
									continue;
								}
								const i = this[e];
								void 0 !== i ? (i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : (this[e] = n)) : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.");
							}
					}
					toJSON(t) {
						const e = void 0 === t || "string" == typeof t;
						e && (t = { textures: {}, images: {} });
						const n = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };
						function i(t) {
							const e = [];
							for (const n in t) {
								const i = t[n];
								delete i.metadata, e.push(i);
							}
							return e;
						}
						if (
							((n.uuid = this.uuid),
							(n.type = this.type),
							"" !== this.name && (n.name = this.name),
							this.color && this.color.isColor && (n.color = this.color.getHex()),
							void 0 !== this.roughness && (n.roughness = this.roughness),
							void 0 !== this.metalness && (n.metalness = this.metalness),
							void 0 !== this.sheen && (n.sheen = this.sheen),
							this.sheenTint && this.sheenTint.isColor && (n.sheenTint = this.sheenTint.getHex()),
							void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness),
							this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
							this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity),
							this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
							void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity),
							this.specularTint && this.specularTint.isColor && (n.specularTint = this.specularTint.getHex()),
							void 0 !== this.shininess && (n.shininess = this.shininess),
							void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
							void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness),
							this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
							this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
							this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid), (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
							this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
							this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid),
							this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid),
							this.lightMap && this.lightMap.isTexture && ((n.lightMap = this.lightMap.toJSON(t).uuid), (n.lightMapIntensity = this.lightMapIntensity)),
							this.aoMap && this.aoMap.isTexture && ((n.aoMap = this.aoMap.toJSON(t).uuid), (n.aoMapIntensity = this.aoMapIntensity)),
							this.bumpMap && this.bumpMap.isTexture && ((n.bumpMap = this.bumpMap.toJSON(t).uuid), (n.bumpScale = this.bumpScale)),
							this.normalMap && this.normalMap.isTexture && ((n.normalMap = this.normalMap.toJSON(t).uuid), (n.normalMapType = this.normalMapType), (n.normalScale = this.normalScale.toArray())),
							this.displacementMap && this.displacementMap.isTexture && ((n.displacementMap = this.displacementMap.toJSON(t).uuid), (n.displacementScale = this.displacementScale), (n.displacementBias = this.displacementBias)),
							this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
							this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
							this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
							this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid),
							this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
							this.specularTintMap && this.specularTintMap.isTexture && (n.specularTintMap = this.specularTintMap.toJSON(t).uuid),
							this.envMap && this.envMap.isTexture && ((n.envMap = this.envMap.toJSON(t).uuid), void 0 !== this.combine && (n.combine = this.combine)),
							void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity),
							void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
							void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio),
							this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid),
							void 0 !== this.transmission && (n.transmission = this.transmission),
							this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
							void 0 !== this.thickness && (n.thickness = this.thickness),
							this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
							void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance),
							void 0 !== this.attenuationTint && (n.attenuationTint = this.attenuationTint.getHex()),
							void 0 !== this.size && (n.size = this.size),
							null !== this.shadowSide && (n.shadowSide = this.shadowSide),
							void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
							1 !== this.blending && (n.blending = this.blending),
							0 !== this.side && (n.side = this.side),
							this.vertexColors && (n.vertexColors = !0),
							this.opacity < 1 && (n.opacity = this.opacity),
							this.format !== et && (n.format = this.format),
							!0 === this.transparent && (n.transparent = this.transparent),
							(n.depthFunc = this.depthFunc),
							(n.depthTest = this.depthTest),
							(n.depthWrite = this.depthWrite),
							(n.colorWrite = this.colorWrite),
							(n.stencilWrite = this.stencilWrite),
							(n.stencilWriteMask = this.stencilWriteMask),
							(n.stencilFunc = this.stencilFunc),
							(n.stencilRef = this.stencilRef),
							(n.stencilFuncMask = this.stencilFuncMask),
							(n.stencilFail = this.stencilFail),
							(n.stencilZFail = this.stencilZFail),
							(n.stencilZPass = this.stencilZPass),
							this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
							!0 === this.polygonOffset && (n.polygonOffset = !0),
							0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
							0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
							this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
							void 0 !== this.dashSize && (n.dashSize = this.dashSize),
							void 0 !== this.gapSize && (n.gapSize = this.gapSize),
							void 0 !== this.scale && (n.scale = this.scale),
							!0 === this.dithering && (n.dithering = !0),
							this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
							!0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage),
							!0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha),
							!0 === this.wireframe && (n.wireframe = this.wireframe),
							this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
							"round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
							"round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
							!0 === this.flatShading && (n.flatShading = this.flatShading),
							!1 === this.visible && (n.visible = !1),
							!1 === this.toneMapped && (n.toneMapped = !1),
							"{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
							e)
						) {
							const e = i(t.textures),
								r = i(t.images);
							e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r);
						}
						return n;
					}
					clone() {
						return new this.constructor().copy(this);
					}
					copy(t) {
						(this.name = t.name),
							(this.fog = t.fog),
							(this.blending = t.blending),
							(this.side = t.side),
							(this.vertexColors = t.vertexColors),
							(this.opacity = t.opacity),
							(this.format = t.format),
							(this.transparent = t.transparent),
							(this.blendSrc = t.blendSrc),
							(this.blendDst = t.blendDst),
							(this.blendEquation = t.blendEquation),
							(this.blendSrcAlpha = t.blendSrcAlpha),
							(this.blendDstAlpha = t.blendDstAlpha),
							(this.blendEquationAlpha = t.blendEquationAlpha),
							(this.depthFunc = t.depthFunc),
							(this.depthTest = t.depthTest),
							(this.depthWrite = t.depthWrite),
							(this.stencilWriteMask = t.stencilWriteMask),
							(this.stencilFunc = t.stencilFunc),
							(this.stencilRef = t.stencilRef),
							(this.stencilFuncMask = t.stencilFuncMask),
							(this.stencilFail = t.stencilFail),
							(this.stencilZFail = t.stencilZFail),
							(this.stencilZPass = t.stencilZPass),
							(this.stencilWrite = t.stencilWrite);
						const e = t.clippingPlanes;
						let n = null;
						if (null !== e) {
							const t = e.length;
							n = new Array(t);
							for (let i = 0; i !== t; ++i) n[i] = e[i].clone();
						}
						return (
							(this.clippingPlanes = n),
							(this.clipIntersection = t.clipIntersection),
							(this.clipShadows = t.clipShadows),
							(this.shadowSide = t.shadowSide),
							(this.colorWrite = t.colorWrite),
							(this.precision = t.precision),
							(this.polygonOffset = t.polygonOffset),
							(this.polygonOffsetFactor = t.polygonOffsetFactor),
							(this.polygonOffsetUnits = t.polygonOffsetUnits),
							(this.dithering = t.dithering),
							(this.alphaTest = t.alphaTest),
							(this.alphaToCoverage = t.alphaToCoverage),
							(this.premultipliedAlpha = t.premultipliedAlpha),
							(this.visible = t.visible),
							(this.toneMapped = t.toneMapped),
							(this.userData = JSON.parse(JSON.stringify(t.userData))),
							this
						);
					}
					dispose() {
						this.dispatchEvent({ type: "dispose" });
					}
					set needsUpdate(t) {
						!0 === t && this.version++;
					}
				}
				ln.prototype.isMaterial = !0;
				const cn = {
						aliceblue: 15792383,
						antiquewhite: 16444375,
						aqua: 65535,
						aquamarine: 8388564,
						azure: 15794175,
						beige: 16119260,
						bisque: 16770244,
						black: 0,
						blanchedalmond: 16772045,
						blue: 255,
						blueviolet: 9055202,
						brown: 10824234,
						burlywood: 14596231,
						cadetblue: 6266528,
						chartreuse: 8388352,
						chocolate: 13789470,
						coral: 16744272,
						cornflowerblue: 6591981,
						cornsilk: 16775388,
						crimson: 14423100,
						cyan: 65535,
						darkblue: 139,
						darkcyan: 35723,
						darkgoldenrod: 12092939,
						darkgray: 11119017,
						darkgreen: 25600,
						darkgrey: 11119017,
						darkkhaki: 12433259,
						darkmagenta: 9109643,
						darkolivegreen: 5597999,
						darkorange: 16747520,
						darkorchid: 10040012,
						darkred: 9109504,
						darksalmon: 15308410,
						darkseagreen: 9419919,
						darkslateblue: 4734347,
						darkslategray: 3100495,
						darkslategrey: 3100495,
						darkturquoise: 52945,
						darkviolet: 9699539,
						deeppink: 16716947,
						deepskyblue: 49151,
						dimgray: 6908265,
						dimgrey: 6908265,
						dodgerblue: 2003199,
						firebrick: 11674146,
						floralwhite: 16775920,
						forestgreen: 2263842,
						fuchsia: 16711935,
						gainsboro: 14474460,
						ghostwhite: 16316671,
						gold: 16766720,
						goldenrod: 14329120,
						gray: 8421504,
						green: 32768,
						greenyellow: 11403055,
						grey: 8421504,
						honeydew: 15794160,
						hotpink: 16738740,
						indianred: 13458524,
						indigo: 4915330,
						ivory: 16777200,
						khaki: 15787660,
						lavender: 15132410,
						lavenderblush: 16773365,
						lawngreen: 8190976,
						lemonchiffon: 16775885,
						lightblue: 11393254,
						lightcoral: 15761536,
						lightcyan: 14745599,
						lightgoldenrodyellow: 16448210,
						lightgray: 13882323,
						lightgreen: 9498256,
						lightgrey: 13882323,
						lightpink: 16758465,
						lightsalmon: 16752762,
						lightseagreen: 2142890,
						lightskyblue: 8900346,
						lightslategray: 7833753,
						lightslategrey: 7833753,
						lightsteelblue: 11584734,
						lightyellow: 16777184,
						lime: 65280,
						limegreen: 3329330,
						linen: 16445670,
						magenta: 16711935,
						maroon: 8388608,
						mediumaquamarine: 6737322,
						mediumblue: 205,
						mediumorchid: 12211667,
						mediumpurple: 9662683,
						mediumseagreen: 3978097,
						mediumslateblue: 8087790,
						mediumspringgreen: 64154,
						mediumturquoise: 4772300,
						mediumvioletred: 13047173,
						midnightblue: 1644912,
						mintcream: 16121850,
						mistyrose: 16770273,
						moccasin: 16770229,
						navajowhite: 16768685,
						navy: 128,
						oldlace: 16643558,
						olive: 8421376,
						olivedrab: 7048739,
						orange: 16753920,
						orangered: 16729344,
						orchid: 14315734,
						palegoldenrod: 15657130,
						palegreen: 10025880,
						paleturquoise: 11529966,
						palevioletred: 14381203,
						papayawhip: 16773077,
						peachpuff: 16767673,
						peru: 13468991,
						pink: 16761035,
						plum: 14524637,
						powderblue: 11591910,
						purple: 8388736,
						rebeccapurple: 6697881,
						red: 16711680,
						rosybrown: 12357519,
						royalblue: 4286945,
						saddlebrown: 9127187,
						salmon: 16416882,
						sandybrown: 16032864,
						seagreen: 3050327,
						seashell: 16774638,
						sienna: 10506797,
						silver: 12632256,
						skyblue: 8900331,
						slateblue: 6970061,
						slategray: 7372944,
						slategrey: 7372944,
						snow: 16775930,
						springgreen: 65407,
						steelblue: 4620980,
						tan: 13808780,
						teal: 32896,
						thistle: 14204888,
						tomato: 16737095,
						turquoise: 4251856,
						violet: 15631086,
						wheat: 16113331,
						white: 16777215,
						whitesmoke: 16119285,
						yellow: 16776960,
						yellowgreen: 10145074,
					},
					un = { h: 0, s: 0, l: 0 },
					hn = { h: 0, s: 0, l: 0 };
				function dn(t, e, n) {
					return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < 0.5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t;
				}
				function pn(t) {
					return t < 0.04045 ? 0.0773993808 * t : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
				}
				function fn(t) {
					return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
				}
				class mn {
					constructor(t, e, n) {
						return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n);
					}
					set(t) {
						return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this;
					}
					setScalar(t) {
						return (this.r = t), (this.g = t), (this.b = t), this;
					}
					setHex(t) {
						return (t = Math.floor(t)), (this.r = ((t >> 16) & 255) / 255), (this.g = ((t >> 8) & 255) / 255), (this.b = (255 & t) / 255), this;
					}
					setRGB(t, e, n) {
						return (this.r = t), (this.g = e), (this.b = n), this;
					}
					setHSL(t, e, n) {
						if (((t = Ct(t, 1)), (e = Et(e, 0, 1)), (n = Et(n, 0, 1)), 0 === e)) this.r = this.g = this.b = n;
						else {
							const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
								r = 2 * n - i;
							(this.r = dn(r, i, t + 1 / 3)), (this.g = dn(r, i, t)), (this.b = dn(r, i, t - 1 / 3));
						}
						return this;
					}
					setStyle(t) {
						function e(e) {
							void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.");
						}
						let n;
						if ((n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t))) {
							let t;
							const i = n[1],
								r = n[2];
							switch (i) {
								case "rgb":
								case "rgba":
									if ((t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))) return (this.r = Math.min(255, parseInt(t[1], 10)) / 255), (this.g = Math.min(255, parseInt(t[2], 10)) / 255), (this.b = Math.min(255, parseInt(t[3], 10)) / 255), e(t[4]), this;
									if ((t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))) return (this.r = Math.min(100, parseInt(t[1], 10)) / 100), (this.g = Math.min(100, parseInt(t[2], 10)) / 100), (this.b = Math.min(100, parseInt(t[3], 10)) / 100), e(t[4]), this;
									break;
								case "hsl":
								case "hsla":
									if ((t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))) {
										const n = parseFloat(t[1]) / 360,
											i = parseInt(t[2], 10) / 100,
											r = parseInt(t[3], 10) / 100;
										return e(t[4]), this.setHSL(n, i, r);
									}
							}
						} else if ((n = /^\#([A-Fa-f\d]+)$/.exec(t))) {
							const t = n[1],
								e = t.length;
							if (3 === e) return (this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255), (this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255), (this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255), this;
							if (6 === e) return (this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255), (this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255), (this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255), this;
						}
						return t && t.length > 0 ? this.setColorName(t) : this;
					}
					setColorName(t) {
						const e = cn[t.toLowerCase()];
						return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this;
					}
					clone() {
						return new this.constructor(this.r, this.g, this.b);
					}
					copy(t) {
						return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
					}
					copyGammaToLinear(t, e = 2) {
						return (this.r = Math.pow(t.r, e)), (this.g = Math.pow(t.g, e)), (this.b = Math.pow(t.b, e)), this;
					}
					copyLinearToGamma(t, e = 2) {
						const n = e > 0 ? 1 / e : 1;
						return (this.r = Math.pow(t.r, n)), (this.g = Math.pow(t.g, n)), (this.b = Math.pow(t.b, n)), this;
					}
					convertGammaToLinear(t) {
						return this.copyGammaToLinear(this, t), this;
					}
					convertLinearToGamma(t) {
						return this.copyLinearToGamma(this, t), this;
					}
					copySRGBToLinear(t) {
						return (this.r = pn(t.r)), (this.g = pn(t.g)), (this.b = pn(t.b)), this;
					}
					copyLinearToSRGB(t) {
						return (this.r = fn(t.r)), (this.g = fn(t.g)), (this.b = fn(t.b)), this;
					}
					convertSRGBToLinear() {
						return this.copySRGBToLinear(this), this;
					}
					convertLinearToSRGB() {
						return this.copyLinearToSRGB(this), this;
					}
					getHex() {
						return ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0);
					}
					getHexString() {
						return ("000000" + this.getHex().toString(16)).slice(-6);
					}
					getHSL(t) {
						const e = this.r,
							n = this.g,
							i = this.b,
							r = Math.max(e, n, i),
							a = Math.min(e, n, i);
						let s, o;
						const l = (a + r) / 2;
						if (a === r) (s = 0), (o = 0);
						else {
							const t = r - a;
							switch (((o = l <= 0.5 ? t / (r + a) : t / (2 - r - a)), r)) {
								case e:
									s = (n - i) / t + (n < i ? 6 : 0);
									break;
								case n:
									s = (i - e) / t + 2;
									break;
								case i:
									s = (e - n) / t + 4;
							}
							s /= 6;
						}
						return (t.h = s), (t.s = o), (t.l = l), t;
					}
					getStyle() {
						return "rgb(" + ((255 * this.r) | 0) + "," + ((255 * this.g) | 0) + "," + ((255 * this.b) | 0) + ")";
					}
					offsetHSL(t, e, n) {
						return this.getHSL(un), (un.h += t), (un.s += e), (un.l += n), this.setHSL(un.h, un.s, un.l), this;
					}
					add(t) {
						return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
					}
					addColors(t, e) {
						return (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this;
					}
					addScalar(t) {
						return (this.r += t), (this.g += t), (this.b += t), this;
					}
					sub(t) {
						return (this.r = Math.max(0, this.r - t.r)), (this.g = Math.max(0, this.g - t.g)), (this.b = Math.max(0, this.b - t.b)), this;
					}
					multiply(t) {
						return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
					}
					multiplyScalar(t) {
						return (this.r *= t), (this.g *= t), (this.b *= t), this;
					}
					lerp(t, e) {
						return (this.r += (t.r - this.r) * e), (this.g += (t.g - this.g) * e), (this.b += (t.b - this.b) * e), this;
					}
					lerpColors(t, e, n) {
						return (this.r = t.r + (e.r - t.r) * n), (this.g = t.g + (e.g - t.g) * n), (this.b = t.b + (e.b - t.b) * n), this;
					}
					lerpHSL(t, e) {
						this.getHSL(un), t.getHSL(hn);
						const n = Pt(un.h, hn.h, e),
							i = Pt(un.s, hn.s, e),
							r = Pt(un.l, hn.l, e);
						return this.setHSL(n, i, r), this;
					}
					equals(t) {
						return t.r === this.r && t.g === this.g && t.b === this.b;
					}
					fromArray(t, e = 0) {
						return (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this;
					}
					toArray(t = [], e = 0) {
						return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
					}
					fromBufferAttribute(t, e) {
						return (this.r = t.getX(e)), (this.g = t.getY(e)), (this.b = t.getZ(e)), !0 === t.normalized && ((this.r /= 255), (this.g /= 255), (this.b /= 255)), this;
					}
					toJSON() {
						return this.getHex();
					}
				}
				(mn.NAMES = cn), (mn.prototype.isColor = !0), (mn.prototype.r = 1), (mn.prototype.g = 1), (mn.prototype.b = 1);
				class vn extends ln {
					constructor(t) {
						super(),
							(this.type = "MeshBasicMaterial"),
							(this.color = new mn(16777215)),
							(this.map = null),
							(this.lightMap = null),
							(this.lightMapIntensity = 1),
							(this.aoMap = null),
							(this.aoMapIntensity = 1),
							(this.specularMap = null),
							(this.alphaMap = null),
							(this.envMap = null),
							(this.combine = 0),
							(this.reflectivity = 1),
							(this.refractionRatio = 0.98),
							(this.wireframe = !1),
							(this.wireframeLinewidth = 1),
							(this.wireframeLinecap = "round"),
							(this.wireframeLinejoin = "round"),
							this.setValues(t);
					}
					copy(t) {
						return (
							super.copy(t),
							this.color.copy(t.color),
							(this.map = t.map),
							(this.lightMap = t.lightMap),
							(this.lightMapIntensity = t.lightMapIntensity),
							(this.aoMap = t.aoMap),
							(this.aoMapIntensity = t.aoMapIntensity),
							(this.specularMap = t.specularMap),
							(this.alphaMap = t.alphaMap),
							(this.envMap = t.envMap),
							(this.combine = t.combine),
							(this.reflectivity = t.reflectivity),
							(this.refractionRatio = t.refractionRatio),
							(this.wireframe = t.wireframe),
							(this.wireframeLinewidth = t.wireframeLinewidth),
							(this.wireframeLinecap = t.wireframeLinecap),
							(this.wireframeLinejoin = t.wireframeLinejoin),
							this
						);
					}
				}
				vn.prototype.isMeshBasicMaterial = !0;
				const gn = new Xt(),
					bn = new Ot();
				class xn {
					constructor(t, e, n) {
						if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
						(this.name = ""), (this.array = t), (this.itemSize = e), (this.count = void 0 !== t ? t.length / e : 0), (this.normalized = !0 === n), (this.usage = vt), (this.updateRange = { offset: 0, count: -1 }), (this.version = 0);
					}
					onUploadCallback() {}
					set needsUpdate(t) {
						!0 === t && this.version++;
					}
					setUsage(t) {
						return (this.usage = t), this;
					}
					copy(t) {
						return (this.name = t.name), (this.array = new t.array.constructor(t.array)), (this.itemSize = t.itemSize), (this.count = t.count), (this.normalized = t.normalized), (this.usage = t.usage), this;
					}
					copyAt(t, e, n) {
						(t *= this.itemSize), (n *= e.itemSize);
						for (let i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i];
						return this;
					}
					copyArray(t) {
						return this.array.set(t), this;
					}
					copyColorsArray(t) {
						const e = this.array;
						let n = 0;
						for (let i = 0, r = t.length; i < r; i++) {
							let r = t[i];
							void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), (r = new mn())), (e[n++] = r.r), (e[n++] = r.g), (e[n++] = r.b);
						}
						return this;
					}
					copyVector2sArray(t) {
						const e = this.array;
						let n = 0;
						for (let i = 0, r = t.length; i < r; i++) {
							let r = t[i];
							void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), (r = new Ot())), (e[n++] = r.x), (e[n++] = r.y);
						}
						return this;
					}
					copyVector3sArray(t) {
						const e = this.array;
						let n = 0;
						for (let i = 0, r = t.length; i < r; i++) {
							let r = t[i];
							void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), (r = new Xt())), (e[n++] = r.x), (e[n++] = r.y), (e[n++] = r.z);
						}
						return this;
					}
					copyVector4sArray(t) {
						const e = this.array;
						let n = 0;
						for (let i = 0, r = t.length; i < r; i++) {
							let r = t[i];
							void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), (r = new Ht())), (e[n++] = r.x), (e[n++] = r.y), (e[n++] = r.z), (e[n++] = r.w);
						}
						return this;
					}
					applyMatrix3(t) {
						if (2 === this.itemSize) for (let e = 0, n = this.count; e < n; e++) bn.fromBufferAttribute(this, e), bn.applyMatrix3(t), this.setXY(e, bn.x, bn.y);
						else if (3 === this.itemSize) for (let e = 0, n = this.count; e < n; e++) gn.fromBufferAttribute(this, e), gn.applyMatrix3(t), this.setXYZ(e, gn.x, gn.y, gn.z);
						return this;
					}
					applyMatrix4(t) {
						for (let e = 0, n = this.count; e < n; e++) (gn.x = this.getX(e)), (gn.y = this.getY(e)), (gn.z = this.getZ(e)), gn.applyMatrix4(t), this.setXYZ(e, gn.x, gn.y, gn.z);
						return this;
					}
					applyNormalMatrix(t) {
						for (let e = 0, n = this.count; e < n; e++) (gn.x = this.getX(e)), (gn.y = this.getY(e)), (gn.z = this.getZ(e)), gn.applyNormalMatrix(t), this.setXYZ(e, gn.x, gn.y, gn.z);
						return this;
					}
					transformDirection(t) {
						for (let e = 0, n = this.count; e < n; e++) (gn.x = this.getX(e)), (gn.y = this.getY(e)), (gn.z = this.getZ(e)), gn.transformDirection(t), this.setXYZ(e, gn.x, gn.y, gn.z);
						return this;
					}
					set(t, e = 0) {
						return this.array.set(t, e), this;
					}
					getX(t) {
						return this.array[t * this.itemSize];
					}
					setX(t, e) {
						return (this.array[t * this.itemSize] = e), this;
					}
					getY(t) {
						return this.array[t * this.itemSize + 1];
					}
					setY(t, e) {
						return (this.array[t * this.itemSize + 1] = e), this;
					}
					getZ(t) {
						return this.array[t * this.itemSize + 2];
					}
					setZ(t, e) {
						return (this.array[t * this.itemSize + 2] = e), this;
					}
					getW(t) {
						return this.array[t * this.itemSize + 3];
					}
					setW(t, e) {
						return (this.array[t * this.itemSize + 3] = e), this;
					}
					setXY(t, e, n) {
						return (t *= this.itemSize), (this.array[t + 0] = e), (this.array[t + 1] = n), this;
					}
					setXYZ(t, e, n, i) {
						return (t *= this.itemSize), (this.array[t + 0] = e), (this.array[t + 1] = n), (this.array[t + 2] = i), this;
					}
					setXYZW(t, e, n, i, r) {
						return (t *= this.itemSize), (this.array[t + 0] = e), (this.array[t + 1] = n), (this.array[t + 2] = i), (this.array[t + 3] = r), this;
					}
					onUpload(t) {
						return (this.onUploadCallback = t), this;
					}
					clone() {
						return new this.constructor(this.array, this.itemSize).copy(this);
					}
					toJSON() {
						const t = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized };
						return "" !== this.name && (t.name = this.name), this.usage !== vt && (t.usage = this.usage), (0 === this.updateRange.offset && -1 === this.updateRange.count) || (t.updateRange = this.updateRange), t;
					}
				}
				xn.prototype.isBufferAttribute = !0;
				class yn extends xn {
					constructor(t, e, n) {
						super(new Uint16Array(t), e, n);
					}
				}
				class _n extends xn {
					constructor(t, e, n) {
						super(new Uint32Array(t), e, n);
					}
				}
				(class extends xn {
					constructor(t, e, n) {
						super(new Uint16Array(t), e, n);
					}
				}.prototype.isFloat16BufferAttribute = !0);
				class wn extends xn {
					constructor(t, e, n) {
						super(new Float32Array(t), e, n);
					}
				}
				let Mn = 0;
				const Sn = new Me(),
					Tn = new Ye(),
					En = new Xt(),
					Cn = new Zt(),
					Pn = new Zt(),
					An = new Xt();
				class Ln extends xt {
					constructor() {
						super(), Object.defineProperty(this, "id", { value: Mn++ }), (this.uuid = Tt()), (this.name = ""), (this.type = "BufferGeometry"), (this.index = null), (this.attributes = {}), (this.morphAttributes = {}), (this.morphTargetsRelative = !1), (this.groups = []), (this.boundingBox = null), (this.boundingSphere = null), (this.drawRange = { start: 0, count: 1 / 0 }), (this.userData = {});
					}
					getIndex() {
						return this.index;
					}
					setIndex(t) {
						return Array.isArray(t) ? (this.index = new (It(t) > 65535 ? _n : yn)(t, 1)) : (this.index = t), this;
					}
					getAttribute(t) {
						return this.attributes[t];
					}
					setAttribute(t, e) {
						return (this.attributes[t] = e), this;
					}
					deleteAttribute(t) {
						return delete this.attributes[t], this;
					}
					hasAttribute(t) {
						return void 0 !== this.attributes[t];
					}
					addGroup(t, e, n = 0) {
						this.groups.push({ start: t, count: e, materialIndex: n });
					}
					clearGroups() {
						this.groups = [];
					}
					setDrawRange(t, e) {
						(this.drawRange.start = t), (this.drawRange.count = e);
					}
					applyMatrix4(t) {
						const e = this.attributes.position;
						void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
						const n = this.attributes.normal;
						if (void 0 !== n) {
							const e = new zt().getNormalMatrix(t);
							n.applyNormalMatrix(e), (n.needsUpdate = !0);
						}
						const i = this.attributes.tangent;
						return void 0 !== i && (i.transformDirection(t), (i.needsUpdate = !0)), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
					}
					applyQuaternion(t) {
						return Sn.makeRotationFromQuaternion(t), this.applyMatrix4(Sn), this;
					}
					rotateX(t) {
						return Sn.makeRotationX(t), this.applyMatrix4(Sn), this;
					}
					rotateY(t) {
						return Sn.makeRotationY(t), this.applyMatrix4(Sn), this;
					}
					rotateZ(t) {
						return Sn.makeRotationZ(t), this.applyMatrix4(Sn), this;
					}
					translate(t, e, n) {
						return Sn.makeTranslation(t, e, n), this.applyMatrix4(Sn), this;
					}
					scale(t, e, n) {
						return Sn.makeScale(t, e, n), this.applyMatrix4(Sn), this;
					}
					lookAt(t) {
						return Tn.lookAt(t), Tn.updateMatrix(), this.applyMatrix4(Tn.matrix), this;
					}
					center() {
						return this.computeBoundingBox(), this.boundingBox.getCenter(En).negate(), this.translate(En.x, En.y, En.z), this;
					}
					setFromPoints(t) {
						const e = [];
						for (let n = 0, i = t.length; n < i; n++) {
							const i = t[n];
							e.push(i.x, i.y, i.z || 0);
						}
						return this.setAttribute("position", new wn(e, 3)), this;
					}
					computeBoundingBox() {
						null === this.boundingBox && (this.boundingBox = new Zt());
						const t = this.attributes.position,
							e = this.morphAttributes.position;
						if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Xt(-1 / 0, -1 / 0, -1 / 0), new Xt(1 / 0, 1 / 0, 1 / 0));
						if (void 0 !== t) {
							if ((this.boundingBox.setFromBufferAttribute(t), e))
								for (let t = 0, n = e.length; t < n; t++) {
									const n = e[t];
									Cn.setFromBufferAttribute(n), this.morphTargetsRelative ? (An.addVectors(this.boundingBox.min, Cn.min), this.boundingBox.expandByPoint(An), An.addVectors(this.boundingBox.max, Cn.max), this.boundingBox.expandByPoint(An)) : (this.boundingBox.expandByPoint(Cn.min), this.boundingBox.expandByPoint(Cn.max));
								}
						} else this.boundingBox.makeEmpty();
						(isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
					}
					computeBoundingSphere() {
						null === this.boundingSphere && (this.boundingSphere = new fe());
						const t = this.attributes.position,
							e = this.morphAttributes.position;
						if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Xt(), 1 / 0);
						if (t) {
							const n = this.boundingSphere.center;
							if ((Cn.setFromBufferAttribute(t), e))
								for (let t = 0, n = e.length; t < n; t++) {
									const n = e[t];
									Pn.setFromBufferAttribute(n), this.morphTargetsRelative ? (An.addVectors(Cn.min, Pn.min), Cn.expandByPoint(An), An.addVectors(Cn.max, Pn.max), Cn.expandByPoint(An)) : (Cn.expandByPoint(Pn.min), Cn.expandByPoint(Pn.max));
								}
							Cn.getCenter(n);
							let i = 0;
							for (let e = 0, r = t.count; e < r; e++) An.fromBufferAttribute(t, e), (i = Math.max(i, n.distanceToSquared(An)));
							if (e)
								for (let r = 0, a = e.length; r < a; r++) {
									const a = e[r],
										s = this.morphTargetsRelative;
									for (let e = 0, r = a.count; e < r; e++) An.fromBufferAttribute(a, e), s && (En.fromBufferAttribute(t, e), An.add(En)), (i = Math.max(i, n.distanceToSquared(An)));
								}
							(this.boundingSphere.radius = Math.sqrt(i)), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
						}
					}
					computeTangents() {
						const t = this.index,
							e = this.attributes;
						if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
						const n = t.array,
							i = e.position.array,
							r = e.normal.array,
							a = e.uv.array,
							s = i.length / 3;
						void 0 === e.tangent && this.setAttribute("tangent", new xn(new Float32Array(4 * s), 4));
						const o = e.tangent.array,
							l = [],
							c = [];
						for (let t = 0; t < s; t++) (l[t] = new Xt()), (c[t] = new Xt());
						const u = new Xt(),
							h = new Xt(),
							d = new Xt(),
							p = new Ot(),
							f = new Ot(),
							m = new Ot(),
							v = new Xt(),
							g = new Xt();
						function b(t, e, n) {
							u.fromArray(i, 3 * t), h.fromArray(i, 3 * e), d.fromArray(i, 3 * n), p.fromArray(a, 2 * t), f.fromArray(a, 2 * e), m.fromArray(a, 2 * n), h.sub(u), d.sub(u), f.sub(p), m.sub(p);
							const r = 1 / (f.x * m.y - m.x * f.y);
							isFinite(r) && (v.copy(h).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(r), g.copy(d).multiplyScalar(f.x).addScaledVector(h, -m.x).multiplyScalar(r), l[t].add(v), l[e].add(v), l[n].add(v), c[t].add(g), c[e].add(g), c[n].add(g));
						}
						let x = this.groups;
						0 === x.length && (x = [{ start: 0, count: n.length }]);
						for (let t = 0, e = x.length; t < e; ++t) {
							const e = x[t],
								i = e.start;
							for (let t = i, r = i + e.count; t < r; t += 3) b(n[t + 0], n[t + 1], n[t + 2]);
						}
						const y = new Xt(),
							_ = new Xt(),
							w = new Xt(),
							M = new Xt();
						function S(t) {
							w.fromArray(r, 3 * t), M.copy(w);
							const e = l[t];
							y.copy(e), y.sub(w.multiplyScalar(w.dot(e))).normalize(), _.crossVectors(M, e);
							const n = _.dot(c[t]) < 0 ? -1 : 1;
							(o[4 * t] = y.x), (o[4 * t + 1] = y.y), (o[4 * t + 2] = y.z), (o[4 * t + 3] = n);
						}
						for (let t = 0, e = x.length; t < e; ++t) {
							const e = x[t],
								i = e.start;
							for (let t = i, r = i + e.count; t < r; t += 3) S(n[t + 0]), S(n[t + 1]), S(n[t + 2]);
						}
					}
					computeVertexNormals() {
						const t = this.index,
							e = this.getAttribute("position");
						if (void 0 !== e) {
							let n = this.getAttribute("normal");
							if (void 0 === n) (n = new xn(new Float32Array(3 * e.count), 3)), this.setAttribute("normal", n);
							else for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
							const i = new Xt(),
								r = new Xt(),
								a = new Xt(),
								s = new Xt(),
								o = new Xt(),
								l = new Xt(),
								c = new Xt(),
								u = new Xt();
							if (t)
								for (let h = 0, d = t.count; h < d; h += 3) {
									const d = t.getX(h + 0),
										p = t.getX(h + 1),
										f = t.getX(h + 2);
									i.fromBufferAttribute(e, d), r.fromBufferAttribute(e, p), a.fromBufferAttribute(e, f), c.subVectors(a, r), u.subVectors(i, r), c.cross(u), s.fromBufferAttribute(n, d), o.fromBufferAttribute(n, p), l.fromBufferAttribute(n, f), s.add(c), o.add(c), l.add(c), n.setXYZ(d, s.x, s.y, s.z), n.setXYZ(p, o.x, o.y, o.z), n.setXYZ(f, l.x, l.y, l.z);
								}
							else for (let t = 0, s = e.count; t < s; t += 3) i.fromBufferAttribute(e, t + 0), r.fromBufferAttribute(e, t + 1), a.fromBufferAttribute(e, t + 2), c.subVectors(a, r), u.subVectors(i, r), c.cross(u), n.setXYZ(t + 0, c.x, c.y, c.z), n.setXYZ(t + 1, c.x, c.y, c.z), n.setXYZ(t + 2, c.x, c.y, c.z);
							this.normalizeNormals(), (n.needsUpdate = !0);
						}
					}
					merge(t, e) {
						if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
						void 0 === e && ((e = 0), console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
						const n = this.attributes;
						for (const i in n) {
							if (void 0 === t.attributes[i]) continue;
							const r = n[i].array,
								a = t.attributes[i],
								s = a.array,
								o = a.itemSize * e,
								l = Math.min(s.length, r.length - o);
							for (let t = 0, e = o; t < l; t++, e++) r[e] = s[t];
						}
						return this;
					}
					normalizeNormals() {
						const t = this.attributes.normal;
						for (let e = 0, n = t.count; e < n; e++) An.fromBufferAttribute(t, e), An.normalize(), t.setXYZ(e, An.x, An.y, An.z);
					}
					toNonIndexed() {
						function t(t, e) {
							const n = t.array,
								i = t.itemSize,
								r = t.normalized,
								a = new n.constructor(e.length * i);
							let s = 0,
								o = 0;
							for (let r = 0, l = e.length; r < l; r++) {
								s = t.isInterleavedBufferAttribute ? e[r] * t.data.stride + t.offset : e[r] * i;
								for (let t = 0; t < i; t++) a[o++] = n[s++];
							}
							return new xn(a, i, r);
						}
						if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
						const e = new Ln(),
							n = this.index.array,
							i = this.attributes;
						for (const r in i) {
							const a = t(i[r], n);
							e.setAttribute(r, a);
						}
						const r = this.morphAttributes;
						for (const i in r) {
							const a = [],
								s = r[i];
							for (let e = 0, i = s.length; e < i; e++) {
								const i = t(s[e], n);
								a.push(i);
							}
							e.morphAttributes[i] = a;
						}
						e.morphTargetsRelative = this.morphTargetsRelative;
						const a = this.groups;
						for (let t = 0, n = a.length; t < n; t++) {
							const n = a[t];
							e.addGroup(n.start, n.count, n.materialIndex);
						}
						return e;
					}
					toJSON() {
						const t = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
						if (((t.uuid = this.uuid), (t.type = this.type), "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters)) {
							const e = this.parameters;
							for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
							return t;
						}
						t.data = { attributes: {} };
						const e = this.index;
						null !== e && (t.data.index = { type: e.array.constructor.name, array: Array.prototype.slice.call(e.array) });
						const n = this.attributes;
						for (const e in n) {
							const i = n[e];
							t.data.attributes[e] = i.toJSON(t.data);
						}
						const i = {};
						let r = !1;
						for (const e in this.morphAttributes) {
							const n = this.morphAttributes[e],
								a = [];
							for (let e = 0, i = n.length; e < i; e++) {
								const i = n[e];
								a.push(i.toJSON(t.data));
							}
							a.length > 0 && ((i[e] = a), (r = !0));
						}
						r && ((t.data.morphAttributes = i), (t.data.morphTargetsRelative = this.morphTargetsRelative));
						const a = this.groups;
						a.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(a)));
						const s = this.boundingSphere;
						return null !== s && (t.data.boundingSphere = { center: s.center.toArray(), radius: s.radius }), t;
					}
					clone() {
						return new this.constructor().copy(this);
					}
					copy(t) {
						(this.index = null), (this.attributes = {}), (this.morphAttributes = {}), (this.groups = []), (this.boundingBox = null), (this.boundingSphere = null);
						const e = {};
						this.name = t.name;
						const n = t.index;
						null !== n && this.setIndex(n.clone(e));
						const i = t.attributes;
						for (const t in i) {
							const n = i[t];
							this.setAttribute(t, n.clone(e));
						}
						const r = t.morphAttributes;
						for (const t in r) {
							const n = [],
								i = r[t];
							for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));
							this.morphAttributes[t] = n;
						}
						this.morphTargetsRelative = t.morphTargetsRelative;
						const a = t.groups;
						for (let t = 0, e = a.length; t < e; t++) {
							const e = a[t];
							this.addGroup(e.start, e.count, e.materialIndex);
						}
						const s = t.boundingBox;
						null !== s && (this.boundingBox = s.clone());
						const o = t.boundingSphere;
						return null !== o && (this.boundingSphere = o.clone()), (this.drawRange.start = t.drawRange.start), (this.drawRange.count = t.drawRange.count), (this.userData = t.userData), void 0 !== t.parameters && (this.parameters = Object.assign({}, t.parameters)), this;
					}
					dispose() {
						this.dispatchEvent({ type: "dispose" });
					}
				}
				Ln.prototype.isBufferGeometry = !0;
				const Rn = new Me(),
					Dn = new we(),
					On = new fe(),
					zn = new Xt(),
					In = new Xt(),
					kn = new Xt(),
					Nn = new Xt(),
					Vn = new Xt(),
					Bn = new Xt(),
					Fn = new Xt(),
					Un = new Xt(),
					Hn = new Xt(),
					Gn = new Ot(),
					Wn = new Ot(),
					jn = new Ot(),
					Xn = new Xt(),
					qn = new Xt();
				class Yn extends Ye {
					constructor(t = new Ln(), e = new vn()) {
						super(), (this.type = "Mesh"), (this.geometry = t), (this.material = e), this.updateMorphTargets();
					}
					copy(t) {
						return super.copy(t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), (this.material = t.material), (this.geometry = t.geometry), this;
					}
					updateMorphTargets() {
						const t = this.geometry;
						if (t.isBufferGeometry) {
							const e = t.morphAttributes,
								n = Object.keys(e);
							if (n.length > 0) {
								const t = e[n[0]];
								if (void 0 !== t) {
									(this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
									for (let e = 0, n = t.length; e < n; e++) {
										const n = t[e].name || String(e);
										this.morphTargetInfluences.push(0), (this.morphTargetDictionary[n] = e);
									}
								}
							}
						} else {
							const e = t.morphTargets;
							void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
						}
					}
					raycast(t, e) {
						const n = this.geometry,
							i = this.material,
							r = this.matrixWorld;
						if (void 0 === i) return;
						if ((null === n.boundingSphere && n.computeBoundingSphere(), On.copy(n.boundingSphere), On.applyMatrix4(r), !1 === t.ray.intersectsSphere(On))) return;
						if ((Rn.copy(r).invert(), Dn.copy(t.ray).applyMatrix4(Rn), null !== n.boundingBox && !1 === Dn.intersectsBox(n.boundingBox))) return;
						let a;
						if (n.isBufferGeometry) {
							const r = n.index,
								s = n.attributes.position,
								o = n.morphAttributes.position,
								l = n.morphTargetsRelative,
								c = n.attributes.uv,
								u = n.attributes.uv2,
								h = n.groups,
								d = n.drawRange;
							if (null !== r)
								if (Array.isArray(i))
									for (let n = 0, p = h.length; n < p; n++) {
										const p = h[n],
											f = i[p.materialIndex];
										for (let n = Math.max(p.start, d.start), i = Math.min(r.count, Math.min(p.start + p.count, d.start + d.count)); n < i; n += 3) {
											const i = r.getX(n),
												h = r.getX(n + 1),
												d = r.getX(n + 2);
											(a = Zn(this, f, t, Dn, s, o, l, c, u, i, h, d)), a && ((a.faceIndex = Math.floor(n / 3)), (a.face.materialIndex = p.materialIndex), e.push(a));
										}
									}
								else {
									for (let n = Math.max(0, d.start), h = Math.min(r.count, d.start + d.count); n < h; n += 3) {
										const h = r.getX(n),
											d = r.getX(n + 1),
											p = r.getX(n + 2);
										(a = Zn(this, i, t, Dn, s, o, l, c, u, h, d, p)), a && ((a.faceIndex = Math.floor(n / 3)), e.push(a));
									}
								}
							else if (void 0 !== s)
								if (Array.isArray(i))
									for (let n = 0, r = h.length; n < r; n++) {
										const r = h[n],
											p = i[r.materialIndex];
										for (let n = Math.max(r.start, d.start), i = Math.min(s.count, Math.min(r.start + r.count, d.start + d.count)); n < i; n += 3) {
											(a = Zn(this, p, t, Dn, s, o, l, c, u, n, n + 1, n + 2)), a && ((a.faceIndex = Math.floor(n / 3)), (a.face.materialIndex = r.materialIndex), e.push(a));
										}
									}
								else {
									for (let n = Math.max(0, d.start), r = Math.min(s.count, d.start + d.count); n < r; n += 3) {
										(a = Zn(this, i, t, Dn, s, o, l, c, u, n, n + 1, n + 2)), a && ((a.faceIndex = Math.floor(n / 3)), e.push(a));
									}
								}
						} else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
					}
				}
				function Zn(t, e, n, i, r, a, s, o, l, c, u, h) {
					zn.fromBufferAttribute(r, c), In.fromBufferAttribute(r, u), kn.fromBufferAttribute(r, h);
					const d = t.morphTargetInfluences;
					if (a && d) {
						Fn.set(0, 0, 0), Un.set(0, 0, 0), Hn.set(0, 0, 0);
						for (let t = 0, e = a.length; t < e; t++) {
							const e = d[t],
								n = a[t];
							0 !== e && (Nn.fromBufferAttribute(n, c), Vn.fromBufferAttribute(n, u), Bn.fromBufferAttribute(n, h), s ? (Fn.addScaledVector(Nn, e), Un.addScaledVector(Vn, e), Hn.addScaledVector(Bn, e)) : (Fn.addScaledVector(Nn.sub(zn), e), Un.addScaledVector(Vn.sub(In), e), Hn.addScaledVector(Bn.sub(kn), e)));
						}
						zn.add(Fn), In.add(Un), kn.add(Hn);
					}
					t.isSkinnedMesh && (t.boneTransform(c, zn), t.boneTransform(u, In), t.boneTransform(h, kn));
					const p = (function (t, e, n, i, r, a, s, o) {
						let l;
						if (((l = 1 === e.side ? i.intersectTriangle(s, a, r, !0, o) : i.intersectTriangle(r, a, s, 2 !== e.side, o)), null === l)) return null;
						qn.copy(o), qn.applyMatrix4(t.matrixWorld);
						const c = n.ray.origin.distanceTo(qn);
						return c < n.near || c > n.far ? null : { distance: c, point: qn.clone(), object: t };
					})(t, e, n, i, zn, In, kn, Xn);
					if (p) {
						o && (Gn.fromBufferAttribute(o, c), Wn.fromBufferAttribute(o, u), jn.fromBufferAttribute(o, h), (p.uv = sn.getUV(Xn, zn, In, kn, Gn, Wn, jn, new Ot()))), l && (Gn.fromBufferAttribute(l, c), Wn.fromBufferAttribute(l, u), jn.fromBufferAttribute(l, h), (p.uv2 = sn.getUV(Xn, zn, In, kn, Gn, Wn, jn, new Ot())));
						const t = { a: c, b: u, c: h, normal: new Xt(), materialIndex: 0 };
						sn.getNormal(zn, In, kn, t.normal), (p.face = t);
					}
					return p;
				}
				Yn.prototype.isMesh = !0;
				class Kn extends Ln {
					constructor(t = 1, e = 1, n = 1, i = 1, r = 1, a = 1) {
						super(), (this.type = "BoxGeometry"), (this.parameters = { width: t, height: e, depth: n, widthSegments: i, heightSegments: r, depthSegments: a });
						const s = this;
						(i = Math.floor(i)), (r = Math.floor(r)), (a = Math.floor(a));
						const o = [],
							l = [],
							c = [],
							u = [];
						let h = 0,
							d = 0;
						function p(t, e, n, i, r, a, p, f, m, v, g) {
							const b = a / m,
								x = p / v,
								y = a / 2,
								_ = p / 2,
								w = f / 2,
								M = m + 1,
								S = v + 1;
							let T = 0,
								E = 0;
							const C = new Xt();
							for (let a = 0; a < S; a++) {
								const s = a * x - _;
								for (let o = 0; o < M; o++) {
									const h = o * b - y;
									(C[t] = h * i), (C[e] = s * r), (C[n] = w), l.push(C.x, C.y, C.z), (C[t] = 0), (C[e] = 0), (C[n] = f > 0 ? 1 : -1), c.push(C.x, C.y, C.z), u.push(o / m), u.push(1 - a / v), (T += 1);
								}
							}
							for (let t = 0; t < v; t++)
								for (let e = 0; e < m; e++) {
									const n = h + e + M * t,
										i = h + e + M * (t + 1),
										r = h + (e + 1) + M * (t + 1),
										a = h + (e + 1) + M * t;
									o.push(n, i, a), o.push(i, r, a), (E += 6);
								}
							s.addGroup(d, E, g), (d += E), (h += T);
						}
						p("z", "y", "x", -1, -1, n, e, t, a, r, 0), p("z", "y", "x", 1, -1, n, e, -t, a, r, 1), p("x", "z", "y", 1, 1, t, n, e, i, a, 2), p("x", "z", "y", 1, -1, t, n, -e, i, a, 3), p("x", "y", "z", 1, -1, t, e, n, i, r, 4), p("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(o), this.setAttribute("position", new wn(l, 3)), this.setAttribute("normal", new wn(c, 3)), this.setAttribute("uv", new wn(u, 2));
					}
					static fromJSON(t) {
						return new Kn(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments);
					}
				}
				function Jn(t) {
					const e = {};
					for (const n in t) {
						e[n] = {};
						for (const i in t[n]) {
							const r = t[n][i];
							r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? (e[n][i] = r.clone()) : Array.isArray(r) ? (e[n][i] = r.slice()) : (e[n][i] = r);
						}
					}
					return e;
				}
				function Qn(t) {
					const e = {};
					for (let n = 0; n < t.length; n++) {
						const i = Jn(t[n]);
						for (const t in i) e[t] = i[t];
					}
					return e;
				}
				const $n = { clone: Jn, merge: Qn };
				class ti extends ln {
					constructor(t) {
						super(),
							(this.type = "ShaderMaterial"),
							(this.defines = {}),
							(this.uniforms = {}),
							(this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
							(this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
							(this.linewidth = 1),
							(this.wireframe = !1),
							(this.wireframeLinewidth = 1),
							(this.fog = !1),
							(this.lights = !1),
							(this.clipping = !1),
							(this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }),
							(this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }),
							(this.index0AttributeName = void 0),
							(this.uniformsNeedUpdate = !1),
							(this.glslVersion = null),
							void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t));
					}
					copy(t) {
						return super.copy(t), (this.fragmentShader = t.fragmentShader), (this.vertexShader = t.vertexShader), (this.uniforms = Jn(t.uniforms)), (this.defines = Object.assign({}, t.defines)), (this.wireframe = t.wireframe), (this.wireframeLinewidth = t.wireframeLinewidth), (this.lights = t.lights), (this.clipping = t.clipping), (this.extensions = Object.assign({}, t.extensions)), (this.glslVersion = t.glslVersion), this;
					}
					toJSON(t) {
						const e = super.toJSON(t);
						(e.glslVersion = this.glslVersion), (e.uniforms = {});
						for (const n in this.uniforms) {
							const i = this.uniforms[n].value;
							i && i.isTexture
								? (e.uniforms[n] = { type: "t", value: i.toJSON(t).uuid })
								: i && i.isColor
								? (e.uniforms[n] = { type: "c", value: i.getHex() })
								: i && i.isVector2
								? (e.uniforms[n] = { type: "v2", value: i.toArray() })
								: i && i.isVector3
								? (e.uniforms[n] = { type: "v3", value: i.toArray() })
								: i && i.isVector4
								? (e.uniforms[n] = { type: "v4", value: i.toArray() })
								: i && i.isMatrix3
								? (e.uniforms[n] = { type: "m3", value: i.toArray() })
								: i && i.isMatrix4
								? (e.uniforms[n] = { type: "m4", value: i.toArray() })
								: (e.uniforms[n] = { value: i });
						}
						Object.keys(this.defines).length > 0 && (e.defines = this.defines), (e.vertexShader = this.vertexShader), (e.fragmentShader = this.fragmentShader);
						const n = {};
						for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);
						return Object.keys(n).length > 0 && (e.extensions = n), e;
					}
				}
				ti.prototype.isShaderMaterial = !0;
				class ei extends Ye {
					constructor() {
						super(), (this.type = "Camera"), (this.matrixWorldInverse = new Me()), (this.projectionMatrix = new Me()), (this.projectionMatrixInverse = new Me());
					}
					copy(t, e) {
						return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this;
					}
					getWorldDirection(t) {
						this.updateWorldMatrix(!0, !1);
						const e = this.matrixWorld.elements;
						return t.set(-e[8], -e[9], -e[10]).normalize();
					}
					updateMatrixWorld(t) {
						super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
					}
					updateWorldMatrix(t, e) {
						super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
					}
					clone() {
						return new this.constructor().copy(this);
					}
				}
				ei.prototype.isCamera = !0;
				class ni extends ei {
					constructor(t = 50, e = 1, n = 0.1, i = 2e3) {
						super(), (this.type = "PerspectiveCamera"), (this.fov = t), (this.zoom = 1), (this.near = n), (this.far = i), (this.focus = 10), (this.aspect = e), (this.view = null), (this.filmGauge = 35), (this.filmOffset = 0), this.updateProjectionMatrix();
					}
					copy(t, e) {
						return super.copy(t, e), (this.fov = t.fov), (this.zoom = t.zoom), (this.near = t.near), (this.far = t.far), (this.focus = t.focus), (this.aspect = t.aspect), (this.view = null === t.view ? null : Object.assign({}, t.view)), (this.filmGauge = t.filmGauge), (this.filmOffset = t.filmOffset), this;
					}
					setFocalLength(t) {
						const e = (0.5 * this.getFilmHeight()) / t;
						(this.fov = 2 * wt * Math.atan(e)), this.updateProjectionMatrix();
					}
					getFocalLength() {
						const t = Math.tan(0.5 * _t * this.fov);
						return (0.5 * this.getFilmHeight()) / t;
					}
					getEffectiveFOV() {
						return 2 * wt * Math.atan(Math.tan(0.5 * _t * this.fov) / this.zoom);
					}
					getFilmWidth() {
						return this.filmGauge * Math.min(this.aspect, 1);
					}
					getFilmHeight() {
						return this.filmGauge / Math.max(this.aspect, 1);
					}
					setViewOffset(t, e, n, i, r, a) {
						(this.aspect = t / e), null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), (this.view.enabled = !0), (this.view.fullWidth = t), (this.view.fullHeight = e), (this.view.offsetX = n), (this.view.offsetY = i), (this.view.width = r), (this.view.height = a), this.updateProjectionMatrix();
					}
					clearViewOffset() {
						null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
					}
					updateProjectionMatrix() {
						const t = this.near;
						let e = (t * Math.tan(0.5 * _t * this.fov)) / this.zoom,
							n = 2 * e,
							i = this.aspect * n,
							r = -0.5 * i;
						const a = this.view;
						if (null !== this.view && this.view.enabled) {
							const t = a.fullWidth,
								s = a.fullHeight;
							(r += (a.offsetX * i) / t), (e -= (a.offsetY * n) / s), (i *= a.width / t), (n *= a.height / s);
						}
						const s = this.filmOffset;
						0 !== s && (r += (t * s) / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
					}
					toJSON(t) {
						const e = super.toJSON(t);
						return (e.object.fov = this.fov), (e.object.zoom = this.zoom), (e.object.near = this.near), (e.object.far = this.far), (e.object.focus = this.focus), (e.object.aspect = this.aspect), null !== this.view && (e.object.view = Object.assign({}, this.view)), (e.object.filmGauge = this.filmGauge), (e.object.filmOffset = this.filmOffset), e;
					}
				}
				ni.prototype.isPerspectiveCamera = !0;
				const ii = 90;
				class ri extends Ye {
					constructor(t, e, n) {
						if ((super(), (this.type = "CubeCamera"), !0 !== n.isWebGLCubeRenderTarget)) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
						this.renderTarget = n;
						const i = new ni(ii, 1, t, e);
						(i.layers = this.layers), i.up.set(0, -1, 0), i.lookAt(new Xt(1, 0, 0)), this.add(i);
						const r = new ni(ii, 1, t, e);
						(r.layers = this.layers), r.up.set(0, -1, 0), r.lookAt(new Xt(-1, 0, 0)), this.add(r);
						const a = new ni(ii, 1, t, e);
						(a.layers = this.layers), a.up.set(0, 0, 1), a.lookAt(new Xt(0, 1, 0)), this.add(a);
						const s = new ni(ii, 1, t, e);
						(s.layers = this.layers), s.up.set(0, 0, -1), s.lookAt(new Xt(0, -1, 0)), this.add(s);
						const o = new ni(ii, 1, t, e);
						(o.layers = this.layers), o.up.set(0, -1, 0), o.lookAt(new Xt(0, 0, 1)), this.add(o);
						const l = new ni(ii, 1, t, e);
						(l.layers = this.layers), l.up.set(0, -1, 0), l.lookAt(new Xt(0, 0, -1)), this.add(l);
					}
					update(t, e) {
						null === this.parent && this.updateMatrixWorld();
						const n = this.renderTarget,
							[i, r, a, s, o, l] = this.children,
							c = t.xr.enabled,
							u = t.getRenderTarget();
						t.xr.enabled = !1;
						const h = n.texture.generateMipmaps;
						(n.texture.generateMipmaps = !1), t.setRenderTarget(n, 0), t.render(e, i), t.setRenderTarget(n, 1), t.render(e, r), t.setRenderTarget(n, 2), t.render(e, a), t.setRenderTarget(n, 3), t.render(e, s), t.setRenderTarget(n, 4), t.render(e, o), (n.texture.generateMipmaps = h), t.setRenderTarget(n, 5), t.render(e, l), t.setRenderTarget(u), (t.xr.enabled = c);
					}
				}
				class ai extends Ft {
					constructor(t, e, n, i, r, a, s, o, l, c) {
						super((t = void 0 !== t ? t : []), (e = void 0 !== e ? e : z), n, i, r, a, s, o, l, c), (this.flipY = !1);
					}
					get images() {
						return this.image;
					}
					set images(t) {
						this.image = t;
					}
				}
				ai.prototype.isCubeTexture = !0;
				class si extends Gt {
					constructor(t, e, n) {
						Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), (e = n)),
							super(t, t, e),
							(e = e || {}),
							(this.texture = new ai(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding)),
							(this.texture.isRenderTargetTexture = !0),
							(this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps),
							(this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : X),
							(this.texture._needsFlipEnvMap = !1);
					}
					fromEquirectangularTexture(t, e) {
						(this.texture.type = e.type), (this.texture.format = et), (this.texture.encoding = e.encoding), (this.texture.generateMipmaps = e.generateMipmaps), (this.texture.minFilter = e.minFilter), (this.texture.magFilter = e.magFilter);
						const n = {
								uniforms: { tEquirect: { value: null } },
								vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
								fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
							},
							i = new Kn(5, 5, 5),
							r = new ti({ name: "CubemapFromEquirect", uniforms: Jn(n.uniforms), vertexShader: n.vertexShader, fragmentShader: n.fragmentShader, side: 1, blending: 0 });
						r.uniforms.tEquirect.value = e;
						const a = new Yn(i, r),
							s = e.minFilter;
						e.minFilter === q && (e.minFilter = X);
						return new ri(1, 10, this).update(t, a), (e.minFilter = s), a.geometry.dispose(), a.material.dispose(), this;
					}
					clear(t, e, n, i) {
						const r = t.getRenderTarget();
						for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(e, n, i);
						t.setRenderTarget(r);
					}
				}
				si.prototype.isWebGLCubeRenderTarget = !0;
				const oi = new Xt(),
					li = new Xt(),
					ci = new zt();
				class ui {
					constructor(t = new Xt(1, 0, 0), e = 0) {
						(this.normal = t), (this.constant = e);
					}
					set(t, e) {
						return this.normal.copy(t), (this.constant = e), this;
					}
					setComponents(t, e, n, i) {
						return this.normal.set(t, e, n), (this.constant = i), this;
					}
					setFromNormalAndCoplanarPoint(t, e) {
						return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this;
					}
					setFromCoplanarPoints(t, e, n) {
						const i = oi.subVectors(n, e).cross(li.subVectors(t, e)).normalize();
						return this.setFromNormalAndCoplanarPoint(i, t), this;
					}
					copy(t) {
						return this.normal.copy(t.normal), (this.constant = t.constant), this;
					}
					normalize() {
						const t = 1 / this.normal.length();
						return this.normal.multiplyScalar(t), (this.constant *= t), this;
					}
					negate() {
						return (this.constant *= -1), this.normal.negate(), this;
					}
					distanceToPoint(t) {
						return this.normal.dot(t) + this.constant;
					}
					distanceToSphere(t) {
						return this.distanceToPoint(t.center) - t.radius;
					}
					projectPoint(t, e) {
						return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t);
					}
					intersectLine(t, e) {
						const n = t.delta(oi),
							i = this.normal.dot(n);
						if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
						const r = -(t.start.dot(this.normal) + this.constant) / i;
						return r < 0 || r > 1 ? null : e.copy(n).multiplyScalar(r).add(t.start);
					}
					intersectsLine(t) {
						const e = this.distanceToPoint(t.start),
							n = this.distanceToPoint(t.end);
						return (e < 0 && n > 0) || (n < 0 && e > 0);
					}
					intersectsBox(t) {
						return t.intersectsPlane(this);
					}
					intersectsSphere(t) {
						return t.intersectsPlane(this);
					}
					coplanarPoint(t) {
						return t.copy(this.normal).multiplyScalar(-this.constant);
					}
					applyMatrix4(t, e) {
						const n = e || ci.getNormalMatrix(t),
							i = this.coplanarPoint(oi).applyMatrix4(t),
							r = this.normal.applyMatrix3(n).normalize();
						return (this.constant = -i.dot(r)), this;
					}
					translate(t) {
						return (this.constant -= t.dot(this.normal)), this;
					}
					equals(t) {
						return t.normal.equals(this.normal) && t.constant === this.constant;
					}
					clone() {
						return new this.constructor().copy(this);
					}
				}
				ui.prototype.isPlane = !0;
				const hi = new fe(),
					di = new Xt();
				class pi {
					constructor(t = new ui(), e = new ui(), n = new ui(), i = new ui(), r = new ui(), a = new ui()) {
						this.planes = [t, e, n, i, r, a];
					}
					set(t, e, n, i, r, a) {
						const s = this.planes;
						return s[0].copy(t), s[1].copy(e), s[2].copy(n), s[3].copy(i), s[4].copy(r), s[5].copy(a), this;
					}
					copy(t) {
						const e = this.planes;
						for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
						return this;
					}
					setFromProjectionMatrix(t) {
						const e = this.planes,
							n = t.elements,
							i = n[0],
							r = n[1],
							a = n[2],
							s = n[3],
							o = n[4],
							l = n[5],
							c = n[6],
							u = n[7],
							h = n[8],
							d = n[9],
							p = n[10],
							f = n[11],
							m = n[12],
							v = n[13],
							g = n[14],
							b = n[15];
						return e[0].setComponents(s - i, u - o, f - h, b - m).normalize(), e[1].setComponents(s + i, u + o, f + h, b + m).normalize(), e[2].setComponents(s + r, u + l, f + d, b + v).normalize(), e[3].setComponents(s - r, u - l, f - d, b - v).normalize(), e[4].setComponents(s - a, u - c, f - p, b - g).normalize(), e[5].setComponents(s + a, u + c, f + p, b + g).normalize(), this;
					}
					intersectsObject(t) {
						const e = t.geometry;
						return null === e.boundingSphere && e.computeBoundingSphere(), hi.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(hi);
					}
					intersectsSprite(t) {
						return hi.center.set(0, 0, 0), (hi.radius = 0.7071067811865476), hi.applyMatrix4(t.matrixWorld), this.intersectsSphere(hi);
					}
					intersectsSphere(t) {
						const e = this.planes,
							n = t.center,
							i = -t.radius;
						for (let t = 0; t < 6; t++) {
							if (e[t].distanceToPoint(n) < i) return !1;
						}
						return !0;
					}
					intersectsBox(t) {
						const e = this.planes;
						for (let n = 0; n < 6; n++) {
							const i = e[n];
							if (((di.x = i.normal.x > 0 ? t.max.x : t.min.x), (di.y = i.normal.y > 0 ? t.max.y : t.min.y), (di.z = i.normal.z > 0 ? t.max.z : t.min.z), i.distanceToPoint(di) < 0)) return !1;
						}
						return !0;
					}
					containsPoint(t) {
						const e = this.planes;
						for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return !1;
						return !0;
					}
					clone() {
						return new this.constructor().copy(this);
					}
				}
				function fi() {
					let t = null,
						e = !1,
						n = null,
						i = null;
					function r(e, a) {
						n(e, a), (i = t.requestAnimationFrame(r));
					}
					return {
						start: function () {
							!0 !== e && null !== n && ((i = t.requestAnimationFrame(r)), (e = !0));
						},
						stop: function () {
							t.cancelAnimationFrame(i), (e = !1);
						},
						setAnimationLoop: function (t) {
							n = t;
						},
						setContext: function (e) {
							t = e;
						},
					};
				}
				function mi(t, e) {
					const n = e.isWebGL2,
						i = new WeakMap();
					return {
						get: function (t) {
							return t.isInterleavedBufferAttribute && (t = t.data), i.get(t);
						},
						remove: function (e) {
							e.isInterleavedBufferAttribute && (e = e.data);
							const n = i.get(e);
							n && (t.deleteBuffer(n.buffer), i.delete(e));
						},
						update: function (e, r) {
							if (e.isGLBufferAttribute) {
								const t = i.get(e);
								return void ((!t || t.version < e.version) && i.set(e, { buffer: e.buffer, type: e.type, bytesPerElement: e.elementSize, version: e.version }));
							}
							e.isInterleavedBufferAttribute && (e = e.data);
							const a = i.get(e);
							void 0 === a
								? i.set(
										e,
										(function (e, i) {
											const r = e.array,
												a = e.usage,
												s = t.createBuffer();
											t.bindBuffer(i, s), t.bufferData(i, r, a), e.onUploadCallback();
											let o = 5126;
											return (
												r instanceof Float32Array
													? (o = 5126)
													: r instanceof Float64Array
													? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.")
													: r instanceof Uint16Array
													? e.isFloat16BufferAttribute
														? n
															? (o = 5131)
															: console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.")
														: (o = 5123)
													: r instanceof Int16Array
													? (o = 5122)
													: r instanceof Uint32Array
													? (o = 5125)
													: r instanceof Int32Array
													? (o = 5124)
													: r instanceof Int8Array
													? (o = 5120)
													: (r instanceof Uint8Array || r instanceof Uint8ClampedArray) && (o = 5121),
												{ buffer: s, type: o, bytesPerElement: r.BYTES_PER_ELEMENT, version: e.version }
											);
										})(e, r)
								  )
								: a.version < e.version &&
								  (!(function (e, i, r) {
										const a = i.array,
											s = i.updateRange;
										t.bindBuffer(r, e), -1 === s.count ? t.bufferSubData(r, 0, a) : (n ? t.bufferSubData(r, s.offset * a.BYTES_PER_ELEMENT, a, s.offset, s.count) : t.bufferSubData(r, s.offset * a.BYTES_PER_ELEMENT, a.subarray(s.offset, s.offset + s.count)), (s.count = -1));
								  })(a.buffer, e, r),
								  (a.version = e.version));
						},
					};
				}
				class vi extends Ln {
					constructor(t = 1, e = 1, n = 1, i = 1) {
						super(), (this.type = "PlaneGeometry"), (this.parameters = { width: t, height: e, widthSegments: n, heightSegments: i });
						const r = t / 2,
							a = e / 2,
							s = Math.floor(n),
							o = Math.floor(i),
							l = s + 1,
							c = o + 1,
							u = t / s,
							h = e / o,
							d = [],
							p = [],
							f = [],
							m = [];
						for (let t = 0; t < c; t++) {
							const e = t * h - a;
							for (let n = 0; n < l; n++) {
								const i = n * u - r;
								p.push(i, -e, 0), f.push(0, 0, 1), m.push(n / s), m.push(1 - t / o);
							}
						}
						for (let t = 0; t < o; t++)
							for (let e = 0; e < s; e++) {
								const n = e + l * t,
									i = e + l * (t + 1),
									r = e + 1 + l * (t + 1),
									a = e + 1 + l * t;
								d.push(n, i, a), d.push(i, r, a);
							}
						this.setIndex(d), this.setAttribute("position", new wn(p, 3)), this.setAttribute("normal", new wn(f, 3)), this.setAttribute("uv", new wn(m, 2));
					}
					static fromJSON(t) {
						return new vi(t.width, t.height, t.widthSegments, t.heightSegments);
					}
				}
				const gi = {
						alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
						alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
						alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
						alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
						aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
						aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
						begin_vertex: "vec3 transformed = vec3( position );",
						beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
						bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenTint, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenTint * ( D * V );\n}\n#endif",
						bumpmap_pars_fragment:
							"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
						clipping_planes_fragment:
							"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
						clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
						clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
						clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
						color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
						color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
						color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
						color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
						common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
						cube_uv_reflection_fragment:
							"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
						defaultnormal_vertex:
							"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
						displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
						displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
						emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
						emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
						encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
						encodings_pars_fragment:
							"\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
						envmap_fragment:
							"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
						envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
						envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
						envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
						envmap_physical_pars_fragment:
							"#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
						envmap_vertex:
							"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
						fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
						fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
						fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
						fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
						gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
						lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
						lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
						lights_lambert_vertex:
							"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
						lights_pars_begin:
							"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
						lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
						lights_toon_pars_fragment:
							"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
						lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
						lights_phong_pars_fragment:
							"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
						lights_physical_fragment:
							"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularTintFactor = specularTint;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARTINTMAP\n\t\t\tspecularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularTintFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenTint = sheenTint;\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n#endif",
						lights_physical_pars_fragment:
							"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenTint;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenTint, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
						lights_fragment_begin:
							"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
						lights_fragment_maps:
							"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
						lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
						logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
						logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
						logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
						logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
						map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
						map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
						map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
						map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
						metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
						metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
						morphnormal_vertex:
							"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
						morphtarget_pars_vertex:
							"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
						morphtarget_vertex:
							"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
						normal_fragment_begin:
							"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
						normal_fragment_maps:
							"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
						normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
						normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
						normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
						normalmap_pars_fragment:
							"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
						clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
						clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
						clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
						output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
						packing:
							"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
						premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
						project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
						dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
						dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
						roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
						roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
						shadowmap_pars_fragment:
							"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
						shadowmap_pars_vertex:
							"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
						shadowmap_vertex:
							"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
						shadowmask_pars_fragment:
							"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
						skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
						skinning_pars_vertex:
							"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
						skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
						skinnormal_vertex:
							"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
						specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
						specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
						tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
						tonemapping_pars_fragment:
							"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
						transmission_fragment:
							"#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationTint, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
						transmission_pars_fragment:
							"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationTint;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
						uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
						uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
						uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
						uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
						uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
						uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
						worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
						background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
						background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
						cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
						cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
						depth_vert:
							"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
						depth_frag:
							"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
						distanceRGBA_vert:
							"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
						distanceRGBA_frag:
							"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
						equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
						equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
						linedashed_vert:
							"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
						linedashed_frag:
							"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
						meshbasic_vert:
							"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
						meshbasic_frag:
							"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
						meshlambert_vert:
							"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
						meshlambert_frag:
							"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
						meshmatcap_vert:
							"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
						meshmatcap_frag:
							"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
						meshnormal_vert:
							"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
						meshnormal_frag:
							"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
						meshphong_vert:
							"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
						meshphong_frag:
							"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
						meshphysical_vert:
							"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
						meshphysical_frag:
							"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularTint;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARTINTMAP\n\t\tuniform sampler2D specularTintMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenTint;\n\tuniform float sheenRoughness;\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
						meshtoon_vert:
							"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
						meshtoon_frag:
							"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
						points_vert:
							"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
						points_frag:
							"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
						shadow_vert:
							"#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
						shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
						sprite_vert:
							"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
						sprite_frag:
							"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
					},
					bi = {
						common: { diffuse: { value: new mn(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new zt() }, uv2Transform: { value: new zt() }, alphaMap: { value: null }, alphaTest: { value: 0 } },
						specularmap: { specularMap: { value: null } },
						envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: 0.98 }, maxMipLevel: { value: 0 } },
						aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
						lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
						emissivemap: { emissiveMap: { value: null } },
						bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
						normalmap: { normalMap: { value: null }, normalScale: { value: new Ot(1, 1) } },
						displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } },
						roughnessmap: { roughnessMap: { value: null } },
						metalnessmap: { metalnessMap: { value: null } },
						gradientmap: { gradientMap: { value: null } },
						fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new mn(16777215) } },
						lights: {
							ambientLightColor: { value: [] },
							lightProbe: { value: [] },
							directionalLights: { value: [], properties: { direction: {}, color: {} } },
							directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } },
							directionalShadowMap: { value: [] },
							directionalShadowMatrix: { value: [] },
							spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } },
							spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } },
							spotShadowMap: { value: [] },
							spotShadowMatrix: { value: [] },
							pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } },
							pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } },
							pointShadowMap: { value: [] },
							pointShadowMatrix: { value: [] },
							hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } },
							rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } },
							ltc_1: { value: null },
							ltc_2: { value: null },
						},
						points: { diffuse: { value: new mn(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new zt() } },
						sprite: { diffuse: { value: new mn(16777215) }, opacity: { value: 1 }, center: { value: new Ot(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new zt() } },
					},
					xi = {
						basic: { uniforms: Qn([bi.common, bi.specularmap, bi.envmap, bi.aomap, bi.lightmap, bi.fog]), vertexShader: gi.meshbasic_vert, fragmentShader: gi.meshbasic_frag },
						lambert: { uniforms: Qn([bi.common, bi.specularmap, bi.envmap, bi.aomap, bi.lightmap, bi.emissivemap, bi.fog, bi.lights, { emissive: { value: new mn(0) } }]), vertexShader: gi.meshlambert_vert, fragmentShader: gi.meshlambert_frag },
						phong: { uniforms: Qn([bi.common, bi.specularmap, bi.envmap, bi.aomap, bi.lightmap, bi.emissivemap, bi.bumpmap, bi.normalmap, bi.displacementmap, bi.fog, bi.lights, { emissive: { value: new mn(0) }, specular: { value: new mn(1118481) }, shininess: { value: 30 } }]), vertexShader: gi.meshphong_vert, fragmentShader: gi.meshphong_frag },
						standard: { uniforms: Qn([bi.common, bi.envmap, bi.aomap, bi.lightmap, bi.emissivemap, bi.bumpmap, bi.normalmap, bi.displacementmap, bi.roughnessmap, bi.metalnessmap, bi.fog, bi.lights, { emissive: { value: new mn(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: gi.meshphysical_vert, fragmentShader: gi.meshphysical_frag },
						toon: { uniforms: Qn([bi.common, bi.aomap, bi.lightmap, bi.emissivemap, bi.bumpmap, bi.normalmap, bi.displacementmap, bi.gradientmap, bi.fog, bi.lights, { emissive: { value: new mn(0) } }]), vertexShader: gi.meshtoon_vert, fragmentShader: gi.meshtoon_frag },
						matcap: { uniforms: Qn([bi.common, bi.bumpmap, bi.normalmap, bi.displacementmap, bi.fog, { matcap: { value: null } }]), vertexShader: gi.meshmatcap_vert, fragmentShader: gi.meshmatcap_frag },
						points: { uniforms: Qn([bi.points, bi.fog]), vertexShader: gi.points_vert, fragmentShader: gi.points_frag },
						dashed: { uniforms: Qn([bi.common, bi.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: gi.linedashed_vert, fragmentShader: gi.linedashed_frag },
						depth: { uniforms: Qn([bi.common, bi.displacementmap]), vertexShader: gi.depth_vert, fragmentShader: gi.depth_frag },
						normal: { uniforms: Qn([bi.common, bi.bumpmap, bi.normalmap, bi.displacementmap, { opacity: { value: 1 } }]), vertexShader: gi.meshnormal_vert, fragmentShader: gi.meshnormal_frag },
						sprite: { uniforms: Qn([bi.sprite, bi.fog]), vertexShader: gi.sprite_vert, fragmentShader: gi.sprite_frag },
						background: { uniforms: { uvTransform: { value: new zt() }, t2D: { value: null } }, vertexShader: gi.background_vert, fragmentShader: gi.background_frag },
						cube: { uniforms: Qn([bi.envmap, { opacity: { value: 1 } }]), vertexShader: gi.cube_vert, fragmentShader: gi.cube_frag },
						equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: gi.equirect_vert, fragmentShader: gi.equirect_frag },
						distanceRGBA: { uniforms: Qn([bi.common, bi.displacementmap, { referencePosition: { value: new Xt() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: gi.distanceRGBA_vert, fragmentShader: gi.distanceRGBA_frag },
						shadow: { uniforms: Qn([bi.lights, bi.fog, { color: { value: new mn(0) }, opacity: { value: 1 } }]), vertexShader: gi.shadow_vert, fragmentShader: gi.shadow_frag },
					};
				function yi(t, e, n, i, r) {
					const a = new mn(0);
					let s,
						o,
						l = 0,
						c = null,
						u = 0,
						h = null;
					function d(t, e) {
						n.buffers.color.setClear(t.r, t.g, t.b, e, r);
					}
					return {
						getClearColor: function () {
							return a;
						},
						setClearColor: function (t, e = 1) {
							a.set(t), (l = e), d(a, l);
						},
						getClearAlpha: function () {
							return l;
						},
						setClearAlpha: function (t) {
							(l = t), d(a, l);
						},
						render: function (n, r) {
							let p = !1,
								f = !0 === r.isScene ? r.background : null;
							f && f.isTexture && (f = e.get(f));
							const m = t.xr,
								v = m.getSession && m.getSession();
							v && "additive" === v.environmentBlendMode && (f = null),
								null === f ? d(a, l) : f && f.isColor && (d(f, 1), (p = !0)),
								(t.autoClear || p) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
								f && (f.isCubeTexture || f.mapping === V)
									? (void 0 === o &&
											((o = new Yn(new Kn(1, 1, 1), new ti({ name: "BackgroundCubeMaterial", uniforms: Jn(xi.cube.uniforms), vertexShader: xi.cube.vertexShader, fragmentShader: xi.cube.fragmentShader, side: 1, depthTest: !1, depthWrite: !1, fog: !1 }))),
											o.geometry.deleteAttribute("normal"),
											o.geometry.deleteAttribute("uv"),
											(o.onBeforeRender = function (t, e, n) {
												this.matrixWorld.copyPosition(n.matrixWorld);
											}),
											Object.defineProperty(o.material, "envMap", {
												get: function () {
													return this.uniforms.envMap.value;
												},
											}),
											i.update(o)),
									  (o.material.uniforms.envMap.value = f),
									  (o.material.uniforms.flipEnvMap.value = f.isCubeTexture && !1 === f.isRenderTargetTexture ? -1 : 1),
									  (c === f && u === f.version && h === t.toneMapping) || ((o.material.needsUpdate = !0), (c = f), (u = f.version), (h = t.toneMapping)),
									  n.unshift(o, o.geometry, o.material, 0, 0, null))
									: f &&
									  f.isTexture &&
									  (void 0 === s &&
											((s = new Yn(new vi(2, 2), new ti({ name: "BackgroundMaterial", uniforms: Jn(xi.background.uniforms), vertexShader: xi.background.vertexShader, fragmentShader: xi.background.fragmentShader, side: 0, depthTest: !1, depthWrite: !1, fog: !1 }))),
											s.geometry.deleteAttribute("normal"),
											Object.defineProperty(s.material, "map", {
												get: function () {
													return this.uniforms.t2D.value;
												},
											}),
											i.update(s)),
									  (s.material.uniforms.t2D.value = f),
									  !0 === f.matrixAutoUpdate && f.updateMatrix(),
									  s.material.uniforms.uvTransform.value.copy(f.matrix),
									  (c === f && u === f.version && h === t.toneMapping) || ((s.material.needsUpdate = !0), (c = f), (u = f.version), (h = t.toneMapping)),
									  n.unshift(s, s.geometry, s.material, 0, 0, null));
						},
					};
				}
				function _i(t, e, n, i) {
					const r = t.getParameter(34921),
						a = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
						s = i.isWebGL2 || null !== a,
						o = {},
						l = d(null);
					let c = l;
					function u(e) {
						return i.isWebGL2 ? t.bindVertexArray(e) : a.bindVertexArrayOES(e);
					}
					function h(e) {
						return i.isWebGL2 ? t.deleteVertexArray(e) : a.deleteVertexArrayOES(e);
					}
					function d(t) {
						const e = [],
							n = [],
							i = [];
						for (let t = 0; t < r; t++) (e[t] = 0), (n[t] = 0), (i[t] = 0);
						return { geometry: null, program: null, wireframe: !1, newAttributes: e, enabledAttributes: n, attributeDivisors: i, object: t, attributes: {}, index: null };
					}
					function p() {
						const t = c.newAttributes;
						for (let e = 0, n = t.length; e < n; e++) t[e] = 0;
					}
					function f(t) {
						m(t, 0);
					}
					function m(n, r) {
						const a = c.newAttributes,
							s = c.enabledAttributes,
							o = c.attributeDivisors;
						if (((a[n] = 1), 0 === s[n] && (t.enableVertexAttribArray(n), (s[n] = 1)), o[n] !== r)) {
							(i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), (o[n] = r);
						}
					}
					function v() {
						const e = c.newAttributes,
							n = c.enabledAttributes;
						for (let i = 0, r = n.length; i < r; i++) n[i] !== e[i] && (t.disableVertexAttribArray(i), (n[i] = 0));
					}
					function g(e, n, r, a, s, o) {
						!0 !== i.isWebGL2 || (5124 !== r && 5125 !== r) ? t.vertexAttribPointer(e, n, r, a, s, o) : t.vertexAttribIPointer(e, n, r, s, o);
					}
					function b() {
						x(), c !== l && ((c = l), u(c.object));
					}
					function x() {
						(l.geometry = null), (l.program = null), (l.wireframe = !1);
					}
					return {
						setup: function (r, l, h, b, x) {
							let y = !1;
							if (s) {
								const e = (function (e, n, r) {
									const s = !0 === r.wireframe;
									let l = o[e.id];
									void 0 === l && ((l = {}), (o[e.id] = l));
									let c = l[n.id];
									void 0 === c && ((c = {}), (l[n.id] = c));
									let u = c[s];
									void 0 === u && ((u = d(i.isWebGL2 ? t.createVertexArray() : a.createVertexArrayOES())), (c[s] = u));
									return u;
								})(b, h, l);
								c !== e && ((c = e), u(c.object)),
									(y = (function (t, e) {
										const n = c.attributes,
											i = t.attributes;
										let r = 0;
										for (const t in i) {
											const e = n[t],
												a = i[t];
											if (void 0 === e) return !0;
											if (e.attribute !== a) return !0;
											if (e.data !== a.data) return !0;
											r++;
										}
										return c.attributesNum !== r || c.index !== e;
									})(b, x)),
									y &&
										(function (t, e) {
											const n = {},
												i = t.attributes;
											let r = 0;
											for (const t in i) {
												const e = i[t],
													a = {};
												(a.attribute = e), e.data && (a.data = e.data), (n[t] = a), r++;
											}
											(c.attributes = n), (c.attributesNum = r), (c.index = e);
										})(b, x);
							} else {
								const t = !0 === l.wireframe;
								(c.geometry === b.id && c.program === h.id && c.wireframe === t) || ((c.geometry = b.id), (c.program = h.id), (c.wireframe = t), (y = !0));
							}
							!0 === r.isInstancedMesh && (y = !0),
								null !== x && n.update(x, 34963),
								y &&
									(!(function (r, a, s, o) {
										if (!1 === i.isWebGL2 && (r.isInstancedMesh || o.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
										p();
										const l = o.attributes,
											c = s.getAttributes(),
											u = a.defaultAttributeValues;
										for (const e in c) {
											const i = c[e];
											if (i.location >= 0) {
												let a = l[e];
												if ((void 0 === a && ("instanceMatrix" === e && r.instanceMatrix && (a = r.instanceMatrix), "instanceColor" === e && r.instanceColor && (a = r.instanceColor)), void 0 !== a)) {
													const e = a.normalized,
														s = a.itemSize,
														l = n.get(a);
													if (void 0 === l) continue;
													const c = l.buffer,
														u = l.type,
														h = l.bytesPerElement;
													if (a.isInterleavedBufferAttribute) {
														const n = a.data,
															l = n.stride,
															d = a.offset;
														if (n && n.isInstancedInterleavedBuffer) {
															for (let t = 0; t < i.locationSize; t++) m(i.location + t, n.meshPerAttribute);
															!0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = n.meshPerAttribute * n.count);
														} else for (let t = 0; t < i.locationSize; t++) f(i.location + t);
														t.bindBuffer(34962, c);
														for (let t = 0; t < i.locationSize; t++) g(i.location + t, s / i.locationSize, u, e, l * h, (d + (s / i.locationSize) * t) * h);
													} else {
														if (a.isInstancedBufferAttribute) {
															for (let t = 0; t < i.locationSize; t++) m(i.location + t, a.meshPerAttribute);
															!0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = a.meshPerAttribute * a.count);
														} else for (let t = 0; t < i.locationSize; t++) f(i.location + t);
														t.bindBuffer(34962, c);
														for (let t = 0; t < i.locationSize; t++) g(i.location + t, s / i.locationSize, u, e, s * h, (s / i.locationSize) * t * h);
													}
												} else if (void 0 !== u) {
													const n = u[e];
													if (void 0 !== n)
														switch (n.length) {
															case 2:
																t.vertexAttrib2fv(i.location, n);
																break;
															case 3:
																t.vertexAttrib3fv(i.location, n);
																break;
															case 4:
																t.vertexAttrib4fv(i.location, n);
																break;
															default:
																t.vertexAttrib1fv(i.location, n);
														}
												}
											}
										}
										v();
									})(r, l, h, b),
									null !== x && t.bindBuffer(34963, n.get(x).buffer));
						},
						reset: b,
						resetDefaultState: x,
						dispose: function () {
							b();
							for (const t in o) {
								const e = o[t];
								for (const t in e) {
									const n = e[t];
									for (const t in n) h(n[t].object), delete n[t];
									delete e[t];
								}
								delete o[t];
							}
						},
						releaseStatesOfGeometry: function (t) {
							if (void 0 === o[t.id]) return;
							const e = o[t.id];
							for (const t in e) {
								const n = e[t];
								for (const t in n) h(n[t].object), delete n[t];
								delete e[t];
							}
							delete o[t.id];
						},
						releaseStatesOfProgram: function (t) {
							for (const e in o) {
								const n = o[e];
								if (void 0 === n[t.id]) continue;
								const i = n[t.id];
								for (const t in i) h(i[t].object), delete i[t];
								delete n[t.id];
							}
						},
						initAttributes: p,
						enableAttribute: f,
						disableUnusedAttributes: v,
					};
				}
				function wi(t, e, n, i) {
					const r = i.isWebGL2;
					let a;
					(this.setMode = function (t) {
						a = t;
					}),
						(this.render = function (e, i) {
							t.drawArrays(a, e, i), n.update(i, a, 1);
						}),
						(this.renderInstances = function (i, s, o) {
							if (0 === o) return;
							let l, c;
							if (r) (l = t), (c = "drawArraysInstanced");
							else if (((l = e.get("ANGLE_instanced_arrays")), (c = "drawArraysInstancedANGLE"), null === l)) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
							l[c](a, i, s, o), n.update(s, a, o);
						});
				}
				function Mi(t, e, n) {
					let i;
					function r(e) {
						if ("highp" === e) {
							if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
							e = "mediump";
						}
						return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
					}
					const a = ("undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext) || ("undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext);
					let s = void 0 !== n.precision ? n.precision : "highp";
					const o = r(s);
					o !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", o, "instead."), (s = o));
					const l = a || e.has("WEBGL_draw_buffers"),
						c = !0 === n.logarithmicDepthBuffer,
						u = t.getParameter(34930),
						h = t.getParameter(35660),
						d = t.getParameter(3379),
						p = t.getParameter(34076),
						f = t.getParameter(34921),
						m = t.getParameter(36347),
						v = t.getParameter(36348),
						g = t.getParameter(36349),
						b = h > 0,
						x = a || e.has("OES_texture_float");
					return {
						isWebGL2: a,
						drawBuffers: l,
						getMaxAnisotropy: function () {
							if (void 0 !== i) return i;
							if (!0 === e.has("EXT_texture_filter_anisotropic")) {
								const n = e.get("EXT_texture_filter_anisotropic");
								i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
							} else i = 0;
							return i;
						},
						getMaxPrecision: r,
						precision: s,
						logarithmicDepthBuffer: c,
						maxTextures: u,
						maxVertexTextures: h,
						maxTextureSize: d,
						maxCubemapSize: p,
						maxAttributes: f,
						maxVertexUniforms: m,
						maxVaryings: v,
						maxFragmentUniforms: g,
						vertexTextures: b,
						floatFragmentTextures: x,
						floatVertexTextures: b && x,
						maxSamples: a ? t.getParameter(36183) : 0,
					};
				}
				function Si(t) {
					const e = this;
					let n = null,
						i = 0,
						r = !1,
						a = !1;
					const s = new ui(),
						o = new zt(),
						l = { value: null, needsUpdate: !1 };
					function c() {
						l.value !== n && ((l.value = n), (l.needsUpdate = i > 0)), (e.numPlanes = i), (e.numIntersection = 0);
					}
					function u(t, n, i, r) {
						const a = null !== t ? t.length : 0;
						let c = null;
						if (0 !== a) {
							if (((c = l.value), !0 !== r || null === c)) {
								const e = i + 4 * a,
									r = n.matrixWorldInverse;
								o.getNormalMatrix(r), (null === c || c.length < e) && (c = new Float32Array(e));
								for (let e = 0, n = i; e !== a; ++e, n += 4) s.copy(t[e]).applyMatrix4(r, o), s.normal.toArray(c, n), (c[n + 3] = s.constant);
							}
							(l.value = c), (l.needsUpdate = !0);
						}
						return (e.numPlanes = a), (e.numIntersection = 0), c;
					}
					(this.uniform = l),
						(this.numPlanes = 0),
						(this.numIntersection = 0),
						(this.init = function (t, e, a) {
							const s = 0 !== t.length || e || 0 !== i || r;
							return (r = e), (n = u(t, a, 0)), (i = t.length), s;
						}),
						(this.beginShadows = function () {
							(a = !0), u(null);
						}),
						(this.endShadows = function () {
							(a = !1), c();
						}),
						(this.setState = function (e, s, o) {
							const h = e.clippingPlanes,
								d = e.clipIntersection,
								p = e.clipShadows,
								f = t.get(e);
							if (!r || null === h || 0 === h.length || (a && !p)) a ? u(null) : c();
							else {
								const t = a ? 0 : i,
									e = 4 * t;
								let r = f.clippingState || null;
								(l.value = r), (r = u(h, s, e, o));
								for (let t = 0; t !== e; ++t) r[t] = n[t];
								(f.clippingState = r), (this.numIntersection = d ? this.numPlanes : 0), (this.numPlanes += t);
							}
						});
				}
				function Ti(t) {
					let e = new WeakMap();
					function n(t, e) {
						return e === k ? (t.mapping = z) : e === N && (t.mapping = I), t;
					}
					function i(t) {
						const n = t.target;
						n.removeEventListener("dispose", i);
						const r = e.get(n);
						void 0 !== r && (e.delete(n), r.dispose());
					}
					return {
						get: function (r) {
							if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
								const a = r.mapping;
								if (a === k || a === N) {
									if (e.has(r)) {
										return n(e.get(r).texture, r.mapping);
									}
									{
										const a = r.image;
										if (a && a.height > 0) {
											const s = t.getRenderTarget(),
												o = new si(a.height / 2);
											return o.fromEquirectangularTexture(t, r), e.set(r, o), t.setRenderTarget(s), r.addEventListener("dispose", i), n(o.texture, r.mapping);
										}
										return null;
									}
								}
							}
							return r;
						},
						dispose: function () {
							e = new WeakMap();
						},
					};
				}
				xi.physical = {
					uniforms: Qn([
						xi.standard.uniforms,
						{
							clearcoat: { value: 0 },
							clearcoatMap: { value: null },
							clearcoatRoughness: { value: 0 },
							clearcoatRoughnessMap: { value: null },
							clearcoatNormalScale: { value: new Ot(1, 1) },
							clearcoatNormalMap: { value: null },
							sheen: { value: 0 },
							sheenTint: { value: new mn(0) },
							sheenRoughness: { value: 0 },
							transmission: { value: 0 },
							transmissionMap: { value: null },
							transmissionSamplerSize: { value: new Ot() },
							transmissionSamplerMap: { value: null },
							thickness: { value: 0 },
							thicknessMap: { value: null },
							attenuationDistance: { value: 0 },
							attenuationTint: { value: new mn(0) },
							specularIntensity: { value: 0 },
							specularIntensityMap: { value: null },
							specularTint: { value: new mn(1, 1, 1) },
							specularTintMap: { value: null },
						},
					]),
					vertexShader: gi.meshphysical_vert,
					fragmentShader: gi.meshphysical_frag,
				};
				class Ei extends ei {
					constructor(t = -1, e = 1, n = 1, i = -1, r = 0.1, a = 2e3) {
						super(), (this.type = "OrthographicCamera"), (this.zoom = 1), (this.view = null), (this.left = t), (this.right = e), (this.top = n), (this.bottom = i), (this.near = r), (this.far = a), this.updateProjectionMatrix();
					}
					copy(t, e) {
						return super.copy(t, e), (this.left = t.left), (this.right = t.right), (this.top = t.top), (this.bottom = t.bottom), (this.near = t.near), (this.far = t.far), (this.zoom = t.zoom), (this.view = null === t.view ? null : Object.assign({}, t.view)), this;
					}
					setViewOffset(t, e, n, i, r, a) {
						null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), (this.view.enabled = !0), (this.view.fullWidth = t), (this.view.fullHeight = e), (this.view.offsetX = n), (this.view.offsetY = i), (this.view.width = r), (this.view.height = a), this.updateProjectionMatrix();
					}
					clearViewOffset() {
						null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
					}
					updateProjectionMatrix() {
						const t = (this.right - this.left) / (2 * this.zoom),
							e = (this.top - this.bottom) / (2 * this.zoom),
							n = (this.right + this.left) / 2,
							i = (this.top + this.bottom) / 2;
						let r = n - t,
							a = n + t,
							s = i + e,
							o = i - e;
						if (null !== this.view && this.view.enabled) {
							const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
								e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
							(r += t * this.view.offsetX), (a = r + t * this.view.width), (s -= e * this.view.offsetY), (o = s - e * this.view.height);
						}
						this.projectionMatrix.makeOrthographic(r, a, s, o, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
					}
					toJSON(t) {
						const e = super.toJSON(t);
						return (e.object.zoom = this.zoom), (e.object.left = this.left), (e.object.right = this.right), (e.object.top = this.top), (e.object.bottom = this.bottom), (e.object.near = this.near), (e.object.far = this.far), null !== this.view && (e.object.view = Object.assign({}, this.view)), e;
					}
				}
				Ei.prototype.isOrthographicCamera = !0;
				class Ci extends ti {
					constructor(t) {
						super(t), (this.type = "RawShaderMaterial");
					}
				}
				Ci.prototype.isRawShaderMaterial = !0;
				const Pi = Math.pow(2, 8),
					Ai = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
					Li = 5 + Ai.length,
					Ri = 20,
					Di = { [ht]: 0, [dt]: 1, [ft]: 2, 3004: 3, 3005: 4, 3006: 5, [pt]: 6 },
					Oi = new Ei(),
					{ _lodPlanes: zi, _sizeLods: Ii, _sigmas: ki } = Wi(),
					Ni = new mn();
				let Vi = null;
				const Bi = (1 + Math.sqrt(5)) / 2,
					Fi = 1 / Bi,
					Ui = [new Xt(1, 1, 1), new Xt(-1, 1, 1), new Xt(1, 1, -1), new Xt(-1, 1, -1), new Xt(0, Bi, Fi), new Xt(0, Bi, -Fi), new Xt(Fi, 0, Bi), new Xt(-Fi, 0, Bi), new Xt(Bi, Fi, 0), new Xt(-Bi, Fi, 0)];
				class Hi {
					constructor(t) {
						(this._renderer = t),
							(this._pingPongRenderTarget = null),
							(this._blurMaterial = (function (t) {
								const e = new Float32Array(t),
									n = new Xt(0, 1, 0);
								return new Ci({
									name: "SphericalGaussianBlur",
									defines: { n: t },
									uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: e }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: n }, inputEncoding: { value: Di[3e3] }, outputEncoding: { value: Di[3e3] } },
									vertexShader: Zi(),
									fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${Ki()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
									blending: 0,
									depthTest: !1,
									depthWrite: !1,
								});
							})(Ri)),
							(this._equirectShader = null),
							(this._cubemapShader = null),
							this._compileMaterial(this._blurMaterial);
					}
					fromScene(t, e = 0, n = 0.1, i = 100) {
						Vi = this._renderer.getRenderTarget();
						const r = this._allocateTargets();
						return this._sceneToCubeUV(t, n, i, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r;
					}
					fromEquirectangular(t) {
						return this._fromTexture(t);
					}
					fromCubemap(t) {
						return this._fromTexture(t);
					}
					compileCubemapShader() {
						null === this._cubemapShader && ((this._cubemapShader = Yi()), this._compileMaterial(this._cubemapShader));
					}
					compileEquirectangularShader() {
						null === this._equirectShader && ((this._equirectShader = qi()), this._compileMaterial(this._equirectShader));
					}
					dispose() {
						this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
						for (let t = 0; t < zi.length; t++) zi[t].dispose();
					}
					_cleanup(t) {
						this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(Vi), (t.scissorTest = !1), Xi(t, 0, 0, t.width, t.height);
					}
					_fromTexture(t) {
						Vi = this._renderer.getRenderTarget();
						const e = this._allocateTargets(t);
						return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e;
					}
					_allocateTargets(t) {
						const e = { magFilter: G, minFilter: G, generateMipmaps: !1, type: Y, format: 1023, encoding: Gi(t) ? t.encoding : ft, depthBuffer: !1 },
							n = ji(e);
						return (n.depthBuffer = !t), (this._pingPongRenderTarget = ji(e)), n;
					}
					_compileMaterial(t) {
						const e = new Yn(zi[0], t);
						this._renderer.compile(e, Oi);
					}
					_sceneToCubeUV(t, e, n, i) {
						const r = new ni(90, 1, e, n),
							a = [1, -1, 1, 1, 1, 1],
							s = [1, 1, 1, -1, -1, -1],
							o = this._renderer,
							l = o.autoClear,
							c = o.outputEncoding,
							u = o.toneMapping;
						o.getClearColor(Ni), (o.toneMapping = 0), (o.outputEncoding = ht), (o.autoClear = !1);
						const h = new vn({ name: "PMREM.Background", side: 1, depthWrite: !1, depthTest: !1 }),
							d = new Yn(new Kn(), h);
						let p = !1;
						const f = t.background;
						f ? f.isColor && (h.color.copy(f), (t.background = null), (p = !0)) : (h.color.copy(Ni), (p = !0));
						for (let e = 0; e < 6; e++) {
							const n = e % 3;
							0 == n ? (r.up.set(0, a[e], 0), r.lookAt(s[e], 0, 0)) : 1 == n ? (r.up.set(0, 0, a[e]), r.lookAt(0, s[e], 0)) : (r.up.set(0, a[e], 0), r.lookAt(0, 0, s[e])), Xi(i, n * Pi, e > 2 ? Pi : 0, Pi, Pi), o.setRenderTarget(i), p && o.render(d, r), o.render(t, r);
						}
						d.geometry.dispose(), d.material.dispose(), (o.toneMapping = u), (o.outputEncoding = c), (o.autoClear = l), (t.background = f);
					}
					_setEncoding(t, e) {
						!0 === this._renderer.capabilities.isWebGL2 && e.format === et && e.type === Y && e.encoding === dt ? (t.value = Di[3e3]) : (t.value = Di[e.encoding]);
					}
					_textureToCubeUV(t, e) {
						const n = this._renderer;
						t.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = Yi()) : null == this._equirectShader && (this._equirectShader = qi());
						const i = t.isCubeTexture ? this._cubemapShader : this._equirectShader,
							r = new Yn(zi[0], i),
							a = i.uniforms;
						(a.envMap.value = t), t.isCubeTexture || a.texelSize.value.set(1 / t.image.width, 1 / t.image.height), this._setEncoding(a.inputEncoding, t), this._setEncoding(a.outputEncoding, e.texture), Xi(e, 0, 0, 3 * Pi, 2 * Pi), n.setRenderTarget(e), n.render(r, Oi);
					}
					_applyPMREM(t) {
						const e = this._renderer,
							n = e.autoClear;
						e.autoClear = !1;
						for (let e = 1; e < Li; e++) {
							const n = Math.sqrt(ki[e] * ki[e] - ki[e - 1] * ki[e - 1]),
								i = Ui[(e - 1) % Ui.length];
							this._blur(t, e - 1, e, n, i);
						}
						e.autoClear = n;
					}
					_blur(t, e, n, i, r) {
						const a = this._pingPongRenderTarget;
						this._halfBlur(t, a, e, n, i, "latitudinal", r), this._halfBlur(a, t, n, n, i, "longitudinal", r);
					}
					_halfBlur(t, e, n, i, r, a, s) {
						const o = this._renderer,
							l = this._blurMaterial;
						"latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!");
						const c = new Yn(zi[i], l),
							u = l.uniforms,
							h = Ii[n] - 1,
							d = isFinite(r) ? Math.PI / (2 * h) : (2 * Math.PI) / 39,
							p = r / d,
							f = isFinite(r) ? 1 + Math.floor(3 * p) : Ri;
						f > Ri && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
						const m = [];
						let v = 0;
						for (let t = 0; t < Ri; ++t) {
							const e = t / p,
								n = Math.exp((-e * e) / 2);
							m.push(n), 0 == t ? (v += n) : t < f && (v += 2 * n);
						}
						for (let t = 0; t < m.length; t++) m[t] = m[t] / v;
						(u.envMap.value = t.texture), (u.samples.value = f), (u.weights.value = m), (u.latitudinal.value = "latitudinal" === a), s && (u.poleAxis.value = s), (u.dTheta.value = d), (u.mipInt.value = 8 - n), this._setEncoding(u.inputEncoding, t.texture), this._setEncoding(u.outputEncoding, t.texture);
						const g = Ii[i];
						Xi(e, 3 * Math.max(0, Pi - 2 * g), (0 === i ? 0 : 2 * Pi) + 2 * g * (i > 4 ? i - 8 + 4 : 0), 3 * g, 2 * g), o.setRenderTarget(e), o.render(c, Oi);
					}
				}
				function Gi(t) {
					return void 0 !== t && t.type === Y && (t.encoding === ht || t.encoding === dt || t.encoding === pt);
				}
				function Wi() {
					const t = [],
						e = [],
						n = [];
					let i = 8;
					for (let r = 0; r < Li; r++) {
						const a = Math.pow(2, i);
						e.push(a);
						let s = 1 / a;
						r > 4 ? (s = Ai[r - 8 + 4 - 1]) : 0 == r && (s = 0), n.push(s);
						const o = 1 / (a - 1),
							l = -o / 2,
							c = 1 + o / 2,
							u = [l, l, c, l, c, c, l, l, c, c, l, c],
							h = 6,
							d = 6,
							p = 3,
							f = 2,
							m = 1,
							v = new Float32Array(p * d * h),
							g = new Float32Array(f * d * h),
							b = new Float32Array(m * d * h);
						for (let t = 0; t < h; t++) {
							const e = ((t % 3) * 2) / 3 - 1,
								n = t > 2 ? 0 : -1,
								i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
							v.set(i, p * d * t), g.set(u, f * d * t);
							const r = [t, t, t, t, t, t];
							b.set(r, m * d * t);
						}
						const x = new Ln();
						x.setAttribute("position", new xn(v, p)), x.setAttribute("uv", new xn(g, f)), x.setAttribute("faceIndex", new xn(b, m)), t.push(x), i > 4 && i--;
					}
					return { _lodPlanes: t, _sizeLods: e, _sigmas: n };
				}
				function ji(t) {
					const e = new Gt(3 * Pi, 3 * Pi, t);
					return (e.texture.mapping = V), (e.texture.name = "PMREM.cubeUv"), (e.scissorTest = !0), e;
				}
				function Xi(t, e, n, i, r) {
					t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);
				}
				function qi() {
					const t = new Ot(1, 1);
					return new Ci({
						name: "EquirectangularToCubeUV",
						uniforms: { envMap: { value: null }, texelSize: { value: t }, inputEncoding: { value: Di[3e3] }, outputEncoding: { value: Di[3e3] } },
						vertexShader: Zi(),
						fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${Ki()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
						blending: 0,
						depthTest: !1,
						depthWrite: !1,
					});
				}
				function Yi() {
					return new Ci({
						name: "CubemapToCubeUV",
						uniforms: { envMap: { value: null }, inputEncoding: { value: Di[3e3] }, outputEncoding: { value: Di[3e3] } },
						vertexShader: Zi(),
						fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${Ki()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
						blending: 0,
						depthTest: !1,
						depthWrite: !1,
					});
				}
				function Zi() {
					return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t";
				}
				function Ki() {
					return "\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t";
				}
				function Ji(t) {
					let e = new WeakMap(),
						n = null;
					function i(t) {
						const n = t.target;
						n.removeEventListener("dispose", i);
						const r = e.get(n);
						void 0 !== r && (e.delete(n), r.dispose());
					}
					return {
						get: function (r) {
							if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
								const a = r.mapping,
									s = a === k || a === N,
									o = a === z || a === I;
								if (s || o) {
									if (e.has(r)) return e.get(r).texture;
									{
										const a = r.image;
										if (
											(s && a && a.height > 0) ||
											(o &&
												a &&
												(function (t) {
													let e = 0;
													const n = 6;
													for (let i = 0; i < n; i++) void 0 !== t[i] && e++;
													return e === n;
												})(a))
										) {
											const a = t.getRenderTarget();
											null === n && (n = new Hi(t));
											const o = s ? n.fromEquirectangular(r) : n.fromCubemap(r);
											return e.set(r, o), t.setRenderTarget(a), r.addEventListener("dispose", i), o.texture;
										}
										return null;
									}
								}
							}
							return r;
						},
						dispose: function () {
							(e = new WeakMap()), null !== n && (n.dispose(), (n = null));
						},
					};
				}
				function Qi(t) {
					const e = {};
					function n(n) {
						if (void 0 !== e[n]) return e[n];
						let i;
						switch (n) {
							case "WEBGL_depth_texture":
								i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
								break;
							case "EXT_texture_filter_anisotropic":
								i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
								break;
							case "WEBGL_compressed_texture_s3tc":
								i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
								break;
							case "WEBGL_compressed_texture_pvrtc":
								i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
								break;
							default:
								i = t.getExtension(n);
						}
						return (e[n] = i), i;
					}
					return {
						has: function (t) {
							return null !== n(t);
						},
						init: function (t) {
							t.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("EXT_multisampled_render_to_texture");
						},
						get: function (t) {
							const e = n(t);
							return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e;
						},
					};
				}
				function $i(t, e, n, i) {
					const r = {},
						a = new WeakMap();
					function s(t) {
						const o = t.target;
						null !== o.index && e.remove(o.index);
						for (const t in o.attributes) e.remove(o.attributes[t]);
						o.removeEventListener("dispose", s), delete r[o.id];
						const l = a.get(o);
						l && (e.remove(l), a.delete(o)), i.releaseStatesOfGeometry(o), !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount, n.memory.geometries--;
					}
					function o(t) {
						const n = [],
							i = t.index,
							r = t.attributes.position;
						let s = 0;
						if (null !== i) {
							const t = i.array;
							s = i.version;
							for (let e = 0, i = t.length; e < i; e += 3) {
								const i = t[e + 0],
									r = t[e + 1],
									a = t[e + 2];
								n.push(i, r, r, a, a, i);
							}
						} else {
							const t = r.array;
							s = r.version;
							for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
								const t = e + 0,
									i = e + 1,
									r = e + 2;
								n.push(t, i, i, r, r, t);
							}
						}
						const o = new (It(n) > 65535 ? _n : yn)(n, 1);
						o.version = s;
						const l = a.get(t);
						l && e.remove(l), a.set(t, o);
					}
					return {
						get: function (t, e) {
							return !0 === r[e.id] || (e.addEventListener("dispose", s), (r[e.id] = !0), n.memory.geometries++), e;
						},
						update: function (t) {
							const n = t.attributes;
							for (const t in n) e.update(n[t], 34962);
							const i = t.morphAttributes;
							for (const t in i) {
								const n = i[t];
								for (let t = 0, i = n.length; t < i; t++) e.update(n[t], 34962);
							}
						},
						getWireframeAttribute: function (t) {
							const e = a.get(t);
							if (e) {
								const n = t.index;
								null !== n && e.version < n.version && o(t);
							} else o(t);
							return a.get(t);
						},
					};
				}
				function tr(t, e, n, i) {
					const r = i.isWebGL2;
					let a, s, o;
					(this.setMode = function (t) {
						a = t;
					}),
						(this.setIndex = function (t) {
							(s = t.type), (o = t.bytesPerElement);
						}),
						(this.render = function (e, i) {
							t.drawElements(a, i, s, e * o), n.update(i, a, 1);
						}),
						(this.renderInstances = function (i, l, c) {
							if (0 === c) return;
							let u, h;
							if (r) (u = t), (h = "drawElementsInstanced");
							else if (((u = e.get("ANGLE_instanced_arrays")), (h = "drawElementsInstancedANGLE"), null === u)) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
							u[h](a, l, s, i * o, c), n.update(l, a, c);
						});
				}
				function er(t) {
					const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
					return {
						memory: { geometries: 0, textures: 0 },
						render: e,
						programs: null,
						autoReset: !0,
						reset: function () {
							e.frame++, (e.calls = 0), (e.triangles = 0), (e.points = 0), (e.lines = 0);
						},
						update: function (t, n, i) {
							switch ((e.calls++, n)) {
								case 4:
									e.triangles += i * (t / 3);
									break;
								case 1:
									e.lines += i * (t / 2);
									break;
								case 3:
									e.lines += i * (t - 1);
									break;
								case 2:
									e.lines += i * t;
									break;
								case 0:
									e.points += i * t;
									break;
								default:
									console.error("THREE.WebGLInfo: Unknown draw mode:", n);
							}
						},
					};
				}
				class nr extends Ft {
					constructor(t = null, e = 1, n = 1, i = 1) {
						super(null), (this.image = { data: t, width: e, height: n, depth: i }), (this.magFilter = G), (this.minFilter = G), (this.wrapR = U), (this.generateMipmaps = !1), (this.flipY = !1), (this.unpackAlignment = 1), (this.needsUpdate = !0);
					}
				}
				function ir(t, e) {
					return t[0] - e[0];
				}
				function rr(t, e) {
					return Math.abs(e[1]) - Math.abs(t[1]);
				}
				function ar(t, e) {
					let n = 1;
					const i = e.isInterleavedBufferAttribute ? e.data.array : e.array;
					i instanceof Int8Array ? (n = 127) : i instanceof Int16Array ? (n = 32767) : i instanceof Int32Array ? (n = 2147483647) : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", i), t.divideScalar(n);
				}
				function sr(t, e, n) {
					const i = {},
						r = new Float32Array(8),
						a = new WeakMap(),
						s = new Xt(),
						o = [];
					for (let t = 0; t < 8; t++) o[t] = [t, 0];
					return {
						update: function (l, c, u, h) {
							const d = l.morphTargetInfluences;
							if (!0 === e.isWebGL2) {
								const i = c.morphAttributes.position.length;
								let r = a.get(c);
								if (void 0 === r || r.count !== i) {
									void 0 !== r && r.texture.dispose();
									const t = void 0 !== c.morphAttributes.normal,
										n = c.morphAttributes.position,
										o = c.morphAttributes.normal || [],
										l = !0 === t ? 2 : 1;
									let u = c.attributes.position.count * l,
										h = 1;
									u > e.maxTextureSize && ((h = Math.ceil(u / e.maxTextureSize)), (u = e.maxTextureSize));
									const d = new Float32Array(u * h * 4 * i),
										p = new nr(d, u, h, i);
									(p.format = et), (p.type = J);
									const f = 4 * l;
									for (let e = 0; e < i; e++) {
										const i = n[e],
											r = o[e],
											a = u * h * 4 * e;
										for (let e = 0; e < i.count; e++) {
											s.fromBufferAttribute(i, e), !0 === i.normalized && ar(s, i);
											const n = e * f;
											(d[a + n + 0] = s.x), (d[a + n + 1] = s.y), (d[a + n + 2] = s.z), (d[a + n + 3] = 0), !0 === t && (s.fromBufferAttribute(r, e), !0 === r.normalized && ar(s, r), (d[a + n + 4] = s.x), (d[a + n + 5] = s.y), (d[a + n + 6] = s.z), (d[a + n + 7] = 0));
										}
									}
									(r = { count: i, texture: p, size: new Ot(u, h) }), a.set(c, r);
								}
								let o = 0;
								for (let t = 0; t < d.length; t++) o += d[t];
								const l = c.morphTargetsRelative ? 1 : 1 - o;
								h.getUniforms().setValue(t, "morphTargetBaseInfluence", l), h.getUniforms().setValue(t, "morphTargetInfluences", d), h.getUniforms().setValue(t, "morphTargetsTexture", r.texture, n), h.getUniforms().setValue(t, "morphTargetsTextureSize", r.size);
							} else {
								const e = void 0 === d ? 0 : d.length;
								let n = i[c.id];
								if (void 0 === n || n.length !== e) {
									n = [];
									for (let t = 0; t < e; t++) n[t] = [t, 0];
									i[c.id] = n;
								}
								for (let t = 0; t < e; t++) {
									const e = n[t];
									(e[0] = t), (e[1] = d[t]);
								}
								n.sort(rr);
								for (let t = 0; t < 8; t++) t < e && n[t][1] ? ((o[t][0] = n[t][0]), (o[t][1] = n[t][1])) : ((o[t][0] = Number.MAX_SAFE_INTEGER), (o[t][1] = 0));
								o.sort(ir);
								const a = c.morphAttributes.position,
									s = c.morphAttributes.normal;
								let l = 0;
								for (let t = 0; t < 8; t++) {
									const e = o[t],
										n = e[0],
										i = e[1];
									n !== Number.MAX_SAFE_INTEGER && i ? (a && c.getAttribute("morphTarget" + t) !== a[n] && c.setAttribute("morphTarget" + t, a[n]), s && c.getAttribute("morphNormal" + t) !== s[n] && c.setAttribute("morphNormal" + t, s[n]), (r[t] = i), (l += i)) : (a && !0 === c.hasAttribute("morphTarget" + t) && c.deleteAttribute("morphTarget" + t), s && !0 === c.hasAttribute("morphNormal" + t) && c.deleteAttribute("morphNormal" + t), (r[t] = 0));
								}
								const u = c.morphTargetsRelative ? 1 : 1 - l;
								h.getUniforms().setValue(t, "morphTargetBaseInfluence", u), h.getUniforms().setValue(t, "morphTargetInfluences", r);
							}
						},
					};
				}
				function or(t, e, n, i) {
					let r = new WeakMap();
					function a(t) {
						const e = t.target;
						e.removeEventListener("dispose", a), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor);
					}
					return {
						update: function (t) {
							const s = i.render.frame,
								o = t.geometry,
								l = e.get(t, o);
							return r.get(l) !== s && (e.update(l), r.set(l, s)), t.isInstancedMesh && (!1 === t.hasEventListener("dispose", a) && t.addEventListener("dispose", a), n.update(t.instanceMatrix, 34962), null !== t.instanceColor && n.update(t.instanceColor, 34962)), l;
						},
						dispose: function () {
							r = new WeakMap();
						},
					};
				}
				nr.prototype.isDataTexture2DArray = !0;
				class lr extends Ft {
					constructor(t = null, e = 1, n = 1, i = 1) {
						super(null), (this.image = { data: t, width: e, height: n, depth: i }), (this.magFilter = G), (this.minFilter = G), (this.wrapR = U), (this.generateMipmaps = !1), (this.flipY = !1), (this.unpackAlignment = 1), (this.needsUpdate = !0);
					}
				}
				lr.prototype.isDataTexture3D = !0;
				const cr = new Ft(),
					ur = new nr(),
					hr = new lr(),
					dr = new ai(),
					pr = [],
					fr = [],
					mr = new Float32Array(16),
					vr = new Float32Array(9),
					gr = new Float32Array(4);
				function br(t, e, n) {
					const i = t[0];
					if (i <= 0 || i > 0) return t;
					const r = e * n;
					let a = pr[r];
					if ((void 0 === a && ((a = new Float32Array(r)), (pr[r] = a)), 0 !== e)) {
						i.toArray(a, 0);
						for (let i = 1, r = 0; i !== e; ++i) (r += n), t[i].toArray(a, r);
					}
					return a;
				}
				function xr(t, e) {
					if (t.length !== e.length) return !1;
					for (let n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1;
					return !0;
				}
				function yr(t, e) {
					for (let n = 0, i = e.length; n < i; n++) t[n] = e[n];
				}
				function _r(t, e) {
					let n = fr[e];
					void 0 === n && ((n = new Int32Array(e)), (fr[e] = n));
					for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
					return n;
				}
				function wr(t, e) {
					const n = this.cache;
					n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
				}
				function Mr(t, e) {
					const n = this.cache;
					if (void 0 !== e.x) (n[0] === e.x && n[1] === e.y) || (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
					else {
						if (xr(n, e)) return;
						t.uniform2fv(this.addr, e), yr(n, e);
					}
				}
				function Sr(t, e) {
					const n = this.cache;
					if (void 0 !== e.x) (n[0] === e.x && n[1] === e.y && n[2] === e.z) || (t.uniform3f(this.addr, e.x, e.y, e.z), (n[0] = e.x), (n[1] = e.y), (n[2] = e.z));
					else if (void 0 !== e.r) (n[0] === e.r && n[1] === e.g && n[2] === e.b) || (t.uniform3f(this.addr, e.r, e.g, e.b), (n[0] = e.r), (n[1] = e.g), (n[2] = e.b));
					else {
						if (xr(n, e)) return;
						t.uniform3fv(this.addr, e), yr(n, e);
					}
				}
				function Tr(t, e) {
					const n = this.cache;
					if (void 0 !== e.x) (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), (n[0] = e.x), (n[1] = e.y), (n[2] = e.z), (n[3] = e.w));
					else {
						if (xr(n, e)) return;
						t.uniform4fv(this.addr, e), yr(n, e);
					}
				}
				function Er(t, e) {
					const n = this.cache,
						i = e.elements;
					if (void 0 === i) {
						if (xr(n, e)) return;
						t.uniformMatrix2fv(this.addr, !1, e), yr(n, e);
					} else {
						if (xr(n, i)) return;
						gr.set(i), t.uniformMatrix2fv(this.addr, !1, gr), yr(n, i);
					}
				}
				function Cr(t, e) {
					const n = this.cache,
						i = e.elements;
					if (void 0 === i) {
						if (xr(n, e)) return;
						t.uniformMatrix3fv(this.addr, !1, e), yr(n, e);
					} else {
						if (xr(n, i)) return;
						vr.set(i), t.uniformMatrix3fv(this.addr, !1, vr), yr(n, i);
					}
				}
				function Pr(t, e) {
					const n = this.cache,
						i = e.elements;
					if (void 0 === i) {
						if (xr(n, e)) return;
						t.uniformMatrix4fv(this.addr, !1, e), yr(n, e);
					} else {
						if (xr(n, i)) return;
						mr.set(i), t.uniformMatrix4fv(this.addr, !1, mr), yr(n, i);
					}
				}
				function Ar(t, e) {
					const n = this.cache;
					n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
				}
				function Lr(t, e) {
					const n = this.cache;
					xr(n, e) || (t.uniform2iv(this.addr, e), yr(n, e));
				}
				function Rr(t, e) {
					const n = this.cache;
					xr(n, e) || (t.uniform3iv(this.addr, e), yr(n, e));
				}
				function Dr(t, e) {
					const n = this.cache;
					xr(n, e) || (t.uniform4iv(this.addr, e), yr(n, e));
				}
				function Or(t, e) {
					const n = this.cache;
					n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
				}
				function zr(t, e) {
					const n = this.cache;
					xr(n, e) || (t.uniform2uiv(this.addr, e), yr(n, e));
				}
				function Ir(t, e) {
					const n = this.cache;
					xr(n, e) || (t.uniform3uiv(this.addr, e), yr(n, e));
				}
				function kr(t, e) {
					const n = this.cache;
					xr(n, e) || (t.uniform4uiv(this.addr, e), yr(n, e));
				}
				function Nr(t, e, n) {
					const i = this.cache,
						r = n.allocateTextureUnit();
					i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)), n.safeSetTexture2D(e || cr, r);
				}
				function Vr(t, e, n) {
					const i = this.cache,
						r = n.allocateTextureUnit();
					i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)), n.setTexture3D(e || hr, r);
				}
				function Br(t, e, n) {
					const i = this.cache,
						r = n.allocateTextureUnit();
					i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)), n.safeSetTextureCube(e || dr, r);
				}
				function Fr(t, e, n) {
					const i = this.cache,
						r = n.allocateTextureUnit();
					i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)), n.setTexture2DArray(e || ur, r);
				}
				function Ur(t, e) {
					t.uniform1fv(this.addr, e);
				}
				function Hr(t, e) {
					const n = br(e, this.size, 2);
					t.uniform2fv(this.addr, n);
				}
				function Gr(t, e) {
					const n = br(e, this.size, 3);
					t.uniform3fv(this.addr, n);
				}
				function Wr(t, e) {
					const n = br(e, this.size, 4);
					t.uniform4fv(this.addr, n);
				}
				function jr(t, e) {
					const n = br(e, this.size, 4);
					t.uniformMatrix2fv(this.addr, !1, n);
				}
				function Xr(t, e) {
					const n = br(e, this.size, 9);
					t.uniformMatrix3fv(this.addr, !1, n);
				}
				function qr(t, e) {
					const n = br(e, this.size, 16);
					t.uniformMatrix4fv(this.addr, !1, n);
				}
				function Yr(t, e) {
					t.uniform1iv(this.addr, e);
				}
				function Zr(t, e) {
					t.uniform2iv(this.addr, e);
				}
				function Kr(t, e) {
					t.uniform3iv(this.addr, e);
				}
				function Jr(t, e) {
					t.uniform4iv(this.addr, e);
				}
				function Qr(t, e) {
					t.uniform1uiv(this.addr, e);
				}
				function $r(t, e) {
					t.uniform2uiv(this.addr, e);
				}
				function ta(t, e) {
					t.uniform3uiv(this.addr, e);
				}
				function ea(t, e) {
					t.uniform4uiv(this.addr, e);
				}
				function na(t, e, n) {
					const i = e.length,
						r = _r(n, i);
					t.uniform1iv(this.addr, r);
					for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || cr, r[t]);
				}
				function ia(t, e, n) {
					const i = e.length,
						r = _r(n, i);
					t.uniform1iv(this.addr, r);
					for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || dr, r[t]);
				}
				function ra(t, e, n) {
					(this.id = t),
						(this.addr = n),
						(this.cache = []),
						(this.setValue = (function (t) {
							switch (t) {
								case 5126:
									return wr;
								case 35664:
									return Mr;
								case 35665:
									return Sr;
								case 35666:
									return Tr;
								case 35674:
									return Er;
								case 35675:
									return Cr;
								case 35676:
									return Pr;
								case 5124:
								case 35670:
									return Ar;
								case 35667:
								case 35671:
									return Lr;
								case 35668:
								case 35672:
									return Rr;
								case 35669:
								case 35673:
									return Dr;
								case 5125:
									return Or;
								case 36294:
									return zr;
								case 36295:
									return Ir;
								case 36296:
									return kr;
								case 35678:
								case 36198:
								case 36298:
								case 36306:
								case 35682:
									return Nr;
								case 35679:
								case 36299:
								case 36307:
									return Vr;
								case 35680:
								case 36300:
								case 36308:
								case 36293:
									return Br;
								case 36289:
								case 36303:
								case 36311:
								case 36292:
									return Fr;
							}
						})(e.type));
				}
				function aa(t, e, n) {
					(this.id = t),
						(this.addr = n),
						(this.cache = []),
						(this.size = e.size),
						(this.setValue = (function (t) {
							switch (t) {
								case 5126:
									return Ur;
								case 35664:
									return Hr;
								case 35665:
									return Gr;
								case 35666:
									return Wr;
								case 35674:
									return jr;
								case 35675:
									return Xr;
								case 35676:
									return qr;
								case 5124:
								case 35670:
									return Yr;
								case 35667:
								case 35671:
									return Zr;
								case 35668:
								case 35672:
									return Kr;
								case 35669:
								case 35673:
									return Jr;
								case 5125:
									return Qr;
								case 36294:
									return $r;
								case 36295:
									return ta;
								case 36296:
									return ea;
								case 35678:
								case 36198:
								case 36298:
								case 36306:
								case 35682:
									return na;
								case 35680:
								case 36300:
								case 36308:
								case 36293:
									return ia;
							}
						})(e.type));
				}
				function sa(t) {
					(this.id = t), (this.seq = []), (this.map = {});
				}
				(aa.prototype.updateCache = function (t) {
					const e = this.cache;
					t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), yr(e, t);
				}),
					(sa.prototype.setValue = function (t, e, n) {
						const i = this.seq;
						for (let r = 0, a = i.length; r !== a; ++r) {
							const a = i[r];
							a.setValue(t, e[a.id], n);
						}
					});
				const oa = /(\w+)(\])?(\[|\.)?/g;
				function la(t, e) {
					t.seq.push(e), (t.map[e.id] = e);
				}
				function ca(t, e, n) {
					const i = t.name,
						r = i.length;
					for (oa.lastIndex = 0; ; ) {
						const a = oa.exec(i),
							s = oa.lastIndex;
						let o = a[1];
						const l = "]" === a[2],
							c = a[3];
						if ((l && (o |= 0), void 0 === c || ("[" === c && s + 2 === r))) {
							la(n, void 0 === c ? new ra(o, t, e) : new aa(o, t, e));
							break;
						}
						{
							let t = n.map[o];
							void 0 === t && ((t = new sa(o)), la(n, t)), (n = t);
						}
					}
				}
				function ua(t, e) {
					(this.seq = []), (this.map = {});
					const n = t.getProgramParameter(e, 35718);
					for (let i = 0; i < n; ++i) {
						const n = t.getActiveUniform(e, i);
						ca(n, t.getUniformLocation(e, n.name), this);
					}
				}
				function ha(t, e, n) {
					const i = t.createShader(e);
					return t.shaderSource(i, n), t.compileShader(i), i;
				}
				(ua.prototype.setValue = function (t, e, n, i) {
					const r = this.map[e];
					void 0 !== r && r.setValue(t, n, i);
				}),
					(ua.prototype.setOptional = function (t, e, n) {
						const i = e[n];
						void 0 !== i && this.setValue(t, n, i);
					}),
					(ua.upload = function (t, e, n, i) {
						for (let r = 0, a = e.length; r !== a; ++r) {
							const a = e[r],
								s = n[a.id];
							!1 !== s.needsUpdate && a.setValue(t, s.value, i);
						}
					}),
					(ua.seqWithValue = function (t, e) {
						const n = [];
						for (let i = 0, r = t.length; i !== r; ++i) {
							const r = t[i];
							r.id in e && n.push(r);
						}
						return n;
					});
				let da = 0;
				function pa(t) {
					switch (t) {
						case ht:
							return ["Linear", "( value )"];
						case dt:
							return ["sRGB", "( value )"];
						case ft:
							return ["RGBE", "( value )"];
						case 3004:
							return ["RGBM", "( value, 7.0 )"];
						case 3005:
							return ["RGBM", "( value, 16.0 )"];
						case 3006:
							return ["RGBD", "( value, 256.0 )"];
						case pt:
							return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
						case 3003:
							return ["LogLuv", "( value )"];
						default:
							return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"];
					}
				}
				function fa(t, e, n) {
					const i = t.getShaderParameter(e, 35713),
						r = t.getShaderInfoLog(e).trim();
					return i && "" === r
						? ""
						: n.toUpperCase() +
								"\n\n" +
								r +
								"\n\n" +
								(function (t) {
									const e = t.split("\n");
									for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
									return e.join("\n");
								})(t.getShaderSource(e));
				}
				function ma(t, e) {
					const n = pa(e);
					return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }";
				}
				function va(t, e) {
					const n = pa(e);
					return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }";
				}
				function ga(t, e) {
					let n;
					switch (e) {
						case 1:
							n = "Linear";
							break;
						case 2:
							n = "Reinhard";
							break;
						case 3:
							n = "OptimizedCineon";
							break;
						case 4:
							n = "ACESFilmic";
							break;
						case 5:
							n = "Custom";
							break;
						default:
							console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), (n = "Linear");
					}
					return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }";
				}
				function ba(t) {
					return "" !== t;
				}
				function xa(t, e) {
					return t
						.replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
						.replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
						.replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
						.replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
						.replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
						.replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
						.replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
						.replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
				}
				function ya(t, e) {
					return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
				}
				const _a = /^[ \t]*#include +<([\w\d./]+)>/gm;
				function wa(t) {
					return t.replace(_a, Ma);
				}
				function Ma(t, e) {
					const n = gi[e];
					if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
					return wa(n);
				}
				const Sa = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
					Ta = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
				function Ea(t) {
					return t.replace(Ta, Pa).replace(Sa, Ca);
				}
				function Ca(t, e, n, i) {
					return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Pa(t, e, n, i);
				}
				function Pa(t, e, n, i) {
					let r = "";
					for (let t = parseInt(e); t < parseInt(n); t++) r += i.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
					return r;
				}
				function Aa(t) {
					let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
					return "highp" === t.precision ? (e += "\n#define HIGH_PRECISION") : "mediump" === t.precision ? (e += "\n#define MEDIUM_PRECISION") : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e;
				}
				function La(t, e, n, i) {
					const r = t.getContext(),
						a = n.defines;
					let s = n.vertexShader,
						o = n.fragmentShader;
					const l = (function (t) {
							let e = "SHADOWMAP_TYPE_BASIC";
							return 1 === t.shadowMapType ? (e = "SHADOWMAP_TYPE_PCF") : 2 === t.shadowMapType ? (e = "SHADOWMAP_TYPE_PCF_SOFT") : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e;
						})(n),
						c = (function (t) {
							let e = "ENVMAP_TYPE_CUBE";
							if (t.envMap)
								switch (t.envMapMode) {
									case z:
									case I:
										e = "ENVMAP_TYPE_CUBE";
										break;
									case V:
									case B:
										e = "ENVMAP_TYPE_CUBE_UV";
								}
							return e;
						})(n),
						u = (function (t) {
							let e = "ENVMAP_MODE_REFLECTION";
							if (t.envMap)
								switch (t.envMapMode) {
									case I:
									case B:
										e = "ENVMAP_MODE_REFRACTION";
								}
							return e;
						})(n),
						h = (function (t) {
							let e = "ENVMAP_BLENDING_NONE";
							if (t.envMap)
								switch (t.combine) {
									case 0:
										e = "ENVMAP_BLENDING_MULTIPLY";
										break;
									case 1:
										e = "ENVMAP_BLENDING_MIX";
										break;
									case 2:
										e = "ENVMAP_BLENDING_ADD";
								}
							return e;
						})(n),
						d = t.gammaFactor > 0 ? t.gammaFactor : 1,
						p = n.isWebGL2
							? ""
							: (function (t) {
									return [
										t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "",
										(t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
										t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
										(t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : "",
									]
										.filter(ba)
										.join("\n");
							  })(n),
						f = (function (t) {
							const e = [];
							for (const n in t) {
								const i = t[n];
								!1 !== i && e.push("#define " + n + " " + i);
							}
							return e.join("\n");
						})(a),
						m = r.createProgram();
					let v,
						g,
						b = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
					n.isRawShaderMaterial
						? ((v = [f].filter(ba).join("\n")), v.length > 0 && (v += "\n"), (g = [p, f].filter(ba).join("\n")), g.length > 0 && (g += "\n"))
						: ((v = [
								Aa(n),
								"#define SHADER_NAME " + n.shaderName,
								f,
								n.instancing ? "#define USE_INSTANCING" : "",
								n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
								n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
								"#define GAMMA_FACTOR " + d,
								"#define MAX_BONES " + n.maxBones,
								n.useFog && n.fog ? "#define USE_FOG" : "",
								n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
								n.map ? "#define USE_MAP" : "",
								n.envMap ? "#define USE_ENVMAP" : "",
								n.envMap ? "#define " + u : "",
								n.lightMap ? "#define USE_LIGHTMAP" : "",
								n.aoMap ? "#define USE_AOMAP" : "",
								n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
								n.bumpMap ? "#define USE_BUMPMAP" : "",
								n.normalMap ? "#define USE_NORMALMAP" : "",
								n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
								n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
								n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
								n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
								n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
								n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
								n.specularMap ? "#define USE_SPECULARMAP" : "",
								n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
								n.specularTintMap ? "#define USE_SPECULARTINTMAP" : "",
								n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
								n.metalnessMap ? "#define USE_METALNESSMAP" : "",
								n.alphaMap ? "#define USE_ALPHAMAP" : "",
								n.transmission ? "#define USE_TRANSMISSION" : "",
								n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
								n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
								n.vertexTangents ? "#define USE_TANGENT" : "",
								n.vertexColors ? "#define USE_COLOR" : "",
								n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
								n.vertexUvs ? "#define USE_UV" : "",
								n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
								n.flatShading ? "#define FLAT_SHADED" : "",
								n.skinning ? "#define USE_SKINNING" : "",
								n.useVertexTexture ? "#define BONE_TEXTURE" : "",
								n.morphTargets ? "#define USE_MORPHTARGETS" : "",
								n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "",
								n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
								n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "",
								n.doubleSided ? "#define DOUBLE_SIDED" : "",
								n.flipSided ? "#define FLIP_SIDED" : "",
								n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
								n.shadowMapEnabled ? "#define " + l : "",
								n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
								n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
								n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
								"uniform mat4 modelMatrix;",
								"uniform mat4 modelViewMatrix;",
								"uniform mat4 projectionMatrix;",
								"uniform mat4 viewMatrix;",
								"uniform mat3 normalMatrix;",
								"uniform vec3 cameraPosition;",
								"uniform bool isOrthographic;",
								"#ifdef USE_INSTANCING",
								"\tattribute mat4 instanceMatrix;",
								"#endif",
								"#ifdef USE_INSTANCING_COLOR",
								"\tattribute vec3 instanceColor;",
								"#endif",
								"attribute vec3 position;",
								"attribute vec3 normal;",
								"attribute vec2 uv;",
								"#ifdef USE_TANGENT",
								"\tattribute vec4 tangent;",
								"#endif",
								"#if defined( USE_COLOR_ALPHA )",
								"\tattribute vec4 color;",
								"#elif defined( USE_COLOR )",
								"\tattribute vec3 color;",
								"#endif",
								"#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
								"\tattribute vec3 morphTarget0;",
								"\tattribute vec3 morphTarget1;",
								"\tattribute vec3 morphTarget2;",
								"\tattribute vec3 morphTarget3;",
								"\t#ifdef USE_MORPHNORMALS",
								"\t\tattribute vec3 morphNormal0;",
								"\t\tattribute vec3 morphNormal1;",
								"\t\tattribute vec3 morphNormal2;",
								"\t\tattribute vec3 morphNormal3;",
								"\t#else",
								"\t\tattribute vec3 morphTarget4;",
								"\t\tattribute vec3 morphTarget5;",
								"\t\tattribute vec3 morphTarget6;",
								"\t\tattribute vec3 morphTarget7;",
								"\t#endif",
								"#endif",
								"#ifdef USE_SKINNING",
								"\tattribute vec4 skinIndex;",
								"\tattribute vec4 skinWeight;",
								"#endif",
								"\n",
						  ]
								.filter(ba)
								.join("\n")),
						  (g = [
								p,
								Aa(n),
								"#define SHADER_NAME " + n.shaderName,
								f,
								"#define GAMMA_FACTOR " + d,
								n.useFog && n.fog ? "#define USE_FOG" : "",
								n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
								n.map ? "#define USE_MAP" : "",
								n.matcap ? "#define USE_MATCAP" : "",
								n.envMap ? "#define USE_ENVMAP" : "",
								n.envMap ? "#define " + c : "",
								n.envMap ? "#define " + u : "",
								n.envMap ? "#define " + h : "",
								n.lightMap ? "#define USE_LIGHTMAP" : "",
								n.aoMap ? "#define USE_AOMAP" : "",
								n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
								n.bumpMap ? "#define USE_BUMPMAP" : "",
								n.normalMap ? "#define USE_NORMALMAP" : "",
								n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
								n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
								n.clearcoat ? "#define USE_CLEARCOAT" : "",
								n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
								n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
								n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
								n.specularMap ? "#define USE_SPECULARMAP" : "",
								n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
								n.specularTintMap ? "#define USE_SPECULARTINTMAP" : "",
								n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
								n.metalnessMap ? "#define USE_METALNESSMAP" : "",
								n.alphaMap ? "#define USE_ALPHAMAP" : "",
								n.alphaTest ? "#define USE_ALPHATEST" : "",
								n.sheen ? "#define USE_SHEEN" : "",
								n.transmission ? "#define USE_TRANSMISSION" : "",
								n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
								n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
								n.vertexTangents ? "#define USE_TANGENT" : "",
								n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
								n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
								n.vertexUvs ? "#define USE_UV" : "",
								n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
								n.gradientMap ? "#define USE_GRADIENTMAP" : "",
								n.flatShading ? "#define FLAT_SHADED" : "",
								n.doubleSided ? "#define DOUBLE_SIDED" : "",
								n.flipSided ? "#define FLIP_SIDED" : "",
								n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
								n.shadowMapEnabled ? "#define " + l : "",
								n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
								n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
								n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
								n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
								(n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
								"uniform mat4 viewMatrix;",
								"uniform vec3 cameraPosition;",
								"uniform bool isOrthographic;",
								0 !== n.toneMapping ? "#define TONE_MAPPING" : "",
								0 !== n.toneMapping ? gi.tonemapping_pars_fragment : "",
								0 !== n.toneMapping ? ga("toneMapping", n.toneMapping) : "",
								n.dithering ? "#define DITHERING" : "",
								n.format === tt ? "#define OPAQUE" : "",
								gi.encodings_pars_fragment,
								n.map ? ma("mapTexelToLinear", n.mapEncoding) : "",
								n.matcap ? ma("matcapTexelToLinear", n.matcapEncoding) : "",
								n.envMap ? ma("envMapTexelToLinear", n.envMapEncoding) : "",
								n.emissiveMap ? ma("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "",
								n.specularTintMap ? ma("specularTintMapTexelToLinear", n.specularTintMapEncoding) : "",
								n.lightMap ? ma("lightMapTexelToLinear", n.lightMapEncoding) : "",
								va("linearToOutputTexel", n.outputEncoding),
								n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
								"\n",
						  ]
								.filter(ba)
								.join("\n"))),
						(s = wa(s)),
						(s = xa(s, n)),
						(s = ya(s, n)),
						(o = wa(o)),
						(o = xa(o, n)),
						(o = ya(o, n)),
						(s = Ea(s)),
						(o = Ea(o)),
						n.isWebGL2 &&
							!0 !== n.isRawShaderMaterial &&
							((b = "#version 300 es\n"),
							(v = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + v),
							(g =
								[
									"#define varying in",
									n.glslVersion === bt ? "" : "out highp vec4 pc_fragColor;",
									n.glslVersion === bt ? "" : "#define gl_FragColor pc_fragColor",
									"#define gl_FragDepthEXT gl_FragDepth",
									"#define texture2D texture",
									"#define textureCube texture",
									"#define texture2DProj textureProj",
									"#define texture2DLodEXT textureLod",
									"#define texture2DProjLodEXT textureProjLod",
									"#define textureCubeLodEXT textureLod",
									"#define texture2DGradEXT textureGrad",
									"#define texture2DProjGradEXT textureProjGrad",
									"#define textureCubeGradEXT textureGrad",
								].join("\n") +
								"\n" +
								g));
					const x = b + g + o,
						y = ha(r, 35633, b + v + s),
						_ = ha(r, 35632, x);
					if ((r.attachShader(m, y), r.attachShader(m, _), void 0 !== n.index0AttributeName ? r.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"), r.linkProgram(m), t.debug.checkShaderErrors)) {
						const t = r.getProgramInfoLog(m).trim(),
							e = r.getShaderInfoLog(y).trim(),
							n = r.getShaderInfoLog(_).trim();
						let i = !0,
							a = !0;
						if (!1 === r.getProgramParameter(m, 35714)) {
							i = !1;
							const e = fa(r, y, "vertex"),
								n = fa(r, _, "fragment");
							console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(m, 35715) + "\n\nProgram Info Log: " + t + "\n" + e + "\n" + n);
						} else "" !== t ? console.warn("THREE.WebGLProgram: Program Info Log:", t) : ("" !== e && "" !== n) || (a = !1);
						a && (this.diagnostics = { runnable: i, programLog: t, vertexShader: { log: e, prefix: v }, fragmentShader: { log: n, prefix: g } });
					}
					let w, M;
					return (
						r.deleteShader(y),
						r.deleteShader(_),
						(this.getUniforms = function () {
							return void 0 === w && (w = new ua(r, m)), w;
						}),
						(this.getAttributes = function () {
							return (
								void 0 === M &&
									(M = (function (t, e) {
										const n = {},
											i = t.getProgramParameter(e, 35721);
										for (let r = 0; r < i; r++) {
											const i = t.getActiveAttrib(e, r),
												a = i.name;
											let s = 1;
											35674 === i.type && (s = 2), 35675 === i.type && (s = 3), 35676 === i.type && (s = 4), (n[a] = { type: i.type, location: t.getAttribLocation(e, a), locationSize: s });
										}
										return n;
									})(r, m)),
								M
							);
						}),
						(this.destroy = function () {
							i.releaseStatesOfProgram(this), r.deleteProgram(m), (this.program = void 0);
						}),
						(this.name = n.shaderName),
						(this.id = da++),
						(this.cacheKey = e),
						(this.usedTimes = 1),
						(this.program = m),
						(this.vertexShader = y),
						(this.fragmentShader = _),
						this
					);
				}
				function Ra(t, e, n, i, r, a, s) {
					const o = [],
						l = r.isWebGL2,
						c = r.logarithmicDepthBuffer,
						u = r.floatVertexTextures,
						h = r.maxVertexUniforms,
						d = r.vertexTextures;
					let p = r.precision;
					const f = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" },
						m = [
							"precision",
							"isWebGL2",
							"supportsVertexTextures",
							"outputEncoding",
							"instancing",
							"instancingColor",
							"map",
							"mapEncoding",
							"matcap",
							"matcapEncoding",
							"envMap",
							"envMapMode",
							"envMapEncoding",
							"envMapCubeUV",
							"lightMap",
							"lightMapEncoding",
							"aoMap",
							"emissiveMap",
							"emissiveMapEncoding",
							"bumpMap",
							"normalMap",
							"objectSpaceNormalMap",
							"tangentSpaceNormalMap",
							"clearcoat",
							"clearcoatMap",
							"clearcoatRoughnessMap",
							"clearcoatNormalMap",
							"displacementMap",
							"specularMap",
							"specularIntensityMap",
							"specularTintMap",
							"specularTintMapEncoding",
							"roughnessMap",
							"metalnessMap",
							"gradientMap",
							"alphaMap",
							"alphaTest",
							"combine",
							"vertexColors",
							"vertexAlphas",
							"vertexTangents",
							"vertexUvs",
							"uvsVertexOnly",
							"fog",
							"useFog",
							"fogExp2",
							"flatShading",
							"sizeAttenuation",
							"logarithmicDepthBuffer",
							"skinning",
							"maxBones",
							"useVertexTexture",
							"morphTargets",
							"morphNormals",
							"morphTargetsCount",
							"premultipliedAlpha",
							"numDirLights",
							"numPointLights",
							"numSpotLights",
							"numHemiLights",
							"numRectAreaLights",
							"numDirLightShadows",
							"numPointLightShadows",
							"numSpotLightShadows",
							"shadowMapEnabled",
							"shadowMapType",
							"toneMapping",
							"physicallyCorrectLights",
							"doubleSided",
							"flipSided",
							"numClippingPlanes",
							"numClipIntersection",
							"depthPacking",
							"dithering",
							"format",
							"sheen",
							"transmission",
							"transmissionMap",
							"thicknessMap",
						];
					function v(t) {
						let e;
						return t && t.isTexture ? (e = t.encoding) : t && t.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), (e = t.texture.encoding)) : (e = ht), l && t && t.isTexture && t.format === et && t.type === Y && t.encoding === dt && (e = ht), e;
					}
					return {
						getParameters: function (a, o, m, g, b) {
							const x = g.fog,
								y = a.isMeshStandardMaterial ? g.environment : null,
								_ = (a.isMeshStandardMaterial ? n : e).get(a.envMap || y),
								w = f[a.type],
								M = b.isSkinnedMesh
									? (function (t) {
											const e = t.skeleton.bones;
											if (u) return 1024;
											{
												const t = h,
													n = Math.floor((t - 20) / 4),
													i = Math.min(n, e.length);
												return i < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + i + "."), 0) : i;
											}
									  })(b)
									: 0;
							let S, T;
							if ((null !== a.precision && ((p = r.getMaxPrecision(a.precision)), p !== a.precision && console.warn("THREE.WebGLProgram.getParameters:", a.precision, "not supported, using", p, "instead.")), w)) {
								const t = xi[w];
								(S = t.vertexShader), (T = t.fragmentShader);
							} else (S = a.vertexShader), (T = a.fragmentShader);
							const E = t.getRenderTarget(),
								C = a.alphaTest > 0,
								P = a.clearcoat > 0;
							return {
								isWebGL2: l,
								shaderID: w,
								shaderName: a.type,
								vertexShader: S,
								fragmentShader: T,
								defines: a.defines,
								isRawShaderMaterial: !0 === a.isRawShaderMaterial,
								glslVersion: a.glslVersion,
								precision: p,
								instancing: !0 === b.isInstancedMesh,
								instancingColor: !0 === b.isInstancedMesh && null !== b.instanceColor,
								supportsVertexTextures: d,
								outputEncoding: null !== E ? v(E.texture) : t.outputEncoding,
								map: !!a.map,
								mapEncoding: v(a.map),
								matcap: !!a.matcap,
								matcapEncoding: v(a.matcap),
								envMap: !!_,
								envMapMode: _ && _.mapping,
								envMapEncoding: v(_),
								envMapCubeUV: !!_ && (_.mapping === V || _.mapping === B),
								lightMap: !!a.lightMap,
								lightMapEncoding: v(a.lightMap),
								aoMap: !!a.aoMap,
								emissiveMap: !!a.emissiveMap,
								emissiveMapEncoding: v(a.emissiveMap),
								bumpMap: !!a.bumpMap,
								normalMap: !!a.normalMap,
								objectSpaceNormalMap: 1 === a.normalMapType,
								tangentSpaceNormalMap: 0 === a.normalMapType,
								clearcoat: P,
								clearcoatMap: P && !!a.clearcoatMap,
								clearcoatRoughnessMap: P && !!a.clearcoatRoughnessMap,
								clearcoatNormalMap: P && !!a.clearcoatNormalMap,
								displacementMap: !!a.displacementMap,
								roughnessMap: !!a.roughnessMap,
								metalnessMap: !!a.metalnessMap,
								specularMap: !!a.specularMap,
								specularIntensityMap: !!a.specularIntensityMap,
								specularTintMap: !!a.specularTintMap,
								specularTintMapEncoding: v(a.specularTintMap),
								alphaMap: !!a.alphaMap,
								alphaTest: C,
								gradientMap: !!a.gradientMap,
								sheen: a.sheen > 0,
								transmission: a.transmission > 0,
								transmissionMap: !!a.transmissionMap,
								thicknessMap: !!a.thicknessMap,
								combine: a.combine,
								vertexTangents: !!a.normalMap && !!b.geometry && !!b.geometry.attributes.tangent,
								vertexColors: a.vertexColors,
								vertexAlphas: !0 === a.vertexColors && !!b.geometry && !!b.geometry.attributes.color && 4 === b.geometry.attributes.color.itemSize,
								vertexUvs: !!(a.map || a.bumpMap || a.normalMap || a.specularMap || a.alphaMap || a.emissiveMap || a.roughnessMap || a.metalnessMap || a.clearcoatMap || a.clearcoatRoughnessMap || a.clearcoatNormalMap || a.displacementMap || a.transmissionMap || a.thicknessMap || a.specularIntensityMap || a.specularTintMap),
								uvsVertexOnly: !(a.map || a.bumpMap || a.normalMap || a.specularMap || a.alphaMap || a.emissiveMap || a.roughnessMap || a.metalnessMap || a.clearcoatNormalMap || a.transmission > 0 || a.transmissionMap || a.thicknessMap || a.specularIntensityMap || a.specularTintMap || !a.displacementMap),
								fog: !!x,
								useFog: a.fog,
								fogExp2: x && x.isFogExp2,
								flatShading: !!a.flatShading,
								sizeAttenuation: a.sizeAttenuation,
								logarithmicDepthBuffer: c,
								skinning: !0 === b.isSkinnedMesh && M > 0,
								maxBones: M,
								useVertexTexture: u,
								morphTargets: !!b.geometry && !!b.geometry.morphAttributes.position,
								morphNormals: !!b.geometry && !!b.geometry.morphAttributes.normal,
								morphTargetsCount: b.geometry && b.geometry.morphAttributes.position ? b.geometry.morphAttributes.position.length : 0,
								numDirLights: o.directional.length,
								numPointLights: o.point.length,
								numSpotLights: o.spot.length,
								numRectAreaLights: o.rectArea.length,
								numHemiLights: o.hemi.length,
								numDirLightShadows: o.directionalShadowMap.length,
								numPointLightShadows: o.pointShadowMap.length,
								numSpotLightShadows: o.spotShadowMap.length,
								numClippingPlanes: s.numPlanes,
								numClipIntersection: s.numIntersection,
								format: a.format,
								dithering: a.dithering,
								shadowMapEnabled: t.shadowMap.enabled && m.length > 0,
								shadowMapType: t.shadowMap.type,
								toneMapping: a.toneMapped ? t.toneMapping : 0,
								physicallyCorrectLights: t.physicallyCorrectLights,
								premultipliedAlpha: a.premultipliedAlpha,
								doubleSided: 2 === a.side,
								flipSided: 1 === a.side,
								depthPacking: void 0 !== a.depthPacking && a.depthPacking,
								index0AttributeName: a.index0AttributeName,
								extensionDerivatives: a.extensions && a.extensions.derivatives,
								extensionFragDepth: a.extensions && a.extensions.fragDepth,
								extensionDrawBuffers: a.extensions && a.extensions.drawBuffers,
								extensionShaderTextureLOD: a.extensions && a.extensions.shaderTextureLOD,
								rendererExtensionFragDepth: l || i.has("EXT_frag_depth"),
								rendererExtensionDrawBuffers: l || i.has("WEBGL_draw_buffers"),
								rendererExtensionShaderTextureLod: l || i.has("EXT_shader_texture_lod"),
								customProgramCacheKey: a.customProgramCacheKey(),
							};
						},
						getProgramCacheKey: function (e) {
							const n = [];
							if ((e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines)) for (const t in e.defines) n.push(t), n.push(e.defines[t]);
							if (!1 === e.isRawShaderMaterial) {
								for (let t = 0; t < m.length; t++) n.push(e[m[t]]);
								n.push(t.outputEncoding), n.push(t.gammaFactor);
							}
							return n.push(e.customProgramCacheKey), n.join();
						},
						getUniforms: function (t) {
							const e = f[t.type];
							let n;
							if (e) {
								const t = xi[e];
								n = $n.clone(t.uniforms);
							} else n = t.uniforms;
							return n;
						},
						acquireProgram: function (e, n) {
							let i;
							for (let t = 0, e = o.length; t < e; t++) {
								const e = o[t];
								if (e.cacheKey === n) {
									(i = e), ++i.usedTimes;
									break;
								}
							}
							return void 0 === i && ((i = new La(t, n, e, a)), o.push(i)), i;
						},
						releaseProgram: function (t) {
							if (0 == --t.usedTimes) {
								const e = o.indexOf(t);
								(o[e] = o[o.length - 1]), o.pop(), t.destroy();
							}
						},
						programs: o,
					};
				}
				function Da() {
					let t = new WeakMap();
					return {
						get: function (e) {
							let n = t.get(e);
							return void 0 === n && ((n = {}), t.set(e, n)), n;
						},
						remove: function (e) {
							t.delete(e);
						},
						update: function (e, n, i) {
							t.get(e)[n] = i;
						},
						dispose: function () {
							t = new WeakMap();
						},
					};
				}
				function Oa(t, e) {
					return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id;
				}
				function za(t, e) {
					return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id;
				}
				function Ia(t) {
					const e = [];
					let n = 0;
					const i = [],
						r = [],
						a = [],
						s = { id: -1 };
					function o(i, r, a, o, l, c) {
						let u = e[n];
						const h = t.get(a);
						return void 0 === u ? ((u = { id: i.id, object: i, geometry: r, material: a, program: h.program || s, groupOrder: o, renderOrder: i.renderOrder, z: l, group: c }), (e[n] = u)) : ((u.id = i.id), (u.object = i), (u.geometry = r), (u.material = a), (u.program = h.program || s), (u.groupOrder = o), (u.renderOrder = i.renderOrder), (u.z = l), (u.group = c)), n++, u;
					}
					return {
						opaque: i,
						transmissive: r,
						transparent: a,
						init: function () {
							(n = 0), (i.length = 0), (r.length = 0), (a.length = 0);
						},
						push: function (t, e, n, s, l, c) {
							const u = o(t, e, n, s, l, c);
							n.transmission > 0 ? r.push(u) : !0 === n.transparent ? a.push(u) : i.push(u);
						},
						unshift: function (t, e, n, s, l, c) {
							const u = o(t, e, n, s, l, c);
							n.transmission > 0 ? r.unshift(u) : !0 === n.transparent ? a.unshift(u) : i.unshift(u);
						},
						finish: function () {
							for (let t = n, i = e.length; t < i; t++) {
								const n = e[t];
								if (null === n.id) break;
								(n.id = null), (n.object = null), (n.geometry = null), (n.material = null), (n.program = null), (n.group = null);
							}
						},
						sort: function (t, e) {
							i.length > 1 && i.sort(t || Oa), r.length > 1 && r.sort(e || za), a.length > 1 && a.sort(e || za);
						},
					};
				}
				function ka(t) {
					let e = new WeakMap();
					return {
						get: function (n, i) {
							let r;
							return !1 === e.has(n) ? ((r = new Ia(t)), e.set(n, [r])) : i >= e.get(n).length ? ((r = new Ia(t)), e.get(n).push(r)) : (r = e.get(n)[i]), r;
						},
						dispose: function () {
							e = new WeakMap();
						},
					};
				}
				function Na() {
					const t = {};
					return {
						get: function (e) {
							if (void 0 !== t[e.id]) return t[e.id];
							let n;
							switch (e.type) {
								case "DirectionalLight":
									n = { direction: new Xt(), color: new mn() };
									break;
								case "SpotLight":
									n = { position: new Xt(), direction: new Xt(), color: new mn(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
									break;
								case "PointLight":
									n = { position: new Xt(), color: new mn(), distance: 0, decay: 0 };
									break;
								case "HemisphereLight":
									n = { direction: new Xt(), skyColor: new mn(), groundColor: new mn() };
									break;
								case "RectAreaLight":
									n = { color: new mn(), position: new Xt(), halfWidth: new Xt(), halfHeight: new Xt() };
							}
							return (t[e.id] = n), n;
						},
					};
				}
				let Va = 0;
				function Ba(t, e) {
					return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
				}
				function Fa(t, e) {
					const n = new Na(),
						i = (function () {
							const t = {};
							return {
								get: function (e) {
									if (void 0 !== t[e.id]) return t[e.id];
									let n;
									switch (e.type) {
										case "DirectionalLight":
										case "SpotLight":
											n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Ot() };
											break;
										case "PointLight":
											n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Ot(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
									}
									return (t[e.id] = n), n;
								},
							};
						})(),
						r = {
							version: 0,
							hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 },
							ambient: [0, 0, 0],
							probe: [],
							directional: [],
							directionalShadow: [],
							directionalShadowMap: [],
							directionalShadowMatrix: [],
							spot: [],
							spotShadow: [],
							spotShadowMap: [],
							spotShadowMatrix: [],
							rectArea: [],
							rectAreaLTC1: null,
							rectAreaLTC2: null,
							point: [],
							pointShadow: [],
							pointShadowMap: [],
							pointShadowMatrix: [],
							hemi: [],
						};
					for (let t = 0; t < 9; t++) r.probe.push(new Xt());
					const a = new Xt(),
						s = new Me(),
						o = new Me();
					return {
						setup: function (a, s) {
							let o = 0,
								l = 0,
								c = 0;
							for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
							let u = 0,
								h = 0,
								d = 0,
								p = 0,
								f = 0,
								m = 0,
								v = 0,
								g = 0;
							a.sort(Ba);
							const b = !0 !== s ? Math.PI : 1;
							for (let t = 0, e = a.length; t < e; t++) {
								const e = a[t],
									s = e.color,
									x = e.intensity,
									y = e.distance,
									_ = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
								if (e.isAmbientLight) (o += s.r * x * b), (l += s.g * x * b), (c += s.b * x * b);
								else if (e.isLightProbe) for (let t = 0; t < 9; t++) r.probe[t].addScaledVector(e.sh.coefficients[t], x);
								else if (e.isDirectionalLight) {
									const t = n.get(e);
									if ((t.color.copy(e.color).multiplyScalar(e.intensity * b), e.castShadow)) {
										const t = e.shadow,
											n = i.get(e);
										(n.shadowBias = t.bias), (n.shadowNormalBias = t.normalBias), (n.shadowRadius = t.radius), (n.shadowMapSize = t.mapSize), (r.directionalShadow[u] = n), (r.directionalShadowMap[u] = _), (r.directionalShadowMatrix[u] = e.shadow.matrix), m++;
									}
									(r.directional[u] = t), u++;
								} else if (e.isSpotLight) {
									const t = n.get(e);
									if ((t.position.setFromMatrixPosition(e.matrixWorld), t.color.copy(s).multiplyScalar(x * b), (t.distance = y), (t.coneCos = Math.cos(e.angle)), (t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra))), (t.decay = e.decay), e.castShadow)) {
										const t = e.shadow,
											n = i.get(e);
										(n.shadowBias = t.bias), (n.shadowNormalBias = t.normalBias), (n.shadowRadius = t.radius), (n.shadowMapSize = t.mapSize), (r.spotShadow[d] = n), (r.spotShadowMap[d] = _), (r.spotShadowMatrix[d] = e.shadow.matrix), g++;
									}
									(r.spot[d] = t), d++;
								} else if (e.isRectAreaLight) {
									const t = n.get(e);
									t.color.copy(s).multiplyScalar(x), t.halfWidth.set(0.5 * e.width, 0, 0), t.halfHeight.set(0, 0.5 * e.height, 0), (r.rectArea[p] = t), p++;
								} else if (e.isPointLight) {
									const t = n.get(e);
									if ((t.color.copy(e.color).multiplyScalar(e.intensity * b), (t.distance = e.distance), (t.decay = e.decay), e.castShadow)) {
										const t = e.shadow,
											n = i.get(e);
										(n.shadowBias = t.bias), (n.shadowNormalBias = t.normalBias), (n.shadowRadius = t.radius), (n.shadowMapSize = t.mapSize), (n.shadowCameraNear = t.camera.near), (n.shadowCameraFar = t.camera.far), (r.pointShadow[h] = n), (r.pointShadowMap[h] = _), (r.pointShadowMatrix[h] = e.shadow.matrix), v++;
									}
									(r.point[h] = t), h++;
								} else if (e.isHemisphereLight) {
									const t = n.get(e);
									t.skyColor.copy(e.color).multiplyScalar(x * b), t.groundColor.copy(e.groundColor).multiplyScalar(x * b), (r.hemi[f] = t), f++;
								}
							}
							p > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? ((r.rectAreaLTC1 = bi.LTC_FLOAT_1), (r.rectAreaLTC2 = bi.LTC_FLOAT_2)) : !0 === t.has("OES_texture_half_float_linear") ? ((r.rectAreaLTC1 = bi.LTC_HALF_1), (r.rectAreaLTC2 = bi.LTC_HALF_2)) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), (r.ambient[0] = o), (r.ambient[1] = l), (r.ambient[2] = c);
							const x = r.hash;
							(x.directionalLength === u && x.pointLength === h && x.spotLength === d && x.rectAreaLength === p && x.hemiLength === f && x.numDirectionalShadows === m && x.numPointShadows === v && x.numSpotShadows === g) ||
								((r.directional.length = u),
								(r.spot.length = d),
								(r.rectArea.length = p),
								(r.point.length = h),
								(r.hemi.length = f),
								(r.directionalShadow.length = m),
								(r.directionalShadowMap.length = m),
								(r.pointShadow.length = v),
								(r.pointShadowMap.length = v),
								(r.spotShadow.length = g),
								(r.spotShadowMap.length = g),
								(r.directionalShadowMatrix.length = m),
								(r.pointShadowMatrix.length = v),
								(r.spotShadowMatrix.length = g),
								(x.directionalLength = u),
								(x.pointLength = h),
								(x.spotLength = d),
								(x.rectAreaLength = p),
								(x.hemiLength = f),
								(x.numDirectionalShadows = m),
								(x.numPointShadows = v),
								(x.numSpotShadows = g),
								(r.version = Va++));
						},
						setupView: function (t, e) {
							let n = 0,
								i = 0,
								l = 0,
								c = 0,
								u = 0;
							const h = e.matrixWorldInverse;
							for (let e = 0, d = t.length; e < d; e++) {
								const d = t[e];
								if (d.isDirectionalLight) {
									const t = r.directional[n];
									t.direction.setFromMatrixPosition(d.matrixWorld), a.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(a), t.direction.transformDirection(h), n++;
								} else if (d.isSpotLight) {
									const t = r.spot[l];
									t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(h), t.direction.setFromMatrixPosition(d.matrixWorld), a.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(a), t.direction.transformDirection(h), l++;
								} else if (d.isRectAreaLight) {
									const t = r.rectArea[c];
									t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(h), o.identity(), s.copy(d.matrixWorld), s.premultiply(h), o.extractRotation(s), t.halfWidth.set(0.5 * d.width, 0, 0), t.halfHeight.set(0, 0.5 * d.height, 0), t.halfWidth.applyMatrix4(o), t.halfHeight.applyMatrix4(o), c++;
								} else if (d.isPointLight) {
									const t = r.point[i];
									t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(h), i++;
								} else if (d.isHemisphereLight) {
									const t = r.hemi[u];
									t.direction.setFromMatrixPosition(d.matrixWorld), t.direction.transformDirection(h), t.direction.normalize(), u++;
								}
							}
						},
						state: r,
					};
				}
				function Ua(t, e) {
					const n = new Fa(t, e),
						i = [],
						r = [];
					return {
						init: function () {
							(i.length = 0), (r.length = 0);
						},
						state: { lightsArray: i, shadowsArray: r, lights: n },
						setupLights: function (t) {
							n.setup(i, t);
						},
						setupLightsView: function (t) {
							n.setupView(i, t);
						},
						pushLight: function (t) {
							i.push(t);
						},
						pushShadow: function (t) {
							r.push(t);
						},
					};
				}
				function Ha(t, e) {
					let n = new WeakMap();
					return {
						get: function (i, r = 0) {
							let a;
							return !1 === n.has(i) ? ((a = new Ua(t, e)), n.set(i, [a])) : r >= n.get(i).length ? ((a = new Ua(t, e)), n.get(i).push(a)) : (a = n.get(i)[r]), a;
						},
						dispose: function () {
							n = new WeakMap();
						},
					};
				}
				class Ga extends ln {
					constructor(t) {
						super(), (this.type = "MeshDepthMaterial"), (this.depthPacking = 3200), (this.map = null), (this.alphaMap = null), (this.displacementMap = null), (this.displacementScale = 1), (this.displacementBias = 0), (this.wireframe = !1), (this.wireframeLinewidth = 1), (this.fog = !1), this.setValues(t);
					}
					copy(t) {
						return super.copy(t), (this.depthPacking = t.depthPacking), (this.map = t.map), (this.alphaMap = t.alphaMap), (this.displacementMap = t.displacementMap), (this.displacementScale = t.displacementScale), (this.displacementBias = t.displacementBias), (this.wireframe = t.wireframe), (this.wireframeLinewidth = t.wireframeLinewidth), this;
					}
				}
				Ga.prototype.isMeshDepthMaterial = !0;
				class Wa extends ln {
					constructor(t) {
						super(), (this.type = "MeshDistanceMaterial"), (this.referencePosition = new Xt()), (this.nearDistance = 1), (this.farDistance = 1e3), (this.map = null), (this.alphaMap = null), (this.displacementMap = null), (this.displacementScale = 1), (this.displacementBias = 0), (this.fog = !1), this.setValues(t);
					}
					copy(t) {
						return super.copy(t), this.referencePosition.copy(t.referencePosition), (this.nearDistance = t.nearDistance), (this.farDistance = t.farDistance), (this.map = t.map), (this.alphaMap = t.alphaMap), (this.displacementMap = t.displacementMap), (this.displacementScale = t.displacementScale), (this.displacementBias = t.displacementBias), this;
					}
				}
				Wa.prototype.isMeshDistanceMaterial = !0;
				function ja(t, e, n) {
					let i = new pi();
					const r = new Ot(),
						a = new Ot(),
						s = new Ht(),
						o = new Ga({ depthPacking: 3201 }),
						l = new Wa(),
						c = {},
						u = n.maxTextureSize,
						h = { 0: 1, 1: 0, 2: 2 },
						d = new ti({
							uniforms: { shadow_pass: { value: null }, resolution: { value: new Ot() }, radius: { value: 4 }, samples: { value: 8 } },
							vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
							fragmentShader:
								"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\nuniform float samples;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
						}),
						p = d.clone();
					p.defines.HORIZONTAL_PASS = 1;
					const f = new Ln();
					f.setAttribute("position", new xn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
					const m = new Yn(f, d),
						v = this;
					function g(n, i) {
						const r = e.update(m);
						(d.uniforms.shadow_pass.value = n.map.texture),
							(d.uniforms.resolution.value = n.mapSize),
							(d.uniforms.radius.value = n.radius),
							(d.uniforms.samples.value = n.blurSamples),
							t.setRenderTarget(n.mapPass),
							t.clear(),
							t.renderBufferDirect(i, null, r, d, m, null),
							(p.uniforms.shadow_pass.value = n.mapPass.texture),
							(p.uniforms.resolution.value = n.mapSize),
							(p.uniforms.radius.value = n.radius),
							(p.uniforms.samples.value = n.blurSamples),
							t.setRenderTarget(n.map),
							t.clear(),
							t.renderBufferDirect(i, null, r, p, m, null);
					}
					function b(e, n, i, r, a, s, u) {
						let d = null;
						const p = !0 === r.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
						if (((d = void 0 !== p ? p : !0 === r.isPointLight ? l : o), (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) || (i.displacementMap && 0 !== i.displacementScale) || (i.alphaMap && i.alphaTest > 0))) {
							const t = d.uuid,
								e = i.uuid;
							let n = c[t];
							void 0 === n && ((n = {}), (c[t] = n));
							let r = n[e];
							void 0 === r && ((r = d.clone()), (n[e] = r)), (d = r);
						}
						return (
							(d.visible = i.visible),
							(d.wireframe = i.wireframe),
							(d.side = 3 === u ? (null !== i.shadowSide ? i.shadowSide : i.side) : null !== i.shadowSide ? i.shadowSide : h[i.side]),
							(d.alphaMap = i.alphaMap),
							(d.alphaTest = i.alphaTest),
							(d.clipShadows = i.clipShadows),
							(d.clippingPlanes = i.clippingPlanes),
							(d.clipIntersection = i.clipIntersection),
							(d.displacementMap = i.displacementMap),
							(d.displacementScale = i.displacementScale),
							(d.displacementBias = i.displacementBias),
							(d.wireframeLinewidth = i.wireframeLinewidth),
							(d.linewidth = i.linewidth),
							!0 === r.isPointLight && !0 === d.isMeshDistanceMaterial && (d.referencePosition.setFromMatrixPosition(r.matrixWorld), (d.nearDistance = a), (d.farDistance = s)),
							d
						);
					}
					function x(n, r, a, s, o) {
						if (!1 === n.visible) return;
						if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || (n.receiveShadow && 3 === o)) && (!n.frustumCulled || i.intersectsObject(n))) {
							n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, n.matrixWorld);
							const i = e.update(n),
								r = n.material;
							if (Array.isArray(r)) {
								const e = i.groups;
								for (let l = 0, c = e.length; l < c; l++) {
									const c = e[l],
										u = r[c.materialIndex];
									if (u && u.visible) {
										const e = b(n, 0, u, s, a.near, a.far, o);
										t.renderBufferDirect(a, null, i, e, n, c);
									}
								}
							} else if (r.visible) {
								const e = b(n, 0, r, s, a.near, a.far, o);
								t.renderBufferDirect(a, null, i, e, n, null);
							}
						}
						const l = n.children;
						for (let t = 0, e = l.length; t < e; t++) x(l[t], r, a, s, o);
					}
					(this.enabled = !1),
						(this.autoUpdate = !0),
						(this.needsUpdate = !1),
						(this.type = 1),
						(this.render = function (e, n, o) {
							if (!1 === v.enabled) return;
							if (!1 === v.autoUpdate && !1 === v.needsUpdate) return;
							if (0 === e.length) return;
							const l = t.getRenderTarget(),
								c = t.getActiveCubeFace(),
								h = t.getActiveMipmapLevel(),
								d = t.state;
							d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
							for (let l = 0, c = e.length; l < c; l++) {
								const c = e[l],
									h = c.shadow;
								if (void 0 === h) {
									console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
									continue;
								}
								if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue;
								r.copy(h.mapSize);
								const p = h.getFrameExtents();
								if ((r.multiply(p), a.copy(h.mapSize), (r.x > u || r.y > u) && (r.x > u && ((a.x = Math.floor(u / p.x)), (r.x = a.x * p.x), (h.mapSize.x = a.x)), r.y > u && ((a.y = Math.floor(u / p.y)), (r.y = a.y * p.y), (h.mapSize.y = a.y))), null === h.map && !h.isPointLightShadow && 3 === this.type)) {
									const t = { minFilter: X, magFilter: X, format: et };
									(h.map = new Gt(r.x, r.y, t)), (h.map.texture.name = c.name + ".shadowMap"), (h.mapPass = new Gt(r.x, r.y, t)), h.camera.updateProjectionMatrix();
								}
								if (null === h.map) {
									const t = { minFilter: G, magFilter: G, format: et };
									(h.map = new Gt(r.x, r.y, t)), (h.map.texture.name = c.name + ".shadowMap"), h.camera.updateProjectionMatrix();
								}
								t.setRenderTarget(h.map), t.clear();
								const f = h.getViewportCount();
								for (let t = 0; t < f; t++) {
									const e = h.getViewport(t);
									s.set(a.x * e.x, a.y * e.y, a.x * e.z, a.y * e.w), d.viewport(s), h.updateMatrices(c, t), (i = h.getFrustum()), x(n, o, h.camera, c, this.type);
								}
								h.isPointLightShadow || 3 !== this.type || g(h, o), (h.needsUpdate = !1);
							}
							(v.needsUpdate = !1), t.setRenderTarget(l, c, h);
						});
				}
				function Xa(t, e, n) {
					const i = n.isWebGL2;
					const r = new (function () {
							let e = !1;
							const n = new Ht();
							let i = null;
							const r = new Ht(0, 0, 0, 0);
							return {
								setMask: function (n) {
									i === n || e || (t.colorMask(n, n, n, n), (i = n));
								},
								setLocked: function (t) {
									e = t;
								},
								setClear: function (e, i, a, s, o) {
									!0 === o && ((e *= s), (i *= s), (a *= s)), n.set(e, i, a, s), !1 === r.equals(n) && (t.clearColor(e, i, a, s), r.copy(n));
								},
								reset: function () {
									(e = !1), (i = null), r.set(-1, 0, 0, 0);
								},
							};
						})(),
						a = new (function () {
							let e = !1,
								n = null,
								i = null,
								r = null;
							return {
								setTest: function (t) {
									t ? V(2929) : B(2929);
								},
								setMask: function (i) {
									n === i || e || (t.depthMask(i), (n = i));
								},
								setFunc: function (e) {
									if (i !== e) {
										if (e)
											switch (e) {
												case 0:
													t.depthFunc(512);
													break;
												case 1:
													t.depthFunc(519);
													break;
												case 2:
													t.depthFunc(513);
													break;
												case 3:
													t.depthFunc(515);
													break;
												case 4:
													t.depthFunc(514);
													break;
												case 5:
													t.depthFunc(518);
													break;
												case 6:
													t.depthFunc(516);
													break;
												case 7:
													t.depthFunc(517);
													break;
												default:
													t.depthFunc(515);
											}
										else t.depthFunc(515);
										i = e;
									}
								},
								setLocked: function (t) {
									e = t;
								},
								setClear: function (e) {
									r !== e && (t.clearDepth(e), (r = e));
								},
								reset: function () {
									(e = !1), (n = null), (i = null), (r = null);
								},
							};
						})(),
						s = new (function () {
							let e = !1,
								n = null,
								i = null,
								r = null,
								a = null,
								s = null,
								o = null,
								l = null,
								c = null;
							return {
								setTest: function (t) {
									e || (t ? V(2960) : B(2960));
								},
								setMask: function (i) {
									n === i || e || (t.stencilMask(i), (n = i));
								},
								setFunc: function (e, n, s) {
									(i === e && r === n && a === s) || (t.stencilFunc(e, n, s), (i = e), (r = n), (a = s));
								},
								setOp: function (e, n, i) {
									(s === e && o === n && l === i) || (t.stencilOp(e, n, i), (s = e), (o = n), (l = i));
								},
								setLocked: function (t) {
									e = t;
								},
								setClear: function (e) {
									c !== e && (t.clearStencil(e), (c = e));
								},
								reset: function () {
									(e = !1), (n = null), (i = null), (r = null), (a = null), (s = null), (o = null), (l = null), (c = null);
								},
							};
						})();
					let o = {},
						l = null,
						c = {},
						u = null,
						h = !1,
						d = null,
						p = null,
						f = null,
						m = null,
						v = null,
						g = null,
						b = null,
						x = !1,
						y = null,
						_ = null,
						w = null,
						M = null,
						S = null;
					const T = t.getParameter(35661);
					let E = !1,
						C = 0;
					const P = t.getParameter(7938);
					-1 !== P.indexOf("WebGL") ? ((C = parseFloat(/^WebGL (\d)/.exec(P)[1])), (E = C >= 1)) : -1 !== P.indexOf("OpenGL ES") && ((C = parseFloat(/^OpenGL ES (\d)/.exec(P)[1])), (E = C >= 2));
					let A = null,
						L = {};
					const R = t.getParameter(3088),
						D = t.getParameter(2978),
						z = new Ht().fromArray(R),
						I = new Ht().fromArray(D);
					function k(e, n, i) {
						const r = new Uint8Array(4),
							a = t.createTexture();
						t.bindTexture(e, a), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
						for (let e = 0; e < i; e++) t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
						return a;
					}
					const N = {};
					function V(e) {
						!0 !== o[e] && (t.enable(e), (o[e] = !0));
					}
					function B(e) {
						!1 !== o[e] && (t.disable(e), (o[e] = !1));
					}
					(N[3553] = k(3553, 3553, 1)), (N[34067] = k(34067, 34069, 6)), r.setClear(0, 0, 0, 1), a.setClear(1), s.setClear(0), V(2929), a.setFunc(3), G(!1), W(1), V(2884), H(0);
					const F = { [O]: 32774, 101: 32778, 102: 32779 };
					if (i) (F[103] = 32775), (F[104] = 32776);
					else {
						const t = e.get("EXT_blend_minmax");
						null !== t && ((F[103] = t.MIN_EXT), (F[104] = t.MAX_EXT));
					}
					const U = { 200: 0, 201: 1, 202: 768, 204: 770, 210: 776, 208: 774, 206: 772, 203: 769, 205: 771, 209: 775, 207: 773 };
					function H(e, n, i, r, a, s, o, l) {
						if (0 !== e) {
							if ((!1 === h && (V(3042), (h = !0)), 5 === e)) (a = a || n), (s = s || i), (o = o || r), (n === p && a === v) || (t.blendEquationSeparate(F[n], F[a]), (p = n), (v = a)), (i === f && r === m && s === g && o === b) || (t.blendFuncSeparate(U[i], U[r], U[s], U[o]), (f = i), (m = r), (g = s), (b = o)), (d = e), (x = null);
							else if (e !== d || l !== x) {
								if (((p === O && v === O) || (t.blendEquation(32774), (p = O), (v = O)), l))
									switch (e) {
										case 1:
											t.blendFuncSeparate(1, 771, 1, 771);
											break;
										case 2:
											t.blendFunc(1, 1);
											break;
										case 3:
											t.blendFuncSeparate(0, 0, 769, 771);
											break;
										case 4:
											t.blendFuncSeparate(0, 768, 0, 770);
											break;
										default:
											console.error("THREE.WebGLState: Invalid blending: ", e);
									}
								else
									switch (e) {
										case 1:
											t.blendFuncSeparate(770, 771, 1, 771);
											break;
										case 2:
											t.blendFunc(770, 1);
											break;
										case 3:
											t.blendFunc(0, 769);
											break;
										case 4:
											t.blendFunc(0, 768);
											break;
										default:
											console.error("THREE.WebGLState: Invalid blending: ", e);
									}
								(f = null), (m = null), (g = null), (b = null), (d = e), (x = l);
							}
						} else !0 === h && (B(3042), (h = !1));
					}
					function G(e) {
						y !== e && (e ? t.frontFace(2304) : t.frontFace(2305), (y = e));
					}
					function W(e) {
						0 !== e ? (V(2884), e !== _ && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : B(2884), (_ = e);
					}
					function j(e, n, i) {
						e ? (V(32823), (M === n && S === i) || (t.polygonOffset(n, i), (M = n), (S = i))) : B(32823);
					}
					function X(e) {
						void 0 === e && (e = 33984 + T - 1), A !== e && (t.activeTexture(e), (A = e));
					}
					return {
						buffers: { color: r, depth: a, stencil: s },
						enable: V,
						disable: B,
						bindFramebuffer: function (e, n) {
							return null === n && null !== l && (n = l), c[e] !== n && (t.bindFramebuffer(e, n), (c[e] = n), i && (36009 === e && (c[36160] = n), 36160 === e && (c[36009] = n)), !0);
						},
						bindXRFramebuffer: function (e) {
							e !== l && (t.bindFramebuffer(36160, e), (l = e));
						},
						useProgram: function (e) {
							return u !== e && (t.useProgram(e), (u = e), !0);
						},
						setBlending: H,
						setMaterial: function (t, e) {
							2 === t.side ? B(2884) : V(2884);
							let n = 1 === t.side;
							e && (n = !n), G(n), 1 === t.blending && !1 === t.transparent ? H(0) : H(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), a.setFunc(t.depthFunc), a.setTest(t.depthTest), a.setMask(t.depthWrite), r.setMask(t.colorWrite);
							const i = t.stencilWrite;
							s.setTest(i), i && (s.setMask(t.stencilWriteMask), s.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), s.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), j(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? V(32926) : B(32926);
						},
						setFlipSided: G,
						setCullFace: W,
						setLineWidth: function (e) {
							e !== w && (E && t.lineWidth(e), (w = e));
						},
						setPolygonOffset: j,
						setScissorTest: function (t) {
							t ? V(3089) : B(3089);
						},
						activeTexture: X,
						bindTexture: function (e, n) {
							null === A && X();
							let i = L[A];
							void 0 === i && ((i = { type: void 0, texture: void 0 }), (L[A] = i)), (i.type === e && i.texture === n) || (t.bindTexture(e, n || N[e]), (i.type = e), (i.texture = n));
						},
						unbindTexture: function () {
							const e = L[A];
							void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), (e.type = void 0), (e.texture = void 0));
						},
						compressedTexImage2D: function () {
							try {
								t.compressedTexImage2D.apply(t, arguments);
							} catch (t) {
								console.error("THREE.WebGLState:", t);
							}
						},
						texImage2D: function () {
							try {
								t.texImage2D.apply(t, arguments);
							} catch (t) {
								console.error("THREE.WebGLState:", t);
							}
						},
						texImage3D: function () {
							try {
								t.texImage3D.apply(t, arguments);
							} catch (t) {
								console.error("THREE.WebGLState:", t);
							}
						},
						scissor: function (e) {
							!1 === z.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), z.copy(e));
						},
						viewport: function (e) {
							!1 === I.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), I.copy(e));
						},
						reset: function () {
							t.disable(3042),
								t.disable(2884),
								t.disable(2929),
								t.disable(32823),
								t.disable(3089),
								t.disable(2960),
								t.disable(32926),
								t.blendEquation(32774),
								t.blendFunc(1, 0),
								t.blendFuncSeparate(1, 0, 1, 0),
								t.colorMask(!0, !0, !0, !0),
								t.clearColor(0, 0, 0, 0),
								t.depthMask(!0),
								t.depthFunc(513),
								t.clearDepth(1),
								t.stencilMask(4294967295),
								t.stencilFunc(519, 0, 4294967295),
								t.stencilOp(7680, 7680, 7680),
								t.clearStencil(0),
								t.cullFace(1029),
								t.frontFace(2305),
								t.polygonOffset(0, 0),
								t.activeTexture(33984),
								t.bindFramebuffer(36160, null),
								!0 === i && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)),
								t.useProgram(null),
								t.lineWidth(1),
								t.scissor(0, 0, t.canvas.width, t.canvas.height),
								t.viewport(0, 0, t.canvas.width, t.canvas.height),
								(o = {}),
								(A = null),
								(L = {}),
								(l = null),
								(c = {}),
								(u = null),
								(h = !1),
								(d = null),
								(p = null),
								(f = null),
								(m = null),
								(v = null),
								(g = null),
								(b = null),
								(x = !1),
								(y = null),
								(_ = null),
								(w = null),
								(M = null),
								(S = null),
								z.set(0, 0, t.canvas.width, t.canvas.height),
								I.set(0, 0, t.canvas.width, t.canvas.height),
								r.reset(),
								a.reset(),
								s.reset();
						},
					};
				}
				function qa(t, e, n, i, r, a, s) {
					const o = r.isWebGL2,
						l = r.maxTextures,
						c = r.maxCubemapSize,
						u = r.maxTextureSize,
						h = r.maxSamples,
						d = new WeakMap();
					let p,
						f = !1;
					try {
						f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d");
					} catch (t) {}
					function m(t, e) {
						return f ? new OffscreenCanvas(t, e) : kt("canvas");
					}
					function v(t, e, n, i) {
						let r = 1;
						if (((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e)) {
							if (("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement) || ("undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement) || ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)) {
								const i = e ? Rt : Math.floor,
									a = i(r * t.width),
									s = i(r * t.height);
								void 0 === p && (p = m(a, s));
								const o = n ? m(a, s) : p;
								(o.width = a), (o.height = s);
								return o.getContext("2d").drawImage(t, 0, 0, a, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + a + "x" + s + ")."), o;
							}
							return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t;
						}
						return t;
					}
					function g(t) {
						return At(t.width) && At(t.height);
					}
					function b(t, e) {
						return t.generateMipmaps && e && t.minFilter !== G && t.minFilter !== X;
					}
					function x(e, n, r, a, s = 1) {
						t.generateMipmap(e);
						i.get(n).__maxMipLevel = Math.log2(Math.max(r, a, s));
					}
					function y(n, i, r, a) {
						if (!1 === o) return i;
						if (null !== n) {
							if (void 0 !== t[n]) return t[n];
							console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'");
						}
						let s = i;
						return 6403 === i && (5126 === r && (s = 33326), 5131 === r && (s = 33325), 5121 === r && (s = 33321)), 6407 === i && (5126 === r && (s = 34837), 5131 === r && (s = 34843), 5121 === r && (s = 32849)), 6408 === i && (5126 === r && (s = 34836), 5131 === r && (s = 34842), 5121 === r && (s = a === dt ? 35907 : 32856)), (33325 !== s && 33326 !== s && 34842 !== s && 34836 !== s) || e.get("EXT_color_buffer_float"), s;
					}
					function _(t) {
						return t === G || t === W || t === j ? 9728 : 9729;
					}
					function w(e) {
						const n = e.target;
						n.removeEventListener("dispose", w),
							(function (e) {
								const n = i.get(e);
								if (void 0 === n.__webglInit) return;
								t.deleteTexture(n.__webglTexture), i.remove(e);
							})(n),
							n.isVideoTexture && d.delete(n),
							s.memory.textures--;
					}
					function M(e) {
						const n = e.target;
						n.removeEventListener("dispose", M),
							(function (e) {
								const n = e.texture,
									r = i.get(e),
									a = i.get(n);
								if (!e) return;
								void 0 !== a.__webglTexture && (t.deleteTexture(a.__webglTexture), s.memory.textures--);
								e.depthTexture && e.depthTexture.dispose();
								if (e.isWebGLCubeRenderTarget) for (let e = 0; e < 6; e++) t.deleteFramebuffer(r.__webglFramebuffer[e]), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
								else t.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer && t.deleteRenderbuffer(r.__webglColorRenderbuffer), r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
								if (e.isWebGLMultipleRenderTargets)
									for (let e = 0, r = n.length; e < r; e++) {
										const r = i.get(n[e]);
										r.__webglTexture && (t.deleteTexture(r.__webglTexture), s.memory.textures--), i.remove(n[e]);
									}
								i.remove(n), i.remove(e);
							})(n);
					}
					let S = 0;
					function T(t, e) {
						const r = i.get(t);
						if (
							(t.isVideoTexture &&
								(function (t) {
									const e = s.render.frame;
									d.get(t) !== e && (d.set(t, e), t.update());
								})(t),
							t.version > 0 && r.__version !== t.version)
						) {
							const n = t.image;
							if (void 0 === n) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
							else {
								if (!1 !== n.complete) return void R(r, t, e);
								console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
							}
						}
						n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture);
					}
					function E(e, r) {
						const s = i.get(e);
						e.version > 0 && s.__version !== e.version
							? (function (e, i, r) {
									if (6 !== i.image.length) return;
									L(e, i), n.activeTexture(33984 + r), n.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment), t.pixelStorei(37443, 0);
									const s = i && (i.isCompressedTexture || i.image[0].isCompressedTexture),
										l = i.image[0] && i.image[0].isDataTexture,
										u = [];
									for (let t = 0; t < 6; t++) u[t] = s || l ? (l ? i.image[t].image : i.image[t]) : v(i.image[t], !1, !0, c);
									const h = u[0],
										d = g(h) || o,
										p = a.convert(i.format),
										f = a.convert(i.type),
										m = y(i.internalFormat, p, f, i.encoding);
									let _;
									if ((A(34067, i, d), s)) {
										for (let t = 0; t < 6; t++) {
											_ = u[t].mipmaps;
											for (let e = 0; e < _.length; e++) {
												const r = _[e];
												i.format !== et && i.format !== tt ? (null !== p ? n.compressedTexImage2D(34069 + t, e, m, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()")) : n.texImage2D(34069 + t, e, m, r.width, r.height, 0, p, f, r.data);
											}
										}
										e.__maxMipLevel = _.length - 1;
									} else {
										_ = i.mipmaps;
										for (let t = 0; t < 6; t++)
											if (l) {
												n.texImage2D(34069 + t, 0, m, u[t].width, u[t].height, 0, p, f, u[t].data);
												for (let e = 0; e < _.length; e++) {
													const i = _[e].image[t].image;
													n.texImage2D(34069 + t, e + 1, m, i.width, i.height, 0, p, f, i.data);
												}
											} else {
												n.texImage2D(34069 + t, 0, m, p, f, u[t]);
												for (let e = 0; e < _.length; e++) {
													const i = _[e];
													n.texImage2D(34069 + t, e + 1, m, p, f, i.image[t]);
												}
											}
										e.__maxMipLevel = _.length;
									}
									b(i, d) && x(34067, i, h.width, h.height);
									(e.__version = i.version), i.onUpdate && i.onUpdate(i);
							  })(s, e, r)
							: (n.activeTexture(33984 + r), n.bindTexture(34067, s.__webglTexture));
					}
					const C = { [F]: 10497, [U]: 33071, [H]: 33648 },
						P = { [G]: 9728, [W]: 9984, [j]: 9986, [X]: 9729, 1007: 9985, [q]: 9987 };
					function A(n, a, s) {
						if (
							(s
								? (t.texParameteri(n, 10242, C[a.wrapS]), t.texParameteri(n, 10243, C[a.wrapT]), (32879 !== n && 35866 !== n) || t.texParameteri(n, 32882, C[a.wrapR]), t.texParameteri(n, 10240, P[a.magFilter]), t.texParameteri(n, 10241, P[a.minFilter]))
								: (t.texParameteri(n, 10242, 33071),
								  t.texParameteri(n, 10243, 33071),
								  (32879 !== n && 35866 !== n) || t.texParameteri(n, 32882, 33071),
								  (a.wrapS === U && a.wrapT === U) || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
								  t.texParameteri(n, 10240, _(a.magFilter)),
								  t.texParameteri(n, 10241, _(a.minFilter)),
								  a.minFilter !== G && a.minFilter !== X && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
							!0 === e.has("EXT_texture_filter_anisotropic"))
						) {
							const s = e.get("EXT_texture_filter_anisotropic");
							if (a.type === J && !1 === e.has("OES_texture_float_linear")) return;
							if (!1 === o && a.type === Q && !1 === e.has("OES_texture_half_float_linear")) return;
							(a.anisotropy > 1 || i.get(a).__currentAnisotropy) && (t.texParameterf(n, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())), (i.get(a).__currentAnisotropy = a.anisotropy));
						}
					}
					function L(e, n) {
						void 0 === e.__webglInit && ((e.__webglInit = !0), n.addEventListener("dispose", w), (e.__webglTexture = t.createTexture()), s.memory.textures++);
					}
					function R(e, i, r) {
						let s = 3553;
						i.isDataTexture2DArray && (s = 35866), i.isDataTexture3D && (s = 32879), L(e, i), n.activeTexture(33984 + r), n.bindTexture(s, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment), t.pixelStorei(37443, 0);
						const l =
								(function (t) {
									return !o && (t.wrapS !== U || t.wrapT !== U || (t.minFilter !== G && t.minFilter !== X));
								})(i) && !1 === g(i.image),
							c = v(i.image, l, !1, u),
							h = g(c) || o,
							d = a.convert(i.format);
						let p,
							f = a.convert(i.type),
							m = y(i.internalFormat, d, f, i.encoding);
						A(s, i, h);
						const _ = i.mipmaps;
						if (i.isDepthTexture)
							(m = 6402),
								o ? (m = i.type === J ? 36012 : i.type === K ? 33190 : i.type === $ ? 35056 : 33189) : i.type === J && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
								i.format === nt && 6402 === m && i.type !== Z && i.type !== K && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), (i.type = Z), (f = a.convert(i.type))),
								i.format === it && 6402 === m && ((m = 34041), i.type !== $ && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), (i.type = $), (f = a.convert(i.type)))),
								n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, null);
						else if (i.isDataTexture)
							if (_.length > 0 && h) {
								for (let t = 0, e = _.length; t < e; t++) (p = _[t]), n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
								(i.generateMipmaps = !1), (e.__maxMipLevel = _.length - 1);
							} else n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, c.data), (e.__maxMipLevel = 0);
						else if (i.isCompressedTexture) {
							for (let t = 0, e = _.length; t < e; t++) (p = _[t]), i.format !== et && i.format !== tt ? (null !== d ? n.compressedTexImage2D(3553, t, m, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()")) : n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
							e.__maxMipLevel = _.length - 1;
						} else if (i.isDataTexture2DArray) n.texImage3D(35866, 0, m, c.width, c.height, c.depth, 0, d, f, c.data), (e.__maxMipLevel = 0);
						else if (i.isDataTexture3D) n.texImage3D(32879, 0, m, c.width, c.height, c.depth, 0, d, f, c.data), (e.__maxMipLevel = 0);
						else if (_.length > 0 && h) {
							for (let t = 0, e = _.length; t < e; t++) (p = _[t]), n.texImage2D(3553, t, m, d, f, p);
							(i.generateMipmaps = !1), (e.__maxMipLevel = _.length - 1);
						} else n.texImage2D(3553, 0, m, d, f, c), (e.__maxMipLevel = 0);
						b(i, h) && x(s, i, c.width, c.height), (e.__version = i.version), i.onUpdate && i.onUpdate(i);
					}
					function D(e, r, s, o, l) {
						const c = a.convert(s.format),
							u = a.convert(s.type),
							h = y(s.internalFormat, c, u, s.encoding);
						32879 === l || 35866 === l ? n.texImage3D(l, 0, h, r.width, r.height, r.depth, 0, c, u, null) : n.texImage2D(l, 0, h, r.width, r.height, 0, c, u, null), n.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, o, l, i.get(s).__webglTexture, 0), n.bindFramebuffer(36160, null);
					}
					function O(e, n, i) {
						if ((t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer)) {
							let r = 33189;
							if (i) {
								const e = n.depthTexture;
								e && e.isDepthTexture && (e.type === J ? (r = 36012) : e.type === K && (r = 33190));
								const i = I(n);
								t.renderbufferStorageMultisample(36161, i, r, n.width, n.height);
							} else t.renderbufferStorage(36161, r, n.width, n.height);
							t.framebufferRenderbuffer(36160, 36096, 36161, e);
						} else if (n.depthBuffer && n.stencilBuffer) {
							if (i) {
								const e = I(n);
								t.renderbufferStorageMultisample(36161, e, 35056, n.width, n.height);
							} else t.renderbufferStorage(36161, 34041, n.width, n.height);
							t.framebufferRenderbuffer(36160, 33306, 36161, e);
						} else {
							const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture,
								r = a.convert(e.format),
								s = a.convert(e.type),
								o = y(e.internalFormat, r, s, e.encoding);
							if (i) {
								const e = I(n);
								t.renderbufferStorageMultisample(36161, e, o, n.width, n.height);
							} else t.renderbufferStorage(36161, o, n.width, n.height);
						}
						t.bindRenderbuffer(36161, null);
					}
					function z(e) {
						const r = i.get(e),
							a = !0 === e.isWebGLCubeRenderTarget;
						if (e.depthTexture) {
							if (a) throw new Error("target.depthTexture not supported in Cube render targets");
							!(function (e, r) {
								if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
								if ((n.bindFramebuffer(36160, e), !r.depthTexture || !r.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
								(i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height) || ((r.depthTexture.image.width = r.width), (r.depthTexture.image.height = r.height), (r.depthTexture.needsUpdate = !0)), T(r.depthTexture, 0);
								const a = i.get(r.depthTexture).__webglTexture;
								if (r.depthTexture.format === nt) t.framebufferTexture2D(36160, 36096, 3553, a, 0);
								else {
									if (r.depthTexture.format !== it) throw new Error("Unknown depthTexture format");
									t.framebufferTexture2D(36160, 33306, 3553, a, 0);
								}
							})(r.__webglFramebuffer, e);
						} else if (a) {
							r.__webglDepthbuffer = [];
							for (let i = 0; i < 6; i++) n.bindFramebuffer(36160, r.__webglFramebuffer[i]), (r.__webglDepthbuffer[i] = t.createRenderbuffer()), O(r.__webglDepthbuffer[i], e, !1);
						} else n.bindFramebuffer(36160, r.__webglFramebuffer), (r.__webglDepthbuffer = t.createRenderbuffer()), O(r.__webglDepthbuffer, e, !1);
						n.bindFramebuffer(36160, null);
					}
					function I(t) {
						return o && t.isWebGLMultisampleRenderTarget ? Math.min(h, t.samples) : 0;
					}
					let k = !1,
						N = !1;
					(this.allocateTextureUnit = function () {
						const t = S;
						return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l), (S += 1), t;
					}),
						(this.resetTextureUnits = function () {
							S = 0;
						}),
						(this.setTexture2D = T),
						(this.setTexture2DArray = function (t, e) {
							const r = i.get(t);
							t.version > 0 && r.__version !== t.version ? R(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, r.__webglTexture));
						}),
						(this.setTexture3D = function (t, e) {
							const r = i.get(t);
							t.version > 0 && r.__version !== t.version ? R(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, r.__webglTexture));
						}),
						(this.setTextureCube = E),
						(this.setupRenderTarget = function (e) {
							const l = e.texture,
								c = i.get(e),
								u = i.get(l);
							e.addEventListener("dispose", M), !0 !== e.isWebGLMultipleRenderTargets && ((u.__webglTexture = t.createTexture()), (u.__version = l.version), s.memory.textures++);
							const h = !0 === e.isWebGLCubeRenderTarget,
								d = !0 === e.isWebGLMultipleRenderTargets,
								p = !0 === e.isWebGLMultisampleRenderTarget,
								f = l.isDataTexture3D || l.isDataTexture2DArray,
								m = g(e) || o;
							if ((!o || l.format !== tt || (l.type !== J && l.type !== Q) || ((l.format = et), console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), h)) {
								c.__webglFramebuffer = [];
								for (let e = 0; e < 6; e++) c.__webglFramebuffer[e] = t.createFramebuffer();
							} else if (((c.__webglFramebuffer = t.createFramebuffer()), d))
								if (r.drawBuffers) {
									const n = e.texture;
									for (let e = 0, r = n.length; e < r; e++) {
										const r = i.get(n[e]);
										void 0 === r.__webglTexture && ((r.__webglTexture = t.createTexture()), s.memory.textures++);
									}
								} else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
							else if (p)
								if (o) {
									(c.__webglMultisampledFramebuffer = t.createFramebuffer()), (c.__webglColorRenderbuffer = t.createRenderbuffer()), t.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
									const i = a.convert(l.format),
										r = a.convert(l.type),
										s = y(l.internalFormat, i, r, l.encoding),
										o = I(e);
									t.renderbufferStorageMultisample(36161, o, s, e.width, e.height), n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, c.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && ((c.__webglDepthRenderbuffer = t.createRenderbuffer()), O(c.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(36160, null);
								} else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
							if (h) {
								n.bindTexture(34067, u.__webglTexture), A(34067, l, m);
								for (let t = 0; t < 6; t++) D(c.__webglFramebuffer[t], e, l, 36064, 34069 + t);
								b(l, m) && x(34067, l, e.width, e.height), n.unbindTexture();
							} else if (d) {
								const t = e.texture;
								for (let r = 0, a = t.length; r < a; r++) {
									const a = t[r],
										s = i.get(a);
									n.bindTexture(3553, s.__webglTexture), A(3553, a, m), D(c.__webglFramebuffer, e, a, 36064 + r, 3553), b(a, m) && x(3553, a, e.width, e.height);
								}
								n.unbindTexture();
							} else {
								let t = 3553;
								if (f)
									if (o) {
										t = l.isDataTexture3D ? 32879 : 35866;
									} else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
								n.bindTexture(t, u.__webglTexture), A(t, l, m), D(c.__webglFramebuffer, e, l, 36064, t), b(l, m) && x(t, l, e.width, e.height, e.depth), n.unbindTexture();
							}
							e.depthBuffer && z(e);
						}),
						(this.updateRenderTargetMipmap = function (t) {
							const e = g(t) || o,
								r = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
							for (let a = 0, s = r.length; a < s; a++) {
								const s = r[a];
								if (b(s, e)) {
									const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,
										r = i.get(s).__webglTexture;
									n.bindTexture(e, r), x(e, s, t.width, t.height), n.unbindTexture();
								}
							}
						}),
						(this.updateMultisampleRenderTarget = function (e) {
							if (e.isWebGLMultisampleRenderTarget)
								if (o) {
									const r = e.width,
										a = e.height;
									let s = 16384;
									e.depthBuffer && (s |= 256), e.stencilBuffer && (s |= 1024);
									const o = i.get(e);
									n.bindFramebuffer(36008, o.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, o.__webglFramebuffer), t.blitFramebuffer(0, 0, r, a, 0, 0, r, a, s, 9728), n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, o.__webglMultisampledFramebuffer);
								} else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
						}),
						(this.safeSetTexture2D = function (t, e) {
							t && t.isWebGLRenderTarget && (!1 === k && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), (k = !0)), (t = t.texture)), T(t, e);
						}),
						(this.safeSetTextureCube = function (t, e) {
							t && t.isWebGLCubeRenderTarget && (!1 === N && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), (N = !0)), (t = t.texture)), E(t, e);
						});
				}
				function Ya(t, e, n) {
					const i = n.isWebGL2;
					return {
						convert: function (t) {
							let n;
							if (t === Y) return 5121;
							if (1017 === t) return 32819;
							if (1018 === t) return 32820;
							if (1019 === t) return 33635;
							if (1010 === t) return 5120;
							if (1011 === t) return 5122;
							if (t === Z) return 5123;
							if (1013 === t) return 5124;
							if (t === K) return 5125;
							if (t === J) return 5126;
							if (t === Q) return i ? 5131 : ((n = e.get("OES_texture_half_float")), null !== n ? n.HALF_FLOAT_OES : null);
							if (1021 === t) return 6406;
							if (t === tt) return 6407;
							if (t === et) return 6408;
							if (1024 === t) return 6409;
							if (1025 === t) return 6410;
							if (t === nt) return 6402;
							if (t === it) return 34041;
							if (1028 === t) return 6403;
							if (1029 === t) return 36244;
							if (1030 === t) return 33319;
							if (1031 === t) return 33320;
							if (1032 === t) return 36248;
							if (1033 === t) return 36249;
							if (33776 === t || 33777 === t || 33778 === t || 33779 === t) {
								if (((n = e.get("WEBGL_compressed_texture_s3tc")), null === n)) return null;
								if (33776 === t) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
								if (33777 === t) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
								if (33778 === t) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
								if (33779 === t) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
							}
							if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
								if (((n = e.get("WEBGL_compressed_texture_pvrtc")), null === n)) return null;
								if (35840 === t) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
								if (35841 === t) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
								if (35842 === t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
								if (35843 === t) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
							}
							if (36196 === t) return (n = e.get("WEBGL_compressed_texture_etc1")), null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
							if ((37492 === t || 37496 === t) && ((n = e.get("WEBGL_compressed_texture_etc")), null !== n)) {
								if (37492 === t) return n.COMPRESSED_RGB8_ETC2;
								if (37496 === t) return n.COMPRESSED_RGBA8_ETC2_EAC;
							}
							return 37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t || 37840 === t || 37841 === t || 37842 === t || 37843 === t || 37844 === t || 37845 === t || 37846 === t || 37847 === t || 37848 === t || 37849 === t || 37850 === t || 37851 === t || 37852 === t || 37853 === t
								? ((n = e.get("WEBGL_compressed_texture_astc")), null !== n ? t : null)
								: 36492 === t
								? ((n = e.get("EXT_texture_compression_bptc")), null !== n ? t : null)
								: t === $
								? i
									? 34042
									: ((n = e.get("WEBGL_depth_texture")), null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null)
								: void 0;
						},
					};
				}
				class Za extends ni {
					constructor(t = []) {
						super(), (this.cameras = t);
					}
				}
				Za.prototype.isArrayCamera = !0;
				class Ka extends Ye {
					constructor() {
						super(), (this.type = "Group");
					}
				}
				Ka.prototype.isGroup = !0;
				const Ja = { type: "move" };
				class Qa {
					constructor() {
						(this._targetRay = null), (this._grip = null), (this._hand = null);
					}
					getHandSpace() {
						return null === this._hand && ((this._hand = new Ka()), (this._hand.matrixAutoUpdate = !1), (this._hand.visible = !1), (this._hand.joints = {}), (this._hand.inputState = { pinching: !1 })), this._hand;
					}
					getTargetRaySpace() {
						return null === this._targetRay && ((this._targetRay = new Ka()), (this._targetRay.matrixAutoUpdate = !1), (this._targetRay.visible = !1), (this._targetRay.hasLinearVelocity = !1), (this._targetRay.linearVelocity = new Xt()), (this._targetRay.hasAngularVelocity = !1), (this._targetRay.angularVelocity = new Xt())), this._targetRay;
					}
					getGripSpace() {
						return null === this._grip && ((this._grip = new Ka()), (this._grip.matrixAutoUpdate = !1), (this._grip.visible = !1), (this._grip.hasLinearVelocity = !1), (this._grip.linearVelocity = new Xt()), (this._grip.hasAngularVelocity = !1), (this._grip.angularVelocity = new Xt())), this._grip;
					}
					dispatchEvent(t) {
						return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this;
					}
					disconnect(t) {
						return this.dispatchEvent({ type: "disconnected", data: t }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this;
					}
					update(t, e, n) {
						let i = null,
							r = null,
							a = null;
						const s = this._targetRay,
							o = this._grip,
							l = this._hand;
						if (t && "visible-blurred" !== e.session.visibilityState)
							if ((null !== s && ((i = e.getPose(t.targetRaySpace, n)), null !== i && (s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), i.linearVelocity ? ((s.hasLinearVelocity = !0), s.linearVelocity.copy(i.linearVelocity)) : (s.hasLinearVelocity = !1), i.angularVelocity ? ((s.hasAngularVelocity = !0), s.angularVelocity.copy(i.angularVelocity)) : (s.hasAngularVelocity = !1), this.dispatchEvent(Ja))), l && t.hand)) {
								a = !0;
								for (const i of t.hand.values()) {
									const t = e.getJointPose(i, n);
									if (void 0 === l.joints[i.jointName]) {
										const t = new Ka();
										(t.matrixAutoUpdate = !1), (t.visible = !1), (l.joints[i.jointName] = t), l.add(t);
									}
									const r = l.joints[i.jointName];
									null !== t && (r.matrix.fromArray(t.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), (r.jointRadius = t.radius)), (r.visible = null !== t);
								}
								const i = l.joints["index-finger-tip"],
									r = l.joints["thumb-tip"],
									s = i.position.distanceTo(r.position),
									o = 0.02,
									c = 0.005;
								l.inputState.pinching && s > o + c ? ((l.inputState.pinching = !1), this.dispatchEvent({ type: "pinchend", handedness: t.handedness, target: this })) : !l.inputState.pinching && s <= o - c && ((l.inputState.pinching = !0), this.dispatchEvent({ type: "pinchstart", handedness: t.handedness, target: this }));
							} else null !== o && t.gripSpace && ((r = e.getPose(t.gripSpace, n)), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), r.linearVelocity ? ((o.hasLinearVelocity = !0), o.linearVelocity.copy(r.linearVelocity)) : (o.hasLinearVelocity = !1), r.angularVelocity ? ((o.hasAngularVelocity = !0), o.angularVelocity.copy(r.angularVelocity)) : (o.hasAngularVelocity = !1)));
						return null !== s && (s.visible = null !== i), null !== o && (o.visible = null !== r), null !== l && (l.visible = null !== a), this;
					}
				}
				class $a extends xt {
					constructor(t, e) {
						super();
						const n = this,
							i = t.state;
						let r = null,
							a = 1,
							s = null,
							o = "local-floor",
							l = null,
							c = null,
							u = null,
							h = null,
							d = null,
							p = !1,
							f = null,
							m = null,
							v = null,
							g = null,
							b = null,
							x = null;
						const y = t.extensions.has("EXT_multisampled_render_to_texture");
						let _ = null;
						const w = [],
							M = new Map(),
							S = new ni();
						S.layers.enable(1), (S.viewport = new Ht());
						const T = new ni();
						T.layers.enable(2), (T.viewport = new Ht());
						const E = [S, T],
							C = new Za();
						C.layers.enable(1), C.layers.enable(2);
						let P = null,
							A = null;
						function L(t) {
							const e = M.get(t.inputSource);
							e && e.dispatchEvent({ type: t.type, data: t.inputSource });
						}
						function R() {
							M.forEach(function (t, e) {
								t.disconnect(e);
							}),
								M.clear(),
								(P = null),
								(A = null),
								i.bindXRFramebuffer(null),
								t.setRenderTarget(t.getRenderTarget()),
								u && e.deleteFramebuffer(u),
								f && e.deleteFramebuffer(f),
								m && e.deleteRenderbuffer(m),
								v && e.deleteRenderbuffer(v),
								(u = null),
								(f = null),
								(m = null),
								(v = null),
								(d = null),
								(h = null),
								(c = null),
								(r = null),
								N.stop(),
								(n.isPresenting = !1),
								n.dispatchEvent({ type: "sessionend" });
						}
						function D(t) {
							const e = r.inputSources;
							for (let t = 0; t < w.length; t++) M.set(e[t], w[t]);
							for (let e = 0; e < t.removed.length; e++) {
								const n = t.removed[e],
									i = M.get(n);
								i && (i.dispatchEvent({ type: "disconnected", data: n }), M.delete(n));
							}
							for (let e = 0; e < t.added.length; e++) {
								const n = t.added[e],
									i = M.get(n);
								i && i.dispatchEvent({ type: "connected", data: n });
							}
						}
						(this.cameraAutoUpdate = !0),
							(this.enabled = !1),
							(this.isPresenting = !1),
							(this.getController = function (t) {
								let e = w[t];
								return void 0 === e && ((e = new Qa()), (w[t] = e)), e.getTargetRaySpace();
							}),
							(this.getControllerGrip = function (t) {
								let e = w[t];
								return void 0 === e && ((e = new Qa()), (w[t] = e)), e.getGripSpace();
							}),
							(this.getHand = function (t) {
								let e = w[t];
								return void 0 === e && ((e = new Qa()), (w[t] = e)), e.getHandSpace();
							}),
							(this.setFramebufferScaleFactor = function (t) {
								(a = t), !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
							}),
							(this.setReferenceSpaceType = function (t) {
								(o = t), !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
							}),
							(this.getReferenceSpace = function () {
								return s;
							}),
							(this.getBaseLayer = function () {
								return null !== h ? h : d;
							}),
							(this.getBinding = function () {
								return c;
							}),
							(this.getFrame = function () {
								return g;
							}),
							(this.getSession = function () {
								return r;
							}),
							(this.setSession = async function (l) {
								if (((r = l), null !== r)) {
									r.addEventListener("select", L), r.addEventListener("selectstart", L), r.addEventListener("selectend", L), r.addEventListener("squeeze", L), r.addEventListener("squeezestart", L), r.addEventListener("squeezeend", L), r.addEventListener("end", R), r.addEventListener("inputsourceschange", D);
									const l = e.getContextAttributes();
									if ((!0 !== l.xrCompatible && (await e.makeXRCompatible()), void 0 === r.renderState.layers)) {
										const t = { antialias: l.antialias, alpha: l.alpha, depth: l.depth, stencil: l.stencil, framebufferScaleFactor: a };
										(d = new XRWebGLLayer(r, e, t)), r.updateRenderState({ baseLayer: d });
									} else if (e instanceof WebGLRenderingContext) {
										const t = { antialias: !0, alpha: l.alpha, depth: l.depth, stencil: l.stencil, framebufferScaleFactor: a };
										(d = new XRWebGLLayer(r, e, t)), r.updateRenderState({ layers: [d] });
									} else {
										p = l.antialias;
										let n = null;
										l.depth && ((x = 256), l.stencil && (x |= 1024), (b = l.stencil ? 33306 : 36096), (n = l.stencil ? 35056 : 33190));
										const s = { colorFormat: l.alpha ? 32856 : 32849, depthFormat: n, scaleFactor: a };
										(c = new XRWebGLBinding(r, e)),
											(h = c.createProjectionLayer(s)),
											(u = e.createFramebuffer()),
											r.updateRenderState({ layers: [h] }),
											p && y
												? (_ = t.extensions.get("EXT_multisampled_render_to_texture"))
												: p &&
												  ((f = e.createFramebuffer()),
												  (m = e.createRenderbuffer()),
												  e.bindRenderbuffer(36161, m),
												  e.renderbufferStorageMultisample(36161, 4, 32856, h.textureWidth, h.textureHeight),
												  i.bindFramebuffer(36160, f),
												  e.framebufferRenderbuffer(36160, 36064, 36161, m),
												  e.bindRenderbuffer(36161, null),
												  null !== n && ((v = e.createRenderbuffer()), e.bindRenderbuffer(36161, v), e.renderbufferStorageMultisample(36161, 4, n, h.textureWidth, h.textureHeight), e.framebufferRenderbuffer(36160, b, 36161, v), e.bindRenderbuffer(36161, null)),
												  i.bindFramebuffer(36160, null));
									}
									(s = await r.requestReferenceSpace(o)), N.setContext(r), N.start(), (n.isPresenting = !0), n.dispatchEvent({ type: "sessionstart" });
								}
							});
						const O = new Xt(),
							z = new Xt();
						function I(t, e) {
							null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert();
						}
						(this.updateCamera = function (t) {
							if (null === r) return;
							(C.near = T.near = S.near = t.near), (C.far = T.far = S.far = t.far), (P === C.near && A === C.far) || (r.updateRenderState({ depthNear: C.near, depthFar: C.far }), (P = C.near), (A = C.far));
							const e = t.parent,
								n = C.cameras;
							I(C, e);
							for (let t = 0; t < n.length; t++) I(n[t], e);
							C.matrixWorld.decompose(C.position, C.quaternion, C.scale), t.position.copy(C.position), t.quaternion.copy(C.quaternion), t.scale.copy(C.scale), t.matrix.copy(C.matrix), t.matrixWorld.copy(C.matrixWorld);
							const i = t.children;
							for (let t = 0, e = i.length; t < e; t++) i[t].updateMatrixWorld(!0);
							2 === n.length
								? (function (t, e, n) {
										O.setFromMatrixPosition(e.matrixWorld), z.setFromMatrixPosition(n.matrixWorld);
										const i = O.distanceTo(z),
											r = e.projectionMatrix.elements,
											a = n.projectionMatrix.elements,
											s = r[14] / (r[10] - 1),
											o = r[14] / (r[10] + 1),
											l = (r[9] + 1) / r[5],
											c = (r[9] - 1) / r[5],
											u = (r[8] - 1) / r[0],
											h = (a[8] + 1) / a[0],
											d = s * u,
											p = s * h,
											f = i / (-u + h),
											m = f * -u;
										e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
										const v = s + f,
											g = o + f,
											b = d - m,
											x = p + (i - m),
											y = ((l * o) / g) * v,
											_ = ((c * o) / g) * v;
										t.projectionMatrix.makePerspective(b, x, y, _, v, g);
								  })(C, S, T)
								: C.projectionMatrix.copy(S.projectionMatrix);
						}),
							(this.getCamera = function () {
								return C;
							}),
							(this.getFoveation = function () {
								return null !== h ? h.fixedFoveation : null !== d ? d.fixedFoveation : void 0;
							}),
							(this.setFoveation = function (t) {
								null !== h && (h.fixedFoveation = t), null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = t);
							});
						let k = null;
						const N = new fi();
						N.setAnimationLoop(function (t, n) {
							if (((l = n.getViewerPose(s)), (g = n), null !== l)) {
								const t = l.views;
								null !== d && i.bindXRFramebuffer(d.framebuffer);
								let n = !1;
								t.length !== C.cameras.length && ((C.cameras.length = 0), (n = !0));
								for (let r = 0; r < t.length; r++) {
									const a = t[r];
									let s = null;
									if (null !== d) s = d.getViewport(a);
									else {
										const t = c.getViewSubImage(h, a);
										i.bindXRFramebuffer(u), p && y ? (void 0 !== t.depthStencilTexture && _.framebufferTexture2DMultisampleEXT(36160, b, 3553, t.depthStencilTexture, 0, 4), _.framebufferTexture2DMultisampleEXT(36160, 36064, 3553, t.colorTexture, 0, 4)) : (void 0 !== t.depthStencilTexture && e.framebufferTexture2D(36160, b, 3553, t.depthStencilTexture, 0), e.framebufferTexture2D(36160, 36064, 3553, t.colorTexture, 0)), (s = t.viewport);
									}
									const o = E[r];
									o.matrix.fromArray(a.transform.matrix), o.projectionMatrix.fromArray(a.projectionMatrix), o.viewport.set(s.x, s.y, s.width, s.height), 0 === r && C.matrix.copy(o.matrix), !0 === n && C.cameras.push(o);
								}
								p && !y && (i.bindXRFramebuffer(f), null !== x && e.clear(x));
							}
							const a = r.inputSources;
							for (let t = 0; t < w.length; t++) {
								const e = w[t],
									i = a[t];
								e.update(i, n, s);
							}
							if ((k && k(t, n), p && !y)) {
								const t = h.textureWidth,
									n = h.textureHeight;
								i.bindFramebuffer(36008, f), i.bindFramebuffer(36009, u), e.invalidateFramebuffer(36008, [b]), e.invalidateFramebuffer(36009, [b]), e.blitFramebuffer(0, 0, t, n, 0, 0, t, n, 16384, 9728), e.invalidateFramebuffer(36008, [36064]), i.bindFramebuffer(36008, null), i.bindFramebuffer(36009, null), i.bindFramebuffer(36160, f);
							}
							g = null;
						}),
							(this.setAnimationLoop = function (t) {
								k = t;
							}),
							(this.dispose = function () {});
					}
				}
				function ts(t) {
					function e(e, n) {
						(e.opacity.value = n.opacity), n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map), n.alphaMap && (e.alphaMap.value = n.alphaMap), n.specularMap && (e.specularMap.value = n.specularMap), n.alphaTest > 0 && (e.alphaTest.value = n.alphaTest);
						const i = t.get(n).envMap;
						if (i) {
							(e.envMap.value = i), (e.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1), (e.reflectivity.value = n.reflectivity), (e.ior.value = n.ior), (e.refractionRatio.value = n.refractionRatio);
							const r = t.get(i).__maxMipLevel;
							void 0 !== r && (e.maxMipLevel.value = r);
						}
						let r, a;
						n.lightMap && ((e.lightMap.value = n.lightMap), (e.lightMapIntensity.value = n.lightMapIntensity)),
							n.aoMap && ((e.aoMap.value = n.aoMap), (e.aoMapIntensity.value = n.aoMapIntensity)),
							n.map
								? (r = n.map)
								: n.specularMap
								? (r = n.specularMap)
								: n.displacementMap
								? (r = n.displacementMap)
								: n.normalMap
								? (r = n.normalMap)
								: n.bumpMap
								? (r = n.bumpMap)
								: n.roughnessMap
								? (r = n.roughnessMap)
								: n.metalnessMap
								? (r = n.metalnessMap)
								: n.alphaMap
								? (r = n.alphaMap)
								: n.emissiveMap
								? (r = n.emissiveMap)
								: n.clearcoatMap
								? (r = n.clearcoatMap)
								: n.clearcoatNormalMap
								? (r = n.clearcoatNormalMap)
								: n.clearcoatRoughnessMap
								? (r = n.clearcoatRoughnessMap)
								: n.specularIntensityMap
								? (r = n.specularIntensityMap)
								: n.specularTintMap
								? (r = n.specularTintMap)
								: n.transmissionMap
								? (r = n.transmissionMap)
								: n.thicknessMap && (r = n.thicknessMap),
							void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix)),
							n.aoMap ? (a = n.aoMap) : n.lightMap && (a = n.lightMap),
							void 0 !== a && (a.isWebGLRenderTarget && (a = a.texture), !0 === a.matrixAutoUpdate && a.updateMatrix(), e.uv2Transform.value.copy(a.matrix));
					}
					function n(e, n) {
						(e.roughness.value = n.roughness),
							(e.metalness.value = n.metalness),
							n.roughnessMap && (e.roughnessMap.value = n.roughnessMap),
							n.metalnessMap && (e.metalnessMap.value = n.metalnessMap),
							n.emissiveMap && (e.emissiveMap.value = n.emissiveMap),
							n.bumpMap && ((e.bumpMap.value = n.bumpMap), (e.bumpScale.value = n.bumpScale), 1 === n.side && (e.bumpScale.value *= -1)),
							n.normalMap && ((e.normalMap.value = n.normalMap), e.normalScale.value.copy(n.normalScale), 1 === n.side && e.normalScale.value.negate()),
							n.displacementMap && ((e.displacementMap.value = n.displacementMap), (e.displacementScale.value = n.displacementScale), (e.displacementBias.value = n.displacementBias));
						t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity);
					}
					return {
						refreshFogUniforms: function (t, e) {
							t.fogColor.value.copy(e.color), e.isFog ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far)) : e.isFogExp2 && (t.fogDensity.value = e.density);
						},
						refreshMaterialUniforms: function (t, i, r, a, s) {
							i.isMeshBasicMaterial
								? e(t, i)
								: i.isMeshLambertMaterial
								? (e(t, i),
								  (function (t, e) {
										e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
								  })(t, i))
								: i.isMeshToonMaterial
								? (e(t, i),
								  (function (t, e) {
										e.gradientMap && (t.gradientMap.value = e.gradientMap);
										e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
										e.bumpMap && ((t.bumpMap.value = e.bumpMap), (t.bumpScale.value = e.bumpScale), 1 === e.side && (t.bumpScale.value *= -1));
										e.normalMap && ((t.normalMap.value = e.normalMap), t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
										e.displacementMap && ((t.displacementMap.value = e.displacementMap), (t.displacementScale.value = e.displacementScale), (t.displacementBias.value = e.displacementBias));
								  })(t, i))
								: i.isMeshPhongMaterial
								? (e(t, i),
								  (function (t, e) {
										t.specular.value.copy(e.specular), (t.shininess.value = Math.max(e.shininess, 1e-4)), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
										e.bumpMap && ((t.bumpMap.value = e.bumpMap), (t.bumpScale.value = e.bumpScale), 1 === e.side && (t.bumpScale.value *= -1));
										e.normalMap && ((t.normalMap.value = e.normalMap), t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
										e.displacementMap && ((t.displacementMap.value = e.displacementMap), (t.displacementScale.value = e.displacementScale), (t.displacementBias.value = e.displacementBias));
								  })(t, i))
								: i.isMeshStandardMaterial
								? (e(t, i),
								  i.isMeshPhysicalMaterial
										? (function (t, e, i) {
												n(t, e), (t.ior.value = e.ior), e.sheen > 0 && (t.sheenTint.value.copy(e.sheenTint).multiplyScalar(e.sheen), (t.sheenRoughness.value = e.sheenRoughness));
												e.clearcoat > 0 && ((t.clearcoat.value = e.clearcoat), (t.clearcoatRoughness.value = e.clearcoatRoughness), e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), (t.clearcoatNormalMap.value = e.clearcoatNormalMap), 1 === e.side && t.clearcoatNormalScale.value.negate()));
												e.transmission > 0 && ((t.transmission.value = e.transmission), (t.transmissionSamplerMap.value = i.texture), t.transmissionSamplerSize.value.set(i.width, i.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap), (t.thickness.value = e.thickness), e.thicknessMap && (t.thicknessMap.value = e.thicknessMap), (t.attenuationDistance.value = e.attenuationDistance), t.attenuationTint.value.copy(e.attenuationTint));
												(t.specularIntensity.value = e.specularIntensity), t.specularTint.value.copy(e.specularTint), e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap);
												e.specularTintMap && (t.specularTintMap.value = e.specularTintMap);
										  })(t, i, s)
										: n(t, i))
								: i.isMeshMatcapMaterial
								? (e(t, i),
								  (function (t, e) {
										e.matcap && (t.matcap.value = e.matcap);
										e.bumpMap && ((t.bumpMap.value = e.bumpMap), (t.bumpScale.value = e.bumpScale), 1 === e.side && (t.bumpScale.value *= -1));
										e.normalMap && ((t.normalMap.value = e.normalMap), t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
										e.displacementMap && ((t.displacementMap.value = e.displacementMap), (t.displacementScale.value = e.displacementScale), (t.displacementBias.value = e.displacementBias));
								  })(t, i))
								: i.isMeshDepthMaterial
								? (e(t, i),
								  (function (t, e) {
										e.displacementMap && ((t.displacementMap.value = e.displacementMap), (t.displacementScale.value = e.displacementScale), (t.displacementBias.value = e.displacementBias));
								  })(t, i))
								: i.isMeshDistanceMaterial
								? (e(t, i),
								  (function (t, e) {
										e.displacementMap && ((t.displacementMap.value = e.displacementMap), (t.displacementScale.value = e.displacementScale), (t.displacementBias.value = e.displacementBias));
										t.referencePosition.value.copy(e.referencePosition), (t.nearDistance.value = e.nearDistance), (t.farDistance.value = e.farDistance);
								  })(t, i))
								: i.isMeshNormalMaterial
								? (e(t, i),
								  (function (t, e) {
										e.bumpMap && ((t.bumpMap.value = e.bumpMap), (t.bumpScale.value = e.bumpScale), 1 === e.side && (t.bumpScale.value *= -1));
										e.normalMap && ((t.normalMap.value = e.normalMap), t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
										e.displacementMap && ((t.displacementMap.value = e.displacementMap), (t.displacementScale.value = e.displacementScale), (t.displacementBias.value = e.displacementBias));
								  })(t, i))
								: i.isLineBasicMaterial
								? ((function (t, e) {
										t.diffuse.value.copy(e.color), (t.opacity.value = e.opacity);
								  })(t, i),
								  i.isLineDashedMaterial &&
										(function (t, e) {
											(t.dashSize.value = e.dashSize), (t.totalSize.value = e.dashSize + e.gapSize), (t.scale.value = e.scale);
										})(t, i))
								: i.isPointsMaterial
								? (function (t, e, n, i) {
										t.diffuse.value.copy(e.color), (t.opacity.value = e.opacity), (t.size.value = e.size * n), (t.scale.value = 0.5 * i), e.map && (t.map.value = e.map);
										e.alphaMap && (t.alphaMap.value = e.alphaMap);
										e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
										let r;
										e.map ? (r = e.map) : e.alphaMap && (r = e.alphaMap);
										void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix));
								  })(t, i, r, a)
								: i.isSpriteMaterial
								? (function (t, e) {
										t.diffuse.value.copy(e.color), (t.opacity.value = e.opacity), (t.rotation.value = e.rotation), e.map && (t.map.value = e.map);
										e.alphaMap && (t.alphaMap.value = e.alphaMap);
										e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
										let n;
										e.map ? (n = e.map) : e.alphaMap && (n = e.alphaMap);
										void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix));
								  })(t, i)
								: i.isShadowMaterial
								? (t.color.value.copy(i.color), (t.opacity.value = i.opacity))
								: i.isShaderMaterial && (i.uniformsNeedUpdate = !1);
						},
					};
				}
				function es(t = {}) {
					const e =
							void 0 !== t.canvas
								? t.canvas
								: (function () {
										const t = kt("canvas");
										return (t.style.display = "block"), t;
								  })(),
						n = void 0 !== t.context ? t.context : null,
						i = void 0 !== t.alpha && t.alpha,
						r = void 0 === t.depth || t.depth,
						a = void 0 === t.stencil || t.stencil,
						s = void 0 !== t.antialias && t.antialias,
						o = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
						l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
						c = void 0 !== t.powerPreference ? t.powerPreference : "default",
						u = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
					let h = null,
						d = null;
					const p = [],
						f = [];
					(this.domElement = e), (this.debug = { checkShaderErrors: !0 }), (this.autoClear = !0), (this.autoClearColor = !0), (this.autoClearDepth = !0), (this.autoClearStencil = !0), (this.sortObjects = !0), (this.clippingPlanes = []), (this.localClippingEnabled = !1), (this.gammaFactor = 2), (this.outputEncoding = ht), (this.physicallyCorrectLights = !1), (this.toneMapping = 0), (this.toneMappingExposure = 1);
					const m = this;
					let v = !1,
						g = 0,
						b = 0,
						x = null,
						y = -1,
						_ = null;
					const w = new Ht(),
						M = new Ht();
					let S = null,
						T = e.width,
						E = e.height,
						C = 1,
						P = null,
						A = null;
					const L = new Ht(0, 0, T, E),
						R = new Ht(0, 0, T, E);
					let D = !1;
					const O = [],
						z = new pi();
					let I = !1,
						k = !1,
						N = null;
					const V = new Me(),
						B = new Xt(),
						F = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
					function H() {
						return null === x ? C : 1;
					}
					let W,
						j,
						X,
						Z,
						K,
						$,
						tt,
						nt,
						it,
						rt,
						at,
						st,
						ot,
						lt,
						ct,
						ut,
						dt,
						pt,
						ft,
						mt,
						vt,
						gt,
						bt,
						xt = n;
					function yt(t, n) {
						for (let i = 0; i < t.length; i++) {
							const r = t[i],
								a = e.getContext(r, n);
							if (null !== a) return a;
						}
						return null;
					}
					try {
						const t = { alpha: i, depth: r, stencil: a, antialias: s, premultipliedAlpha: o, preserveDrawingBuffer: l, powerPreference: c, failIfMajorPerformanceCaveat: u };
						if ((e.addEventListener("webglcontextlost", Mt, !1), e.addEventListener("webglcontextrestored", St, !1), null === xt)) {
							const e = ["webgl2", "webgl", "experimental-webgl"];
							if ((!0 === m.isWebGL1Renderer && e.shift(), (xt = yt(e, t)), null === xt)) throw yt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
						}
						void 0 === xt.getShaderPrecisionFormat &&
							(xt.getShaderPrecisionFormat = function () {
								return { rangeMin: 1, rangeMax: 1, precision: 1 };
							});
					} catch (t) {
						throw (console.error("THREE.WebGLRenderer: " + t.message), t);
					}
					function _t() {
						(W = new Qi(xt)),
							(j = new Mi(xt, W, t)),
							W.init(j),
							(gt = new Ya(xt, W, j)),
							(X = new Xa(xt, W, j)),
							(O[0] = 1029),
							(Z = new er(xt)),
							(K = new Da()),
							($ = new qa(xt, W, X, K, j, gt, Z)),
							(tt = new Ti(m)),
							(nt = new Ji(m)),
							(it = new mi(xt, j)),
							(bt = new _i(xt, W, it, j)),
							(rt = new $i(xt, it, Z, bt)),
							(at = new or(xt, rt, it, Z)),
							(ft = new sr(xt, j, $)),
							(ut = new Si(K)),
							(st = new Ra(m, tt, nt, W, j, bt, ut)),
							(ot = new ts(K)),
							(lt = new ka(K)),
							(ct = new Ha(W, j)),
							(pt = new yi(m, tt, X, at, o)),
							(dt = new ja(m, at, j)),
							(mt = new wi(xt, W, Z, j)),
							(vt = new tr(xt, W, Z, j)),
							(Z.programs = st.programs),
							(m.capabilities = j),
							(m.extensions = W),
							(m.properties = K),
							(m.renderLists = lt),
							(m.shadowMap = dt),
							(m.state = X),
							(m.info = Z);
					}
					_t();
					const wt = new $a(m, xt);
					function Mt(t) {
						t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), (v = !0);
					}
					function St() {
						console.log("THREE.WebGLRenderer: Context Restored."), (v = !1);
						const t = Z.autoReset,
							e = dt.enabled,
							n = dt.autoUpdate,
							i = dt.needsUpdate,
							r = dt.type;
						_t(), (Z.autoReset = t), (dt.enabled = e), (dt.autoUpdate = n), (dt.needsUpdate = i), (dt.type = r);
					}
					function Tt(t) {
						const e = t.target;
						e.removeEventListener("dispose", Tt),
							(function (t) {
								(function (t) {
									const e = K.get(t).programs;
									void 0 !== e &&
										e.forEach(function (t) {
											st.releaseProgram(t);
										});
								})(t),
									K.remove(t);
							})(e);
					}
					(this.xr = wt),
						(this.getContext = function () {
							return xt;
						}),
						(this.getContextAttributes = function () {
							return xt.getContextAttributes();
						}),
						(this.forceContextLoss = function () {
							const t = W.get("WEBGL_lose_context");
							t && t.loseContext();
						}),
						(this.forceContextRestore = function () {
							const t = W.get("WEBGL_lose_context");
							t && t.restoreContext();
						}),
						(this.getPixelRatio = function () {
							return C;
						}),
						(this.setPixelRatio = function (t) {
							void 0 !== t && ((C = t), this.setSize(T, E, !1));
						}),
						(this.getSize = function (t) {
							return t.set(T, E);
						}),
						(this.setSize = function (t, n, i) {
							wt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : ((T = t), (E = n), (e.width = Math.floor(t * C)), (e.height = Math.floor(n * C)), !1 !== i && ((e.style.width = t + "px"), (e.style.height = n + "px")), this.setViewport(0, 0, t, n));
						}),
						(this.getDrawingBufferSize = function (t) {
							return t.set(T * C, E * C).floor();
						}),
						(this.setDrawingBufferSize = function (t, n, i) {
							(T = t), (E = n), (C = i), (e.width = Math.floor(t * i)), (e.height = Math.floor(n * i)), this.setViewport(0, 0, t, n);
						}),
						(this.getCurrentViewport = function (t) {
							return t.copy(w);
						}),
						(this.getViewport = function (t) {
							return t.copy(L);
						}),
						(this.setViewport = function (t, e, n, i) {
							t.isVector4 ? L.set(t.x, t.y, t.z, t.w) : L.set(t, e, n, i), X.viewport(w.copy(L).multiplyScalar(C).floor());
						}),
						(this.getScissor = function (t) {
							return t.copy(R);
						}),
						(this.setScissor = function (t, e, n, i) {
							t.isVector4 ? R.set(t.x, t.y, t.z, t.w) : R.set(t, e, n, i), X.scissor(M.copy(R).multiplyScalar(C).floor());
						}),
						(this.getScissorTest = function () {
							return D;
						}),
						(this.setScissorTest = function (t) {
							X.setScissorTest((D = t));
						}),
						(this.setOpaqueSort = function (t) {
							P = t;
						}),
						(this.setTransparentSort = function (t) {
							A = t;
						}),
						(this.getClearColor = function (t) {
							return t.copy(pt.getClearColor());
						}),
						(this.setClearColor = function () {
							pt.setClearColor.apply(pt, arguments);
						}),
						(this.getClearAlpha = function () {
							return pt.getClearAlpha();
						}),
						(this.setClearAlpha = function () {
							pt.setClearAlpha.apply(pt, arguments);
						}),
						(this.clear = function (t, e, n) {
							let i = 0;
							(void 0 === t || t) && (i |= 16384), (void 0 === e || e) && (i |= 256), (void 0 === n || n) && (i |= 1024), xt.clear(i);
						}),
						(this.clearColor = function () {
							this.clear(!0, !1, !1);
						}),
						(this.clearDepth = function () {
							this.clear(!1, !0, !1);
						}),
						(this.clearStencil = function () {
							this.clear(!1, !1, !0);
						}),
						(this.dispose = function () {
							e.removeEventListener("webglcontextlost", Mt, !1), e.removeEventListener("webglcontextrestored", St, !1), lt.dispose(), ct.dispose(), K.dispose(), tt.dispose(), nt.dispose(), at.dispose(), bt.dispose(), wt.dispose(), wt.removeEventListener("sessionstart", Ct), wt.removeEventListener("sessionend", Pt), N && (N.dispose(), (N = null)), At.stop();
						}),
						(this.renderBufferImmediate = function (t, e) {
							bt.initAttributes();
							const n = K.get(t);
							t.hasPositions && !n.position && (n.position = xt.createBuffer()), t.hasNormals && !n.normal && (n.normal = xt.createBuffer()), t.hasUvs && !n.uv && (n.uv = xt.createBuffer()), t.hasColors && !n.color && (n.color = xt.createBuffer());
							const i = e.getAttributes();
							t.hasPositions && (xt.bindBuffer(34962, n.position), xt.bufferData(34962, t.positionArray, 35048), bt.enableAttribute(i.position.location), xt.vertexAttribPointer(i.position.location, 3, 5126, !1, 0, 0)),
								t.hasNormals && (xt.bindBuffer(34962, n.normal), xt.bufferData(34962, t.normalArray, 35048), bt.enableAttribute(i.normal.location), xt.vertexAttribPointer(i.normal.location, 3, 5126, !1, 0, 0)),
								t.hasUvs && (xt.bindBuffer(34962, n.uv), xt.bufferData(34962, t.uvArray, 35048), bt.enableAttribute(i.uv.location), xt.vertexAttribPointer(i.uv.location, 2, 5126, !1, 0, 0)),
								t.hasColors && (xt.bindBuffer(34962, n.color), xt.bufferData(34962, t.colorArray, 35048), bt.enableAttribute(i.color.location), xt.vertexAttribPointer(i.color.location, 3, 5126, !1, 0, 0)),
								bt.disableUnusedAttributes(),
								xt.drawArrays(4, 0, t.count),
								(t.count = 0);
						}),
						(this.renderBufferDirect = function (t, e, n, i, r, a) {
							null === e && (e = F);
							const s = r.isMesh && r.matrixWorld.determinant() < 0,
								o = Nt(t, e, i, r);
							X.setMaterial(i, s);
							let l = n.index;
							const c = n.attributes.position;
							if (null === l) {
								if (void 0 === c || 0 === c.count) return;
							} else if (0 === l.count) return;
							let u,
								h = 1;
							!0 === i.wireframe && ((l = rt.getWireframeAttribute(n)), (h = 2)), (void 0 === n.morphAttributes.position && void 0 === n.morphAttributes.normal) || ft.update(r, n, i, o), bt.setup(r, i, o, n, l);
							let d = mt;
							null !== l && ((u = it.get(l)), (d = vt), d.setIndex(u));
							const p = null !== l ? l.count : c.count,
								f = n.drawRange.start * h,
								m = n.drawRange.count * h,
								v = null !== a ? a.start * h : 0,
								g = null !== a ? a.count * h : 1 / 0,
								b = Math.max(f, v),
								x = Math.min(p, f + m, v + g) - 1,
								y = Math.max(0, x - b + 1);
							if (0 !== y) {
								if (r.isMesh) !0 === i.wireframe ? (X.setLineWidth(i.wireframeLinewidth * H()), d.setMode(1)) : d.setMode(4);
								else if (r.isLine) {
									let t = i.linewidth;
									void 0 === t && (t = 1), X.setLineWidth(t * H()), r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3);
								} else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
								if (r.isInstancedMesh) d.renderInstances(b, y, r.count);
								else if (n.isInstancedBufferGeometry) {
									const t = Math.min(n.instanceCount, n._maxInstanceCount);
									d.renderInstances(b, y, t);
								} else d.render(b, y);
							}
						}),
						(this.compile = function (t, e) {
							(d = ct.get(t)),
								d.init(),
								f.push(d),
								t.traverseVisible(function (t) {
									t.isLight && t.layers.test(e.layers) && (d.pushLight(t), t.castShadow && d.pushShadow(t));
								}),
								d.setupLights(m.physicallyCorrectLights),
								t.traverse(function (e) {
									const n = e.material;
									if (n)
										if (Array.isArray(n))
											for (let i = 0; i < n.length; i++) {
												zt(n[i], t, e);
											}
										else zt(n, t, e);
								}),
								f.pop(),
								(d = null);
						});
					let Et = null;
					function Ct() {
						At.stop();
					}
					function Pt() {
						At.start();
					}
					const At = new fi();
					function Lt(t, e, n, i) {
						if (!1 === t.visible) return;
						if (t.layers.test(e.layers))
							if (t.isGroup) n = t.renderOrder;
							else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
							else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t);
							else if (t.isSprite) {
								if (!t.frustumCulled || z.intersectsSprite(t)) {
									i && B.setFromMatrixPosition(t.matrixWorld).applyMatrix4(V);
									const e = at.update(t),
										r = t.material;
									r.visible && h.push(t, e, r, n, B.z, null);
								}
							} else if (t.isImmediateRenderObject) i && B.setFromMatrixPosition(t.matrixWorld).applyMatrix4(V), h.push(t, null, t.material, n, B.z, null);
							else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== Z.render.frame && (t.skeleton.update(), (t.skeleton.frame = Z.render.frame)), !t.frustumCulled || z.intersectsObject(t))) {
								i && B.setFromMatrixPosition(t.matrixWorld).applyMatrix4(V);
								const e = at.update(t),
									r = t.material;
								if (Array.isArray(r)) {
									const i = e.groups;
									for (let a = 0, s = i.length; a < s; a++) {
										const s = i[a],
											o = r[s.materialIndex];
										o && o.visible && h.push(t, e, o, n, B.z, s);
									}
								} else r.visible && h.push(t, e, r, n, B.z, null);
							}
						const r = t.children;
						for (let t = 0, a = r.length; t < a; t++) Lt(r[t], e, n, i);
					}
					function Rt(t, e, n, i) {
						const r = t.opaque,
							a = t.transmissive,
							o = t.transparent;
						d.setupLightsView(n),
							a.length > 0 &&
								(function (t, e, n) {
									if (null === N) {
										const t = !0 === s && !0 === j.isWebGL2;
										N = new (t ? Wt : Gt)(1024, 1024, { generateMipmaps: !0, type: null !== gt.convert(Q) ? Q : Y, minFilter: q, magFilter: G, wrapS: U, wrapT: U });
									}
									const i = m.getRenderTarget();
									m.setRenderTarget(N), m.clear();
									const r = m.toneMapping;
									(m.toneMapping = 0), Dt(t, e, n), (m.toneMapping = r), $.updateMultisampleRenderTarget(N), $.updateRenderTargetMipmap(N), m.setRenderTarget(i);
								})(r, e, n),
							i && X.viewport(w.copy(i)),
							r.length > 0 && Dt(r, e, n),
							a.length > 0 && Dt(a, e, n),
							o.length > 0 && Dt(o, e, n);
					}
					function Dt(t, e, n) {
						const i = !0 === e.isScene ? e.overrideMaterial : null;
						for (let r = 0, a = t.length; r < a; r++) {
							const a = t[r],
								s = a.object,
								o = a.geometry,
								l = null === i ? a.material : i,
								c = a.group;
							s.layers.test(n.layers) && Ot(s, e, n, o, l, c);
						}
					}
					function Ot(t, e, n, i, r, a) {
						if ((t.onBeforeRender(m, e, n, i, r, a), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), r.onBeforeRender(m, e, n, i, t, a), t.isImmediateRenderObject)) {
							const i = Nt(n, e, r, t);
							X.setMaterial(r),
								bt.reset(),
								(function (t, e) {
									t.render(function (t) {
										m.renderBufferImmediate(t, e);
									});
								})(t, i);
						} else !0 === r.transparent && 2 === r.side ? ((r.side = 1), (r.needsUpdate = !0), m.renderBufferDirect(n, e, i, r, t, a), (r.side = 0), (r.needsUpdate = !0), m.renderBufferDirect(n, e, i, r, t, a), (r.side = 2)) : m.renderBufferDirect(n, e, i, r, t, a);
						t.onAfterRender(m, e, n, i, r, a);
					}
					function zt(t, e, n) {
						!0 !== e.isScene && (e = F);
						const i = K.get(t),
							r = d.state.lights,
							a = d.state.shadowsArray,
							s = r.state.version,
							o = st.getParameters(t, r.state, a, e, n),
							l = st.getProgramCacheKey(o);
						let c = i.programs;
						(i.environment = t.isMeshStandardMaterial ? e.environment : null), (i.fog = e.fog), (i.envMap = (t.isMeshStandardMaterial ? nt : tt).get(t.envMap || i.environment)), void 0 === c && (t.addEventListener("dispose", Tt), (c = new Map()), (i.programs = c));
						let u = c.get(l);
						if (void 0 !== u) {
							if (i.currentProgram === u && i.lightsStateVersion === s) return It(t, o), u;
						} else (o.uniforms = st.getUniforms(t)), t.onBuild(o, m), t.onBeforeCompile(o, m), (u = st.acquireProgram(o, l)), c.set(l, u), (i.uniforms = o.uniforms);
						const h = i.uniforms;
						((t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping) || (h.clippingPlanes = ut.uniform),
							It(t, o),
							(i.needsLights = (function (t) {
								return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || (t.isShaderMaterial && !0 === t.lights);
							})(t)),
							(i.lightsStateVersion = s),
							i.needsLights &&
								((h.ambientLightColor.value = r.state.ambient),
								(h.lightProbe.value = r.state.probe),
								(h.directionalLights.value = r.state.directional),
								(h.directionalLightShadows.value = r.state.directionalShadow),
								(h.spotLights.value = r.state.spot),
								(h.spotLightShadows.value = r.state.spotShadow),
								(h.rectAreaLights.value = r.state.rectArea),
								(h.ltc_1.value = r.state.rectAreaLTC1),
								(h.ltc_2.value = r.state.rectAreaLTC2),
								(h.pointLights.value = r.state.point),
								(h.pointLightShadows.value = r.state.pointShadow),
								(h.hemisphereLights.value = r.state.hemi),
								(h.directionalShadowMap.value = r.state.directionalShadowMap),
								(h.directionalShadowMatrix.value = r.state.directionalShadowMatrix),
								(h.spotShadowMap.value = r.state.spotShadowMap),
								(h.spotShadowMatrix.value = r.state.spotShadowMatrix),
								(h.pointShadowMap.value = r.state.pointShadowMap),
								(h.pointShadowMatrix.value = r.state.pointShadowMatrix));
						const p = u.getUniforms(),
							f = ua.seqWithValue(p.seq, h);
						return (i.currentProgram = u), (i.uniformsList = f), u;
					}
					function It(t, e) {
						const n = K.get(t);
						(n.outputEncoding = e.outputEncoding), (n.instancing = e.instancing), (n.skinning = e.skinning), (n.morphTargets = e.morphTargets), (n.morphNormals = e.morphNormals), (n.morphTargetsCount = e.morphTargetsCount), (n.numClippingPlanes = e.numClippingPlanes), (n.numIntersection = e.numClipIntersection), (n.vertexAlphas = e.vertexAlphas), (n.vertexTangents = e.vertexTangents);
					}
					function Nt(t, e, n, i) {
						!0 !== e.isScene && (e = F), $.resetTextureUnits();
						const r = e.fog,
							a = n.isMeshStandardMaterial ? e.environment : null,
							s = null === x ? m.outputEncoding : x.texture.encoding,
							o = (n.isMeshStandardMaterial ? nt : tt).get(n.envMap || a),
							l = !0 === n.vertexColors && !!i.geometry && !!i.geometry.attributes.color && 4 === i.geometry.attributes.color.itemSize,
							c = !!n.normalMap && !!i.geometry && !!i.geometry.attributes.tangent,
							u = !!i.geometry && !!i.geometry.morphAttributes.position,
							h = !!i.geometry && !!i.geometry.morphAttributes.normal,
							p = i.geometry && i.geometry.morphAttributes.position ? i.geometry.morphAttributes.position.length : 0,
							f = K.get(n),
							v = d.state.lights;
						if (!0 === I && (!0 === k || t !== _)) {
							const e = t === _ && n.id === y;
							ut.setState(n, t, e);
						}
						let g = !1;
						n.version === f.__version
							? (f.needsLights && f.lightsStateVersion !== v.state.version) || f.outputEncoding !== s || (i.isInstancedMesh && !1 === f.instancing)
								? (g = !0)
								: i.isInstancedMesh || !0 !== f.instancing
								? i.isSkinnedMesh && !1 === f.skinning
									? (g = !0)
									: i.isSkinnedMesh || !0 !== f.skinning
									? f.envMap !== o || (n.fog && f.fog !== r)
										? (g = !0)
										: void 0 === f.numClippingPlanes || (f.numClippingPlanes === ut.numPlanes && f.numIntersection === ut.numIntersection)
										? (f.vertexAlphas !== l || f.vertexTangents !== c || f.morphTargets !== u || f.morphNormals !== h || (!0 === j.isWebGL2 && f.morphTargetsCount !== p)) && (g = !0)
										: (g = !0)
									: (g = !0)
								: (g = !0)
							: ((g = !0), (f.__version = n.version));
						let b = f.currentProgram;
						!0 === g && (b = zt(n, e, i));
						let w = !1,
							M = !1,
							S = !1;
						const T = b.getUniforms(),
							P = f.uniforms;
						if ((X.useProgram(b.program) && ((w = !0), (M = !0), (S = !0)), n.id !== y && ((y = n.id), (M = !0)), w || _ !== t)) {
							if ((T.setValue(xt, "projectionMatrix", t.projectionMatrix), j.logarithmicDepthBuffer && T.setValue(xt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), _ !== t && ((_ = t), (M = !0), (S = !0)), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap)) {
								const e = T.map.cameraPosition;
								void 0 !== e && e.setValue(xt, B.setFromMatrixPosition(t.matrixWorld));
							}
							(n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && T.setValue(xt, "isOrthographic", !0 === t.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || i.isSkinnedMesh) && T.setValue(xt, "viewMatrix", t.matrixWorldInverse);
						}
						if (i.isSkinnedMesh) {
							T.setOptional(xt, i, "bindMatrix"), T.setOptional(xt, i, "bindMatrixInverse");
							const t = i.skeleton;
							t && (j.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), T.setValue(xt, "boneTexture", t.boneTexture, $), T.setValue(xt, "boneTextureSize", t.boneTextureSize)) : T.setOptional(xt, t, "boneMatrices"));
						}
						var A, L;
						return (
							(M || f.receiveShadow !== i.receiveShadow) && ((f.receiveShadow = i.receiveShadow), T.setValue(xt, "receiveShadow", i.receiveShadow)),
							M &&
								(T.setValue(xt, "toneMappingExposure", m.toneMappingExposure),
								f.needsLights && ((L = S), ((A = P).ambientLightColor.needsUpdate = L), (A.lightProbe.needsUpdate = L), (A.directionalLights.needsUpdate = L), (A.directionalLightShadows.needsUpdate = L), (A.pointLights.needsUpdate = L), (A.pointLightShadows.needsUpdate = L), (A.spotLights.needsUpdate = L), (A.spotLightShadows.needsUpdate = L), (A.rectAreaLights.needsUpdate = L), (A.hemisphereLights.needsUpdate = L)),
								r && n.fog && ot.refreshFogUniforms(P, r),
								ot.refreshMaterialUniforms(P, n, C, E, N),
								ua.upload(xt, f.uniformsList, P, $)),
							n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (ua.upload(xt, f.uniformsList, P, $), (n.uniformsNeedUpdate = !1)),
							n.isSpriteMaterial && T.setValue(xt, "center", i.center),
							T.setValue(xt, "modelViewMatrix", i.modelViewMatrix),
							T.setValue(xt, "normalMatrix", i.normalMatrix),
							T.setValue(xt, "modelMatrix", i.matrixWorld),
							b
						);
					}
					At.setAnimationLoop(function (t) {
						Et && Et(t);
					}),
						"undefined" != typeof window && At.setContext(window),
						(this.setAnimationLoop = function (t) {
							(Et = t), wt.setAnimationLoop(t), null === t ? At.stop() : At.start();
						}),
						wt.addEventListener("sessionstart", Ct),
						wt.addEventListener("sessionend", Pt),
						(this.render = function (t, e) {
							if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
							if (!0 === v) return;
							!0 === t.autoUpdate && t.updateMatrixWorld(),
								null === e.parent && e.updateMatrixWorld(),
								!0 === wt.enabled && !0 === wt.isPresenting && (!0 === wt.cameraAutoUpdate && wt.updateCamera(e), (e = wt.getCamera())),
								!0 === t.isScene && t.onBeforeRender(m, t, e, x),
								(d = ct.get(t, f.length)),
								d.init(),
								f.push(d),
								V.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
								z.setFromProjectionMatrix(V),
								(k = this.localClippingEnabled),
								(I = ut.init(this.clippingPlanes, k, e)),
								(h = lt.get(t, p.length)),
								h.init(),
								p.push(h),
								Lt(t, e, 0, m.sortObjects),
								h.finish(),
								!0 === m.sortObjects && h.sort(P, A),
								!0 === I && ut.beginShadows();
							const n = d.state.shadowsArray;
							if ((dt.render(n, t, e), !0 === I && ut.endShadows(), !0 === this.info.autoReset && this.info.reset(), pt.render(h, t), d.setupLights(m.physicallyCorrectLights), e.isArrayCamera)) {
								const n = e.cameras;
								for (let e = 0, i = n.length; e < i; e++) {
									const i = n[e];
									Rt(h, t, i, i.viewport);
								}
							} else Rt(h, t, e);
							null !== x && ($.updateMultisampleRenderTarget(x), $.updateRenderTargetMipmap(x)), !0 === t.isScene && t.onAfterRender(m, t, e), X.buffers.depth.setTest(!0), X.buffers.depth.setMask(!0), X.buffers.color.setMask(!0), X.setPolygonOffset(!1), bt.resetDefaultState(), (y = -1), (_ = null), f.pop(), (d = f.length > 0 ? f[f.length - 1] : null), p.pop(), (h = p.length > 0 ? p[p.length - 1] : null);
						}),
						(this.getActiveCubeFace = function () {
							return g;
						}),
						(this.getActiveMipmapLevel = function () {
							return b;
						}),
						(this.getRenderTarget = function () {
							return x;
						}),
						(this.setRenderTarget = function (t, e = 0, n = 0) {
							(x = t), (g = e), (b = n), t && void 0 === K.get(t).__webglFramebuffer && $.setupRenderTarget(t);
							let i = null,
								r = !1,
								a = !1;
							if (t) {
								const n = t.texture;
								(n.isDataTexture3D || n.isDataTexture2DArray) && (a = !0);
								const s = K.get(t).__webglFramebuffer;
								t.isWebGLCubeRenderTarget ? ((i = s[e]), (r = !0)) : (i = t.isWebGLMultisampleRenderTarget ? K.get(t).__webglMultisampledFramebuffer : s), w.copy(t.viewport), M.copy(t.scissor), (S = t.scissorTest);
							} else w.copy(L).multiplyScalar(C).floor(), M.copy(R).multiplyScalar(C).floor(), (S = D);
							if (X.bindFramebuffer(36160, i) && j.drawBuffers) {
								let e = !1;
								if (t)
									if (t.isWebGLMultipleRenderTargets) {
										const n = t.texture;
										if (O.length !== n.length || 36064 !== O[0]) {
											for (let t = 0, e = n.length; t < e; t++) O[t] = 36064 + t;
											(O.length = n.length), (e = !0);
										}
									} else (1 === O.length && 36064 === O[0]) || ((O[0] = 36064), (O.length = 1), (e = !0));
								else (1 === O.length && 1029 === O[0]) || ((O[0] = 1029), (O.length = 1), (e = !0));
								e && (j.isWebGL2 ? xt.drawBuffers(O) : W.get("WEBGL_draw_buffers").drawBuffersWEBGL(O));
							}
							if ((X.viewport(w), X.scissor(M), X.setScissorTest(S), r)) {
								const i = K.get(t.texture);
								xt.framebufferTexture2D(36160, 36064, 34069 + e, i.__webglTexture, n);
							} else if (a) {
								const i = K.get(t.texture),
									r = e || 0;
								xt.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r);
							}
							y = -1;
						}),
						(this.readRenderTargetPixels = function (t, e, n, i, r, a, s) {
							if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
							let o = K.get(t).__webglFramebuffer;
							if ((t.isWebGLCubeRenderTarget && void 0 !== s && (o = o[s]), o)) {
								X.bindFramebuffer(36160, o);
								try {
									const s = t.texture,
										o = s.format,
										l = s.type;
									if (o !== et && gt.convert(o) !== xt.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
									const c = l === Q && (W.has("EXT_color_buffer_half_float") || (j.isWebGL2 && W.has("EXT_color_buffer_float")));
									if (!(l === Y || gt.convert(l) === xt.getParameter(35738) || (l === J && (j.isWebGL2 || W.has("OES_texture_float") || W.has("WEBGL_color_buffer_float"))) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
									36053 === xt.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && xt.readPixels(e, n, i, r, gt.convert(o), gt.convert(l), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
								} finally {
									const t = null !== x ? K.get(x).__webglFramebuffer : null;
									X.bindFramebuffer(36160, t);
								}
							}
						}),
						(this.copyFramebufferToTexture = function (t, e, n = 0) {
							const i = Math.pow(2, -n),
								r = Math.floor(e.image.width * i),
								a = Math.floor(e.image.height * i);
							let s = gt.convert(e.format);
							j.isWebGL2 && (6407 === s && (s = 32849), 6408 === s && (s = 32856)), $.setTexture2D(e, 0), xt.copyTexImage2D(3553, n, s, t.x, t.y, r, a, 0), X.unbindTexture();
						}),
						(this.copyTextureToTexture = function (t, e, n, i = 0) {
							const r = e.image.width,
								a = e.image.height,
								s = gt.convert(n.format),
								o = gt.convert(n.type);
							$.setTexture2D(n, 0),
								xt.pixelStorei(37440, n.flipY),
								xt.pixelStorei(37441, n.premultiplyAlpha),
								xt.pixelStorei(3317, n.unpackAlignment),
								e.isDataTexture ? xt.texSubImage2D(3553, i, t.x, t.y, r, a, s, o, e.image.data) : e.isCompressedTexture ? xt.compressedTexSubImage2D(3553, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, s, e.mipmaps[0].data) : xt.texSubImage2D(3553, i, t.x, t.y, s, o, e.image),
								0 === i && n.generateMipmaps && xt.generateMipmap(3553),
								X.unbindTexture();
						}),
						(this.copyTextureToTexture3D = function (t, e, n, i, r = 0) {
							if (m.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
							const a = t.max.x - t.min.x + 1,
								s = t.max.y - t.min.y + 1,
								o = t.max.z - t.min.z + 1,
								l = gt.convert(i.format),
								c = gt.convert(i.type);
							let u;
							if (i.isDataTexture3D) $.setTexture3D(i, 0), (u = 32879);
							else {
								if (!i.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
								$.setTexture2DArray(i, 0), (u = 35866);
							}
							xt.pixelStorei(37440, i.flipY), xt.pixelStorei(37441, i.premultiplyAlpha), xt.pixelStorei(3317, i.unpackAlignment);
							const h = xt.getParameter(3314),
								d = xt.getParameter(32878),
								p = xt.getParameter(3316),
								f = xt.getParameter(3315),
								v = xt.getParameter(32877),
								g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
							xt.pixelStorei(3314, g.width),
								xt.pixelStorei(32878, g.height),
								xt.pixelStorei(3316, t.min.x),
								xt.pixelStorei(3315, t.min.y),
								xt.pixelStorei(32877, t.min.z),
								n.isDataTexture || n.isDataTexture3D ? xt.texSubImage3D(u, r, e.x, e.y, e.z, a, s, o, l, c, g.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), xt.compressedTexSubImage3D(u, r, e.x, e.y, e.z, a, s, o, l, g.data)) : xt.texSubImage3D(u, r, e.x, e.y, e.z, a, s, o, l, c, g),
								xt.pixelStorei(3314, h),
								xt.pixelStorei(32878, d),
								xt.pixelStorei(3316, p),
								xt.pixelStorei(3315, f),
								xt.pixelStorei(32877, v),
								0 === r && i.generateMipmaps && xt.generateMipmap(u),
								X.unbindTexture();
						}),
						(this.initTexture = function (t) {
							$.setTexture2D(t, 0), X.unbindTexture();
						}),
						(this.resetState = function () {
							(g = 0), (b = 0), (x = null), X.reset(), bt.reset();
						}),
						"undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
				}
				(class extends es {}.prototype.isWebGL1Renderer = !0);
				class ns {
					constructor(t, e = 25e-5) {
						(this.name = ""), (this.color = new mn(t)), (this.density = e);
					}
					clone() {
						return new ns(this.color, this.density);
					}
					toJSON() {
						return { type: "FogExp2", color: this.color.getHex(), density: this.density };
					}
				}
				ns.prototype.isFogExp2 = !0;
				class is {
					constructor(t, e = 1, n = 1e3) {
						(this.name = ""), (this.color = new mn(t)), (this.near = e), (this.far = n);
					}
					clone() {
						return new is(this.color, this.near, this.far);
					}
					toJSON() {
						return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far };
					}
				}
				is.prototype.isFog = !0;
				class rs extends Ye {
					constructor() {
						super(), (this.type = "Scene"), (this.background = null), (this.environment = null), (this.fog = null), (this.overrideMaterial = null), (this.autoUpdate = !0), "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
					}
					copy(t, e) {
						return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), (this.autoUpdate = t.autoUpdate), (this.matrixAutoUpdate = t.matrixAutoUpdate), this;
					}
					toJSON(t) {
						const e = super.toJSON(t);
						return null !== this.fog && (e.object.fog = this.fog.toJSON()), e;
					}
				}
				rs.prototype.isScene = !0;
				class as {
					constructor(t, e) {
						(this.array = t), (this.stride = e), (this.count = void 0 !== t ? t.length / e : 0), (this.usage = vt), (this.updateRange = { offset: 0, count: -1 }), (this.version = 0), (this.uuid = Tt());
					}
					onUploadCallback() {}
					set needsUpdate(t) {
						!0 === t && this.version++;
					}
					setUsage(t) {
						return (this.usage = t), this;
					}
					copy(t) {
						return (this.array = new t.array.constructor(t.array)), (this.count = t.count), (this.stride = t.stride), (this.usage = t.usage), this;
					}
					copyAt(t, e, n) {
						(t *= this.stride), (n *= e.stride);
						for (let i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i];
						return this;
					}
					set(t, e = 0) {
						return this.array.set(t, e), this;
					}
					clone(t) {
						void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Tt()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
						const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
							n = new this.constructor(e, this.stride);
						return n.setUsage(this.usage), n;
					}
					onUpload(t) {
						return (this.onUploadCallback = t), this;
					}
					toJSON(t) {
						return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Tt()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };
					}
				}
				as.prototype.isInterleavedBuffer = !0;
				const ss = new Xt();
				class os {
					constructor(t, e, n, i = !1) {
						(this.name = ""), (this.data = t), (this.itemSize = e), (this.offset = n), (this.normalized = !0 === i);
					}
					get count() {
						return this.data.count;
					}
					get array() {
						return this.data.array;
					}
					set needsUpdate(t) {
						this.data.needsUpdate = t;
					}
					applyMatrix4(t) {
						for (let e = 0, n = this.data.count; e < n; e++) (ss.x = this.getX(e)), (ss.y = this.getY(e)), (ss.z = this.getZ(e)), ss.applyMatrix4(t), this.setXYZ(e, ss.x, ss.y, ss.z);
						return this;
					}
					applyNormalMatrix(t) {
						for (let e = 0, n = this.count; e < n; e++) (ss.x = this.getX(e)), (ss.y = this.getY(e)), (ss.z = this.getZ(e)), ss.applyNormalMatrix(t), this.setXYZ(e, ss.x, ss.y, ss.z);
						return this;
					}
					transformDirection(t) {
						for (let e = 0, n = this.count; e < n; e++) (ss.x = this.getX(e)), (ss.y = this.getY(e)), (ss.z = this.getZ(e)), ss.transformDirection(t), this.setXYZ(e, ss.x, ss.y, ss.z);
						return this;
					}
					setX(t, e) {
						return (this.data.array[t * this.data.stride + this.offset] = e), this;
					}
					setY(t, e) {
						return (this.data.array[t * this.data.stride + this.offset + 1] = e), this;
					}
					setZ(t, e) {
						return (this.data.array[t * this.data.stride + this.offset + 2] = e), this;
					}
					setW(t, e) {
						return (this.data.array[t * this.data.stride + this.offset + 3] = e), this;
					}
					getX(t) {
						return this.data.array[t * this.data.stride + this.offset];
					}
					getY(t) {
						return this.data.array[t * this.data.stride + this.offset + 1];
					}
					getZ(t) {
						return this.data.array[t * this.data.stride + this.offset + 2];
					}
					getW(t) {
						return this.data.array[t * this.data.stride + this.offset + 3];
					}
					setXY(t, e, n) {
						return (t = t * this.data.stride + this.offset), (this.data.array[t + 0] = e), (this.data.array[t + 1] = n), this;
					}
					setXYZ(t, e, n, i) {
						return (t = t * this.data.stride + this.offset), (this.data.array[t + 0] = e), (this.data.array[t + 1] = n), (this.data.array[t + 2] = i), this;
					}
					setXYZW(t, e, n, i, r) {
						return (t = t * this.data.stride + this.offset), (this.data.array[t + 0] = e), (this.data.array[t + 1] = n), (this.data.array[t + 2] = i), (this.data.array[t + 3] = r), this;
					}
					clone(t) {
						if (void 0 === t) {
							console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
							const t = [];
							for (let e = 0; e < this.count; e++) {
								const n = e * this.data.stride + this.offset;
								for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e]);
							}
							return new xn(new this.array.constructor(t), this.itemSize, this.normalized);
						}
						return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new os(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
					}
					toJSON(t) {
						if (void 0 === t) {
							console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
							const t = [];
							for (let e = 0; e < this.count; e++) {
								const n = e * this.data.stride + this.offset;
								for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e]);
							}
							return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized };
						}
						return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
					}
				}
				os.prototype.isInterleavedBufferAttribute = !0;
				class ls extends ln {
					constructor(t) {
						super(), (this.type = "SpriteMaterial"), (this.color = new mn(16777215)), (this.map = null), (this.alphaMap = null), (this.rotation = 0), (this.sizeAttenuation = !0), (this.transparent = !0), this.setValues(t);
					}
					copy(t) {
						return super.copy(t), this.color.copy(t.color), (this.map = t.map), (this.alphaMap = t.alphaMap), (this.rotation = t.rotation), (this.sizeAttenuation = t.sizeAttenuation), this;
					}
				}
				let cs;
				ls.prototype.isSpriteMaterial = !0;
				const us = new Xt(),
					hs = new Xt(),
					ds = new Xt(),
					ps = new Ot(),
					fs = new Ot(),
					ms = new Me(),
					vs = new Xt(),
					gs = new Xt(),
					bs = new Xt(),
					xs = new Ot(),
					ys = new Ot(),
					_s = new Ot();
				class ws extends Ye {
					constructor(t) {
						if ((super(), (this.type = "Sprite"), void 0 === cs)) {
							cs = new Ln();
							const t = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]),
								e = new as(t, 5);
							cs.setIndex([0, 1, 2, 0, 2, 3]), cs.setAttribute("position", new os(e, 3, 0, !1)), cs.setAttribute("uv", new os(e, 2, 3, !1));
						}
						(this.geometry = cs), (this.material = void 0 !== t ? t : new ls()), (this.center = new Ot(0.5, 0.5));
					}
					raycast(t, e) {
						null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), hs.setFromMatrixScale(this.matrixWorld), ms.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), ds.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && hs.multiplyScalar(-ds.z);
						const n = this.material.rotation;
						let i, r;
						0 !== n && ((r = Math.cos(n)), (i = Math.sin(n)));
						const a = this.center;
						Ms(vs.set(-0.5, -0.5, 0), ds, a, hs, i, r), Ms(gs.set(0.5, -0.5, 0), ds, a, hs, i, r), Ms(bs.set(0.5, 0.5, 0), ds, a, hs, i, r), xs.set(0, 0), ys.set(1, 0), _s.set(1, 1);
						let s = t.ray.intersectTriangle(vs, gs, bs, !1, us);
						if (null === s && (Ms(gs.set(-0.5, 0.5, 0), ds, a, hs, i, r), ys.set(0, 1), (s = t.ray.intersectTriangle(vs, bs, gs, !1, us)), null === s)) return;
						const o = t.ray.origin.distanceTo(us);
						o < t.near || o > t.far || e.push({ distance: o, point: us.clone(), uv: sn.getUV(us, vs, gs, bs, xs, ys, _s, new Ot()), face: null, object: this });
					}
					copy(t) {
						return super.copy(t), void 0 !== t.center && this.center.copy(t.center), (this.material = t.material), this;
					}
				}
				function Ms(t, e, n, i, r, a) {
					ps.subVectors(t, n).addScalar(0.5).multiply(i), void 0 !== r ? ((fs.x = a * ps.x - r * ps.y), (fs.y = r * ps.x + a * ps.y)) : fs.copy(ps), t.copy(e), (t.x += fs.x), (t.y += fs.y), t.applyMatrix4(ms);
				}
				ws.prototype.isSprite = !0;
				const Ss = new Xt(),
					Ts = new Ht(),
					Es = new Ht(),
					Cs = new Xt(),
					Ps = new Me();
				class As extends Yn {
					constructor(t, e) {
						super(t, e), (this.type = "SkinnedMesh"), (this.bindMode = "attached"), (this.bindMatrix = new Me()), (this.bindMatrixInverse = new Me());
					}
					copy(t) {
						return super.copy(t), (this.bindMode = t.bindMode), this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), (this.skeleton = t.skeleton), this;
					}
					bind(t, e) {
						(this.skeleton = t), void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), (e = this.matrixWorld)), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert();
					}
					pose() {
						this.skeleton.pose();
					}
					normalizeSkinWeights() {
						const t = new Ht(),
							e = this.geometry.attributes.skinWeight;
						for (let n = 0, i = e.count; n < i; n++) {
							(t.x = e.getX(n)), (t.y = e.getY(n)), (t.z = e.getZ(n)), (t.w = e.getW(n));
							const i = 1 / t.manhattanLength();
							i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w);
						}
					}
					updateMatrixWorld(t) {
						super.updateMatrixWorld(t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
					}
					boneTransform(t, e) {
						const n = this.skeleton,
							i = this.geometry;
						Ts.fromBufferAttribute(i.attributes.skinIndex, t), Es.fromBufferAttribute(i.attributes.skinWeight, t), Ss.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
						for (let t = 0; t < 4; t++) {
							const i = Es.getComponent(t);
							if (0 !== i) {
								const r = Ts.getComponent(t);
								Ps.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), e.addScaledVector(Cs.copy(Ss).applyMatrix4(Ps), i);
							}
						}
						return e.applyMatrix4(this.bindMatrixInverse);
					}
				}
				As.prototype.isSkinnedMesh = !0;
				class Ls extends Ye {
					constructor() {
						super(), (this.type = "Bone");
					}
				}
				Ls.prototype.isBone = !0;
				class Rs extends Ft {
					constructor(t = null, e = 1, n = 1, i, r, a, s, o, l = 1003, c = 1003, u, h) {
						super(null, a, s, o, l, c, i, r, u, h), (this.image = { data: t, width: e, height: n }), (this.magFilter = l), (this.minFilter = c), (this.generateMipmaps = !1), (this.flipY = !1), (this.unpackAlignment = 1), (this.needsUpdate = !0);
					}
				}
				Rs.prototype.isDataTexture = !0;
				class Ds extends xn {
					constructor(t, e, n, i = 1) {
						"number" == typeof n && ((i = n), (n = !1), console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t, e, n), (this.meshPerAttribute = i);
					}
					copy(t) {
						return super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this;
					}
					toJSON() {
						const t = super.toJSON();
						return (t.meshPerAttribute = this.meshPerAttribute), (t.isInstancedBufferAttribute = !0), t;
					}
				}
				Ds.prototype.isInstancedBufferAttribute = !0;
				const Os = new Me(),
					zs = new Me(),
					Is = [],
					ks = new Yn();
				class Ns extends Yn {
					constructor(t, e, n) {
						super(t, e), (this.instanceMatrix = new Ds(new Float32Array(16 * n), 16)), (this.instanceColor = null), (this.count = n), (this.frustumCulled = !1);
					}
					copy(t) {
						return super.copy(t), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), (this.count = t.count), this;
					}
					getColorAt(t, e) {
						e.fromArray(this.instanceColor.array, 3 * t);
					}
					getMatrixAt(t, e) {
						e.fromArray(this.instanceMatrix.array, 16 * t);
					}
					raycast(t, e) {
						const n = this.matrixWorld,
							i = this.count;
						if (((ks.geometry = this.geometry), (ks.material = this.material), void 0 !== ks.material))
							for (let r = 0; r < i; r++) {
								this.getMatrixAt(r, Os), zs.multiplyMatrices(n, Os), (ks.matrixWorld = zs), ks.raycast(t, Is);
								for (let t = 0, n = Is.length; t < n; t++) {
									const n = Is[t];
									(n.instanceId = r), (n.object = this), e.push(n);
								}
								Is.length = 0;
							}
					}
					setColorAt(t, e) {
						null === this.instanceColor && (this.instanceColor = new Ds(new Float32Array(3 * this.instanceMatrix.count), 3)), e.toArray(this.instanceColor.array, 3 * t);
					}
					setMatrixAt(t, e) {
						e.toArray(this.instanceMatrix.array, 16 * t);
					}
					updateMorphTargets() {}
					dispose() {
						this.dispatchEvent({ type: "dispose" });
					}
				}
				Ns.prototype.isInstancedMesh = !0;
				class Vs extends ln {
					constructor(t) {
						super(), (this.type = "LineBasicMaterial"), (this.color = new mn(16777215)), (this.linewidth = 1), (this.linecap = "round"), (this.linejoin = "round"), this.setValues(t);
					}
					copy(t) {
						return super.copy(t), this.color.copy(t.color), (this.linewidth = t.linewidth), (this.linecap = t.linecap), (this.linejoin = t.linejoin), this;
					}
				}
				Vs.prototype.isLineBasicMaterial = !0;
				const Bs = new Xt(),
					Fs = new Xt(),
					Us = new Me(),
					Hs = new we(),
					Gs = new fe();
				class Ws extends Ye {
					constructor(t = new Ln(), e = new Vs()) {
						super(), (this.type = "Line"), (this.geometry = t), (this.material = e), this.updateMorphTargets();
					}
					copy(t) {
						return super.copy(t), (this.material = t.material), (this.geometry = t.geometry), this;
					}
					computeLineDistances() {
						const t = this.geometry;
						if (t.isBufferGeometry)
							if (null === t.index) {
								const e = t.attributes.position,
									n = [0];
								for (let t = 1, i = e.count; t < i; t++) Bs.fromBufferAttribute(e, t - 1), Fs.fromBufferAttribute(e, t), (n[t] = n[t - 1]), (n[t] += Bs.distanceTo(Fs));
								t.setAttribute("lineDistance", new wn(n, 1));
							} else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
						else t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
						return this;
					}
					raycast(t, e) {
						const n = this.geometry,
							i = this.matrixWorld,
							r = t.params.Line.threshold,
							a = n.drawRange;
						if ((null === n.boundingSphere && n.computeBoundingSphere(), Gs.copy(n.boundingSphere), Gs.applyMatrix4(i), (Gs.radius += r), !1 === t.ray.intersectsSphere(Gs))) return;
						Us.copy(i).invert(), Hs.copy(t.ray).applyMatrix4(Us);
						const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
							o = s * s,
							l = new Xt(),
							c = new Xt(),
							u = new Xt(),
							h = new Xt(),
							d = this.isLineSegments ? 2 : 1;
						if (n.isBufferGeometry) {
							const i = n.index,
								r = n.attributes.position;
							if (null !== i) {
								for (let n = Math.max(0, a.start), s = Math.min(i.count, a.start + a.count) - 1; n < s; n += d) {
									const a = i.getX(n),
										s = i.getX(n + 1);
									l.fromBufferAttribute(r, a), c.fromBufferAttribute(r, s);
									if (Hs.distanceSqToSegment(l, c, h, u) > o) continue;
									h.applyMatrix4(this.matrixWorld);
									const d = t.ray.origin.distanceTo(h);
									d < t.near || d > t.far || e.push({ distance: d, point: u.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this });
								}
							} else {
								for (let n = Math.max(0, a.start), i = Math.min(r.count, a.start + a.count) - 1; n < i; n += d) {
									l.fromBufferAttribute(r, n), c.fromBufferAttribute(r, n + 1);
									if (Hs.distanceSqToSegment(l, c, h, u) > o) continue;
									h.applyMatrix4(this.matrixWorld);
									const i = t.ray.origin.distanceTo(h);
									i < t.near || i > t.far || e.push({ distance: i, point: u.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this });
								}
							}
						} else n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
					}
					updateMorphTargets() {
						const t = this.geometry;
						if (t.isBufferGeometry) {
							const e = t.morphAttributes,
								n = Object.keys(e);
							if (n.length > 0) {
								const t = e[n[0]];
								if (void 0 !== t) {
									(this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
									for (let e = 0, n = t.length; e < n; e++) {
										const n = t[e].name || String(e);
										this.morphTargetInfluences.push(0), (this.morphTargetDictionary[n] = e);
									}
								}
							}
						} else {
							const e = t.morphTargets;
							void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
						}
					}
				}
				Ws.prototype.isLine = !0;
				const js = new Xt(),
					Xs = new Xt();
				class qs extends Ws {
					constructor(t, e) {
						super(t, e), (this.type = "LineSegments");
					}
					computeLineDistances() {
						const t = this.geometry;
						if (t.isBufferGeometry)
							if (null === t.index) {
								const e = t.attributes.position,
									n = [];
								for (let t = 0, i = e.count; t < i; t += 2) js.fromBufferAttribute(e, t), Xs.fromBufferAttribute(e, t + 1), (n[t] = 0 === t ? 0 : n[t - 1]), (n[t + 1] = n[t] + js.distanceTo(Xs));
								t.setAttribute("lineDistance", new wn(n, 1));
							} else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
						else t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
						return this;
					}
				}
				qs.prototype.isLineSegments = !0;
				class Ys extends Ws {
					constructor(t, e) {
						super(t, e), (this.type = "LineLoop");
					}
				}
				Ys.prototype.isLineLoop = !0;
				class Zs extends ln {
					constructor(t) {
						super(), (this.type = "PointsMaterial"), (this.color = new mn(16777215)), (this.map = null), (this.alphaMap = null), (this.size = 1), (this.sizeAttenuation = !0), this.setValues(t);
					}
					copy(t) {
						return super.copy(t), this.color.copy(t.color), (this.map = t.map), (this.alphaMap = t.alphaMap), (this.size = t.size), (this.sizeAttenuation = t.sizeAttenuation), this;
					}
				}
				Zs.prototype.isPointsMaterial = !0;
				const Ks = new Me(),
					Js = new we(),
					Qs = new fe(),
					$s = new Xt();
				class to extends Ye {
					constructor(t = new Ln(), e = new Zs()) {
						super(), (this.type = "Points"), (this.geometry = t), (this.material = e), this.updateMorphTargets();
					}
					copy(t) {
						return super.copy(t), (this.material = t.material), (this.geometry = t.geometry), this;
					}
					raycast(t, e) {
						const n = this.geometry,
							i = this.matrixWorld,
							r = t.params.Points.threshold,
							a = n.drawRange;
						if ((null === n.boundingSphere && n.computeBoundingSphere(), Qs.copy(n.boundingSphere), Qs.applyMatrix4(i), (Qs.radius += r), !1 === t.ray.intersectsSphere(Qs))) return;
						Ks.copy(i).invert(), Js.copy(t.ray).applyMatrix4(Ks);
						const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
							o = s * s;
						if (n.isBufferGeometry) {
							const r = n.index,
								s = n.attributes.position;
							if (null !== r) {
								for (let n = Math.max(0, a.start), l = Math.min(r.count, a.start + a.count); n < l; n++) {
									const a = r.getX(n);
									$s.fromBufferAttribute(s, a), eo($s, a, o, i, t, e, this);
								}
							} else {
								for (let n = Math.max(0, a.start), r = Math.min(s.count, a.start + a.count); n < r; n++) $s.fromBufferAttribute(s, n), eo($s, n, o, i, t, e, this);
							}
						} else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
					}
					updateMorphTargets() {
						const t = this.geometry;
						if (t.isBufferGeometry) {
							const e = t.morphAttributes,
								n = Object.keys(e);
							if (n.length > 0) {
								const t = e[n[0]];
								if (void 0 !== t) {
									(this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
									for (let e = 0, n = t.length; e < n; e++) {
										const n = t[e].name || String(e);
										this.morphTargetInfluences.push(0), (this.morphTargetDictionary[n] = e);
									}
								}
							}
						} else {
							const e = t.morphTargets;
							void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
						}
					}
				}
				function eo(t, e, n, i, r, a, s) {
					const o = Js.distanceSqToPoint(t);
					if (o < n) {
						const n = new Xt();
						Js.closestPointToPoint(t, n), n.applyMatrix4(i);
						const l = r.ray.origin.distanceTo(n);
						if (l < r.near || l > r.far) return;
						a.push({ distance: l, distanceToRay: Math.sqrt(o), point: n, index: e, face: null, object: s });
					}
				}
				to.prototype.isPoints = !0;
				(class extends Ft {
					constructor(t, e, n, i, r, a, s, o, l) {
						super(t, e, n, i, r, a, s, o, l), (this.format = void 0 !== s ? s : tt), (this.minFilter = void 0 !== a ? a : X), (this.magFilter = void 0 !== r ? r : X), (this.generateMipmaps = !1);
						const c = this;
						"requestVideoFrameCallback" in t &&
							t.requestVideoFrameCallback(function e() {
								(c.needsUpdate = !0), t.requestVideoFrameCallback(e);
							});
					}
					clone() {
						return new this.constructor(this.image).copy(this);
					}
					update() {
						const t = this.image;
						!1 === "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
					}
				}.prototype.isVideoTexture = !0);
				class no extends Ft {
					constructor(t, e, n, i, r, a, s, o, l, c, u, h) {
						super(null, a, s, o, l, c, i, r, u, h), (this.image = { width: e, height: n }), (this.mipmaps = t), (this.flipY = !1), (this.generateMipmaps = !1);
					}
				}
				no.prototype.isCompressedTexture = !0;
				(class extends Ft {
					constructor(t, e, n, i, r, a, s, o, l) {
						super(t, e, n, i, r, a, s, o, l), (this.needsUpdate = !0);
					}
				}.prototype.isCanvasTexture = !0);
				(class extends Ft {
					constructor(t, e, n, i, r, a, s, o, l, c) {
						if ((c = void 0 !== c ? c : nt) !== nt && c !== it) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
						void 0 === n && c === nt && (n = Z), void 0 === n && c === it && (n = $), super(null, i, r, a, s, o, c, n, l), (this.image = { width: t, height: e }), (this.magFilter = void 0 !== s ? s : G), (this.minFilter = void 0 !== o ? o : G), (this.flipY = !1), (this.generateMipmaps = !1);
					}
				}.prototype.isDepthTexture = !0);
				class io extends Ln {
					constructor(t = 1, e = 8, n = 0, i = 2 * Math.PI) {
						super(), (this.type = "CircleGeometry"), (this.parameters = { radius: t, segments: e, thetaStart: n, thetaLength: i }), (e = Math.max(3, e));
						const r = [],
							a = [],
							s = [],
							o = [],
							l = new Xt(),
							c = new Ot();
						a.push(0, 0, 0), s.push(0, 0, 1), o.push(0.5, 0.5);
						for (let r = 0, u = 3; r <= e; r++, u += 3) {
							const h = n + (r / e) * i;
							(l.x = t * Math.cos(h)), (l.y = t * Math.sin(h)), a.push(l.x, l.y, l.z), s.push(0, 0, 1), (c.x = (a[u] / t + 1) / 2), (c.y = (a[u + 1] / t + 1) / 2), o.push(c.x, c.y);
						}
						for (let t = 1; t <= e; t++) r.push(t, t + 1, 0);
						this.setIndex(r), this.setAttribute("position", new wn(a, 3)), this.setAttribute("normal", new wn(s, 3)), this.setAttribute("uv", new wn(o, 2));
					}
					static fromJSON(t) {
						return new io(t.radius, t.segments, t.thetaStart, t.thetaLength);
					}
				}
				class ro extends Ln {
					constructor(t = 1, e = 1, n = 1, i = 8, r = 1, a = !1, s = 0, o = 2 * Math.PI) {
						super(), (this.type = "CylinderGeometry"), (this.parameters = { radiusTop: t, radiusBottom: e, height: n, radialSegments: i, heightSegments: r, openEnded: a, thetaStart: s, thetaLength: o });
						const l = this;
						(i = Math.floor(i)), (r = Math.floor(r));
						const c = [],
							u = [],
							h = [],
							d = [];
						let p = 0;
						const f = [],
							m = n / 2;
						let v = 0;
						function g(n) {
							const r = p,
								a = new Ot(),
								f = new Xt();
							let g = 0;
							const b = !0 === n ? t : e,
								x = !0 === n ? 1 : -1;
							for (let t = 1; t <= i; t++) u.push(0, m * x, 0), h.push(0, x, 0), d.push(0.5, 0.5), p++;
							const y = p;
							for (let t = 0; t <= i; t++) {
								const e = (t / i) * o + s,
									n = Math.cos(e),
									r = Math.sin(e);
								(f.x = b * r), (f.y = m * x), (f.z = b * n), u.push(f.x, f.y, f.z), h.push(0, x, 0), (a.x = 0.5 * n + 0.5), (a.y = 0.5 * r * x + 0.5), d.push(a.x, a.y), p++;
							}
							for (let t = 0; t < i; t++) {
								const e = r + t,
									i = y + t;
								!0 === n ? c.push(i, i + 1, e) : c.push(i + 1, i, e), (g += 3);
							}
							l.addGroup(v, g, !0 === n ? 1 : 2), (v += g);
						}
						!(function () {
							const a = new Xt(),
								g = new Xt();
							let b = 0;
							const x = (e - t) / n;
							for (let l = 0; l <= r; l++) {
								const c = [],
									v = l / r,
									b = v * (e - t) + t;
								for (let t = 0; t <= i; t++) {
									const e = t / i,
										r = e * o + s,
										l = Math.sin(r),
										f = Math.cos(r);
									(g.x = b * l), (g.y = -v * n + m), (g.z = b * f), u.push(g.x, g.y, g.z), a.set(l, x, f).normalize(), h.push(a.x, a.y, a.z), d.push(e, 1 - v), c.push(p++);
								}
								f.push(c);
							}
							for (let t = 0; t < i; t++)
								for (let e = 0; e < r; e++) {
									const n = f[e][t],
										i = f[e + 1][t],
										r = f[e + 1][t + 1],
										a = f[e][t + 1];
									c.push(n, i, a), c.push(i, r, a), (b += 6);
								}
							l.addGroup(v, b, 0), (v += b);
						})(),
							!1 === a && (t > 0 && g(!0), e > 0 && g(!1)),
							this.setIndex(c),
							this.setAttribute("position", new wn(u, 3)),
							this.setAttribute("normal", new wn(h, 3)),
							this.setAttribute("uv", new wn(d, 2));
					}
					static fromJSON(t) {
						return new ro(t.radiusTop, t.radiusBottom, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength);
					}
				}
				new Xt(), new Xt(), new Xt(), new sn();
				class ao {
					constructor() {
						(this.type = "Curve"), (this.arcLengthDivisions = 200);
					}
					getPoint() {
						return console.warn("THREE.Curve: .getPoint() not implemented."), null;
					}
					getPointAt(t, e) {
						const n = this.getUtoTmapping(t);
						return this.getPoint(n, e);
					}
					getPoints(t = 5) {
						const e = [];
						for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
						return e;
					}
					getSpacedPoints(t = 5) {
						const e = [];
						for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
						return e;
					}
					getLength() {
						const t = this.getLengths();
						return t[t.length - 1];
					}
					getLengths(t = this.arcLengthDivisions) {
						if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
						this.needsUpdate = !1;
						const e = [];
						let n,
							i = this.getPoint(0),
							r = 0;
						e.push(0);
						for (let a = 1; a <= t; a++) (n = this.getPoint(a / t)), (r += n.distanceTo(i)), e.push(r), (i = n);
						return (this.cacheArcLengths = e), e;
					}
					updateArcLengths() {
						(this.needsUpdate = !0), this.getLengths();
					}
					getUtoTmapping(t, e) {
						const n = this.getLengths();
						let i = 0;
						const r = n.length;
						let a;
						a = e || t * n[r - 1];
						let s,
							o = 0,
							l = r - 1;
						for (; o <= l; )
							if (((i = Math.floor(o + (l - o) / 2)), (s = n[i] - a), s < 0)) o = i + 1;
							else {
								if (!(s > 0)) {
									l = i;
									break;
								}
								l = i - 1;
							}
						if (((i = l), n[i] === a)) return i / (r - 1);
						const c = n[i];
						return (i + (a - c) / (n[i + 1] - c)) / (r - 1);
					}
					getTangent(t, e) {
						const n = 1e-4;
						let i = t - n,
							r = t + n;
						i < 0 && (i = 0), r > 1 && (r = 1);
						const a = this.getPoint(i),
							s = this.getPoint(r),
							o = e || (a.isVector2 ? new Ot() : new Xt());
						return o.copy(s).sub(a).normalize(), o;
					}
					getTangentAt(t, e) {
						const n = this.getUtoTmapping(t);
						return this.getTangent(n, e);
					}
					computeFrenetFrames(t, e) {
						const n = new Xt(),
							i = [],
							r = [],
							a = [],
							s = new Xt(),
							o = new Me();
						for (let e = 0; e <= t; e++) {
							const n = e / t;
							i[e] = this.getTangentAt(n, new Xt());
						}
						(r[0] = new Xt()), (a[0] = new Xt());
						let l = Number.MAX_VALUE;
						const c = Math.abs(i[0].x),
							u = Math.abs(i[0].y),
							h = Math.abs(i[0].z);
						c <= l && ((l = c), n.set(1, 0, 0)), u <= l && ((l = u), n.set(0, 1, 0)), h <= l && n.set(0, 0, 1), s.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], s), a[0].crossVectors(i[0], r[0]);
						for (let e = 1; e <= t; e++) {
							if (((r[e] = r[e - 1].clone()), (a[e] = a[e - 1].clone()), s.crossVectors(i[e - 1], i[e]), s.length() > Number.EPSILON)) {
								s.normalize();
								const t = Math.acos(Et(i[e - 1].dot(i[e]), -1, 1));
								r[e].applyMatrix4(o.makeRotationAxis(s, t));
							}
							a[e].crossVectors(i[e], r[e]);
						}
						if (!0 === e) {
							let e = Math.acos(Et(r[0].dot(r[t]), -1, 1));
							(e /= t), i[0].dot(s.crossVectors(r[0], r[t])) > 0 && (e = -e);
							for (let n = 1; n <= t; n++) r[n].applyMatrix4(o.makeRotationAxis(i[n], e * n)), a[n].crossVectors(i[n], r[n]);
						}
						return { tangents: i, normals: r, binormals: a };
					}
					clone() {
						return new this.constructor().copy(this);
					}
					copy(t) {
						return (this.arcLengthDivisions = t.arcLengthDivisions), this;
					}
					toJSON() {
						const t = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } };
						return (t.arcLengthDivisions = this.arcLengthDivisions), (t.type = this.type), t;
					}
					fromJSON(t) {
						return (this.arcLengthDivisions = t.arcLengthDivisions), this;
					}
				}
				class so extends ao {
					constructor(t = 0, e = 0, n = 1, i = 1, r = 0, a = 2 * Math.PI, s = !1, o = 0) {
						super(), (this.type = "EllipseCurve"), (this.aX = t), (this.aY = e), (this.xRadius = n), (this.yRadius = i), (this.aStartAngle = r), (this.aEndAngle = a), (this.aClockwise = s), (this.aRotation = o);
					}
					getPoint(t, e) {
						const n = e || new Ot(),
							i = 2 * Math.PI;
						let r = this.aEndAngle - this.aStartAngle;
						const a = Math.abs(r) < Number.EPSILON;
						for (; r < 0; ) r += i;
						for (; r > i; ) r -= i;
						r < Number.EPSILON && (r = a ? 0 : i), !0 !== this.aClockwise || a || (r === i ? (r = -i) : (r -= i));
						const s = this.aStartAngle + t * r;
						let o = this.aX + this.xRadius * Math.cos(s),
							l = this.aY + this.yRadius * Math.sin(s);
						if (0 !== this.aRotation) {
							const t = Math.cos(this.aRotation),
								e = Math.sin(this.aRotation),
								n = o - this.aX,
								i = l - this.aY;
							(o = n * t - i * e + this.aX), (l = n * e + i * t + this.aY);
						}
						return n.set(o, l);
					}
					copy(t) {
						return super.copy(t), (this.aX = t.aX), (this.aY = t.aY), (this.xRadius = t.xRadius), (this.yRadius = t.yRadius), (this.aStartAngle = t.aStartAngle), (this.aEndAngle = t.aEndAngle), (this.aClockwise = t.aClockwise), (this.aRotation = t.aRotation), this;
					}
					toJSON() {
						const t = super.toJSON();
						return (t.aX = this.aX), (t.aY = this.aY), (t.xRadius = this.xRadius), (t.yRadius = this.yRadius), (t.aStartAngle = this.aStartAngle), (t.aEndAngle = this.aEndAngle), (t.aClockwise = this.aClockwise), (t.aRotation = this.aRotation), t;
					}
					fromJSON(t) {
						return super.fromJSON(t), (this.aX = t.aX), (this.aY = t.aY), (this.xRadius = t.xRadius), (this.yRadius = t.yRadius), (this.aStartAngle = t.aStartAngle), (this.aEndAngle = t.aEndAngle), (this.aClockwise = t.aClockwise), (this.aRotation = t.aRotation), this;
					}
				}
				so.prototype.isEllipseCurve = !0;
				class oo extends so {
					constructor(t, e, n, i, r, a) {
						super(t, e, n, n, i, r, a), (this.type = "ArcCurve");
					}
				}
				function lo() {
					let t = 0,
						e = 0,
						n = 0,
						i = 0;
					function r(r, a, s, o) {
						(t = r), (e = s), (n = -3 * r + 3 * a - 2 * s - o), (i = 2 * r - 2 * a + s + o);
					}
					return {
						initCatmullRom: function (t, e, n, i, a) {
							r(e, n, a * (n - t), a * (i - e));
						},
						initNonuniformCatmullRom: function (t, e, n, i, a, s, o) {
							let l = (e - t) / a - (n - t) / (a + s) + (n - e) / s,
								c = (n - e) / s - (i - e) / (s + o) + (i - n) / o;
							(l *= s), (c *= s), r(e, n, l, c);
						},
						calc: function (r) {
							const a = r * r;
							return t + e * r + n * a + i * (a * r);
						},
					};
				}
				oo.prototype.isArcCurve = !0;
				const co = new Xt(),
					uo = new lo(),
					ho = new lo(),
					po = new lo();
				class fo extends ao {
					constructor(t = [], e = !1, n = "centripetal", i = 0.5) {
						super(), (this.type = "CatmullRomCurve3"), (this.points = t), (this.closed = e), (this.curveType = n), (this.tension = i);
					}
					getPoint(t, e = new Xt()) {
						const n = e,
							i = this.points,
							r = i.length,
							a = (r - (this.closed ? 0 : 1)) * t;
						let s,
							o,
							l = Math.floor(a),
							c = a - l;
						this.closed ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r) : 0 === c && l === r - 1 && ((l = r - 2), (c = 1)), this.closed || l > 0 ? (s = i[(l - 1) % r]) : (co.subVectors(i[0], i[1]).add(i[0]), (s = co));
						const u = i[l % r],
							h = i[(l + 1) % r];
						if ((this.closed || l + 2 < r ? (o = i[(l + 2) % r]) : (co.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (o = co)), "centripetal" === this.curveType || "chordal" === this.curveType)) {
							const t = "chordal" === this.curveType ? 0.5 : 0.25;
							let e = Math.pow(s.distanceToSquared(u), t),
								n = Math.pow(u.distanceToSquared(h), t),
								i = Math.pow(h.distanceToSquared(o), t);
							n < 1e-4 && (n = 1), e < 1e-4 && (e = n), i < 1e-4 && (i = n), uo.initNonuniformCatmullRom(s.x, u.x, h.x, o.x, e, n, i), ho.initNonuniformCatmullRom(s.y, u.y, h.y, o.y, e, n, i), po.initNonuniformCatmullRom(s.z, u.z, h.z, o.z, e, n, i);
						} else "catmullrom" === this.curveType && (uo.initCatmullRom(s.x, u.x, h.x, o.x, this.tension), ho.initCatmullRom(s.y, u.y, h.y, o.y, this.tension), po.initCatmullRom(s.z, u.z, h.z, o.z, this.tension));
						return n.set(uo.calc(c), ho.calc(c), po.calc(c)), n;
					}
					copy(t) {
						super.copy(t), (this.points = []);
						for (let e = 0, n = t.points.length; e < n; e++) {
							const n = t.points[e];
							this.points.push(n.clone());
						}
						return (this.closed = t.closed), (this.curveType = t.curveType), (this.tension = t.tension), this;
					}
					toJSON() {
						const t = super.toJSON();
						t.points = [];
						for (let e = 0, n = this.points.length; e < n; e++) {
							const n = this.points[e];
							t.points.push(n.toArray());
						}
						return (t.closed = this.closed), (t.curveType = this.curveType), (t.tension = this.tension), t;
					}
					fromJSON(t) {
						super.fromJSON(t), (this.points = []);
						for (let e = 0, n = t.points.length; e < n; e++) {
							const n = t.points[e];
							this.points.push(new Xt().fromArray(n));
						}
						return (this.closed = t.closed), (this.curveType = t.curveType), (this.tension = t.tension), this;
					}
				}
				function mo(t, e, n, i, r) {
					const a = 0.5 * (i - e),
						s = 0.5 * (r - n),
						o = t * t;
					return (2 * n - 2 * i + a + s) * (t * o) + (-3 * n + 3 * i - 2 * a - s) * o + a * t + n;
				}
				function vo(t, e, n, i) {
					return (
						(function (t, e) {
							const n = 1 - t;
							return n * n * e;
						})(t, e) +
						(function (t, e) {
							return 2 * (1 - t) * t * e;
						})(t, n) +
						(function (t, e) {
							return t * t * e;
						})(t, i)
					);
				}
				function go(t, e, n, i, r) {
					return (
						(function (t, e) {
							const n = 1 - t;
							return n * n * n * e;
						})(t, e) +
						(function (t, e) {
							const n = 1 - t;
							return 3 * n * n * t * e;
						})(t, n) +
						(function (t, e) {
							return 3 * (1 - t) * t * t * e;
						})(t, i) +
						(function (t, e) {
							return t * t * t * e;
						})(t, r)
					);
				}
				fo.prototype.isCatmullRomCurve3 = !0;
				class bo extends ao {
					constructor(t = new Ot(), e = new Ot(), n = new Ot(), i = new Ot()) {
						super(), (this.type = "CubicBezierCurve"), (this.v0 = t), (this.v1 = e), (this.v2 = n), (this.v3 = i);
					}
					getPoint(t, e = new Ot()) {
						const n = e,
							i = this.v0,
							r = this.v1,
							a = this.v2,
							s = this.v3;
						return n.set(go(t, i.x, r.x, a.x, s.x), go(t, i.y, r.y, a.y, s.y)), n;
					}
					copy(t) {
						return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
					}
					toJSON() {
						const t = super.toJSON();
						return (t.v0 = this.v0.toArray()), (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), (t.v3 = this.v3.toArray()), t;
					}
					fromJSON(t) {
						return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
					}
				}
				bo.prototype.isCubicBezierCurve = !0;
				class xo extends ao {
					constructor(t = new Xt(), e = new Xt(), n = new Xt(), i = new Xt()) {
						super(), (this.type = "CubicBezierCurve3"), (this.v0 = t), (this.v1 = e), (this.v2 = n), (this.v3 = i);
					}
					getPoint(t, e = new Xt()) {
						const n = e,
							i = this.v0,
							r = this.v1,
							a = this.v2,
							s = this.v3;
						return n.set(go(t, i.x, r.x, a.x, s.x), go(t, i.y, r.y, a.y, s.y), go(t, i.z, r.z, a.z, s.z)), n;
					}
					copy(t) {
						return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
					}
					toJSON() {
						const t = super.toJSON();
						return (t.v0 = this.v0.toArray()), (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), (t.v3 = this.v3.toArray()), t;
					}
					fromJSON(t) {
						return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
					}
				}
				xo.prototype.isCubicBezierCurve3 = !0;
				class yo extends ao {
					constructor(t = new Ot(), e = new Ot()) {
						super(), (this.type = "LineCurve"), (this.v1 = t), (this.v2 = e);
					}
					getPoint(t, e = new Ot()) {
						const n = e;
						return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n;
					}
					getPointAt(t, e) {
						return this.getPoint(t, e);
					}
					getTangent(t, e) {
						const n = e || new Ot();
						return n.copy(this.v2).sub(this.v1).normalize(), n;
					}
					copy(t) {
						return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
					}
					toJSON() {
						const t = super.toJSON();
						return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
					}
					fromJSON(t) {
						return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
					}
				}
				yo.prototype.isLineCurve = !0;
				class _o extends ao {
					constructor(t = new Ot(), e = new Ot(), n = new Ot()) {
						super(), (this.type = "QuadraticBezierCurve"), (this.v0 = t), (this.v1 = e), (this.v2 = n);
					}
					getPoint(t, e = new Ot()) {
						const n = e,
							i = this.v0,
							r = this.v1,
							a = this.v2;
						return n.set(vo(t, i.x, r.x, a.x), vo(t, i.y, r.y, a.y)), n;
					}
					copy(t) {
						return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
					}
					toJSON() {
						const t = super.toJSON();
						return (t.v0 = this.v0.toArray()), (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
					}
					fromJSON(t) {
						return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
					}
				}
				_o.prototype.isQuadraticBezierCurve = !0;
				class wo extends ao {
					constructor(t = new Xt(), e = new Xt(), n = new Xt()) {
						super(), (this.type = "QuadraticBezierCurve3"), (this.v0 = t), (this.v1 = e), (this.v2 = n);
					}
					getPoint(t, e = new Xt()) {
						const n = e,
							i = this.v0,
							r = this.v1,
							a = this.v2;
						return n.set(vo(t, i.x, r.x, a.x), vo(t, i.y, r.y, a.y), vo(t, i.z, r.z, a.z)), n;
					}
					copy(t) {
						return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
					}
					toJSON() {
						const t = super.toJSON();
						return (t.v0 = this.v0.toArray()), (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
					}
					fromJSON(t) {
						return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
					}
				}
				wo.prototype.isQuadraticBezierCurve3 = !0;
				class Mo extends ao {
					constructor(t = []) {
						super(), (this.type = "SplineCurve"), (this.points = t);
					}
					getPoint(t, e = new Ot()) {
						const n = e,
							i = this.points,
							r = (i.length - 1) * t,
							a = Math.floor(r),
							s = r - a,
							o = i[0 === a ? a : a - 1],
							l = i[a],
							c = i[a > i.length - 2 ? i.length - 1 : a + 1],
							u = i[a > i.length - 3 ? i.length - 1 : a + 2];
						return n.set(mo(s, o.x, l.x, c.x, u.x), mo(s, o.y, l.y, c.y, u.y)), n;
					}
					copy(t) {
						super.copy(t), (this.points = []);
						for (let e = 0, n = t.points.length; e < n; e++) {
							const n = t.points[e];
							this.points.push(n.clone());
						}
						return this;
					}
					toJSON() {
						const t = super.toJSON();
						t.points = [];
						for (let e = 0, n = this.points.length; e < n; e++) {
							const n = this.points[e];
							t.points.push(n.toArray());
						}
						return t;
					}
					fromJSON(t) {
						super.fromJSON(t), (this.points = []);
						for (let e = 0, n = t.points.length; e < n; e++) {
							const n = t.points[e];
							this.points.push(new Ot().fromArray(n));
						}
						return this;
					}
				}
				Mo.prototype.isSplineCurve = !0;
				var So = Object.freeze({
					__proto__: null,
					ArcCurve: oo,
					CatmullRomCurve3: fo,
					CubicBezierCurve: bo,
					CubicBezierCurve3: xo,
					EllipseCurve: so,
					LineCurve: yo,
					LineCurve3: class extends ao {
						constructor(t = new Xt(), e = new Xt()) {
							super(), (this.type = "LineCurve3"), (this.isLineCurve3 = !0), (this.v1 = t), (this.v2 = e);
						}
						getPoint(t, e = new Xt()) {
							const n = e;
							return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n;
						}
						getPointAt(t, e) {
							return this.getPoint(t, e);
						}
						copy(t) {
							return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
						}
						toJSON() {
							const t = super.toJSON();
							return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
						}
						fromJSON(t) {
							return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
						}
					},
					QuadraticBezierCurve: _o,
					QuadraticBezierCurve3: wo,
					SplineCurve: Mo,
				});
				class To extends ao {
					constructor() {
						super(), (this.type = "CurvePath"), (this.curves = []), (this.autoClose = !1);
					}
					add(t) {
						this.curves.push(t);
					}
					closePath() {
						const t = this.curves[0].getPoint(0),
							e = this.curves[this.curves.length - 1].getPoint(1);
						t.equals(e) || this.curves.push(new yo(e, t));
					}
					getPoint(t, e) {
						const n = t * this.getLength(),
							i = this.getCurveLengths();
						let r = 0;
						for (; r < i.length; ) {
							if (i[r] >= n) {
								const t = i[r] - n,
									a = this.curves[r],
									s = a.getLength(),
									o = 0 === s ? 0 : 1 - t / s;
								return a.getPointAt(o, e);
							}
							r++;
						}
						return null;
					}
					getLength() {
						const t = this.getCurveLengths();
						return t[t.length - 1];
					}
					updateArcLengths() {
						(this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
					}
					getCurveLengths() {
						if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
						const t = [];
						let e = 0;
						for (let n = 0, i = this.curves.length; n < i; n++) (e += this.curves[n].getLength()), t.push(e);
						return (this.cacheLengths = t), t;
					}
					getSpacedPoints(t = 40) {
						const e = [];
						for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
						return this.autoClose && e.push(e[0]), e;
					}
					getPoints(t = 12) {
						const e = [];
						let n;
						for (let i = 0, r = this.curves; i < r.length; i++) {
							const a = r[i],
								s = a && a.isEllipseCurve ? 2 * t : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? t * a.points.length : t,
								o = a.getPoints(s);
							for (let t = 0; t < o.length; t++) {
								const i = o[t];
								(n && n.equals(i)) || (e.push(i), (n = i));
							}
						}
						return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e;
					}
					copy(t) {
						super.copy(t), (this.curves = []);
						for (let e = 0, n = t.curves.length; e < n; e++) {
							const n = t.curves[e];
							this.curves.push(n.clone());
						}
						return (this.autoClose = t.autoClose), this;
					}
					toJSON() {
						const t = super.toJSON();
						(t.autoClose = this.autoClose), (t.curves = []);
						for (let e = 0, n = this.curves.length; e < n; e++) {
							const n = this.curves[e];
							t.curves.push(n.toJSON());
						}
						return t;
					}
					fromJSON(t) {
						super.fromJSON(t), (this.autoClose = t.autoClose), (this.curves = []);
						for (let e = 0, n = t.curves.length; e < n; e++) {
							const n = t.curves[e];
							this.curves.push(new So[n.type]().fromJSON(n));
						}
						return this;
					}
				}
				class Eo extends To {
					constructor(t) {
						super(), (this.type = "Path"), (this.currentPoint = new Ot()), t && this.setFromPoints(t);
					}
					setFromPoints(t) {
						this.moveTo(t[0].x, t[0].y);
						for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
						return this;
					}
					moveTo(t, e) {
						return this.currentPoint.set(t, e), this;
					}
					lineTo(t, e) {
						const n = new yo(this.currentPoint.clone(), new Ot(t, e));
						return this.curves.push(n), this.currentPoint.set(t, e), this;
					}
					quadraticCurveTo(t, e, n, i) {
						const r = new _o(this.currentPoint.clone(), new Ot(t, e), new Ot(n, i));
						return this.curves.push(r), this.currentPoint.set(n, i), this;
					}
					bezierCurveTo(t, e, n, i, r, a) {
						const s = new bo(this.currentPoint.clone(), new Ot(t, e), new Ot(n, i), new Ot(r, a));
						return this.curves.push(s), this.currentPoint.set(r, a), this;
					}
					splineThru(t) {
						const e = [this.currentPoint.clone()].concat(t),
							n = new Mo(e);
						return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this;
					}
					arc(t, e, n, i, r, a) {
						const s = this.currentPoint.x,
							o = this.currentPoint.y;
						return this.absarc(t + s, e + o, n, i, r, a), this;
					}
					absarc(t, e, n, i, r, a) {
						return this.absellipse(t, e, n, n, i, r, a), this;
					}
					ellipse(t, e, n, i, r, a, s, o) {
						const l = this.currentPoint.x,
							c = this.currentPoint.y;
						return this.absellipse(t + l, e + c, n, i, r, a, s, o), this;
					}
					absellipse(t, e, n, i, r, a, s, o) {
						const l = new so(t, e, n, i, r, a, s, o);
						if (this.curves.length > 0) {
							const t = l.getPoint(0);
							t.equals(this.currentPoint) || this.lineTo(t.x, t.y);
						}
						this.curves.push(l);
						const c = l.getPoint(1);
						return this.currentPoint.copy(c), this;
					}
					copy(t) {
						return super.copy(t), this.currentPoint.copy(t.currentPoint), this;
					}
					toJSON() {
						const t = super.toJSON();
						return (t.currentPoint = this.currentPoint.toArray()), t;
					}
					fromJSON(t) {
						return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this;
					}
				}
				class Co extends Eo {
					constructor(t) {
						super(t), (this.uuid = Tt()), (this.type = "Shape"), (this.holes = []);
					}
					getPointsHoles(t) {
						const e = [];
						for (let n = 0, i = this.holes.length; n < i; n++) e[n] = this.holes[n].getPoints(t);
						return e;
					}
					extractPoints(t) {
						return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
					}
					copy(t) {
						super.copy(t), (this.holes = []);
						for (let e = 0, n = t.holes.length; e < n; e++) {
							const n = t.holes[e];
							this.holes.push(n.clone());
						}
						return this;
					}
					toJSON() {
						const t = super.toJSON();
						(t.uuid = this.uuid), (t.holes = []);
						for (let e = 0, n = this.holes.length; e < n; e++) {
							const n = this.holes[e];
							t.holes.push(n.toJSON());
						}
						return t;
					}
					fromJSON(t) {
						super.fromJSON(t), (this.uuid = t.uuid), (this.holes = []);
						for (let e = 0, n = t.holes.length; e < n; e++) {
							const n = t.holes[e];
							this.holes.push(new Eo().fromJSON(n));
						}
						return this;
					}
				}
				const Po = function (t, e, n = 2) {
					const i = e && e.length,
						r = i ? e[0] * n : t.length;
					let a = Ao(t, 0, r, n, !0);
					const s = [];
					if (!a || a.next === a.prev) return s;
					let o, l, c, u, h, d, p;
					if (
						(i &&
							(a = (function (t, e, n, i) {
								const r = [];
								let a, s, o, l, c;
								for (a = 0, s = e.length; a < s; a++) (o = e[a] * i), (l = a < s - 1 ? e[a + 1] * i : t.length), (c = Ao(t, o, l, i, !1)), c === c.next && (c.steiner = !0), r.push(Fo(c));
								for (r.sort(ko), a = 0; a < r.length; a++) No(r[a], n), (n = Lo(n, n.next));
								return n;
							})(t, e, a, n)),
						t.length > 80 * n)
					) {
						(o = c = t[0]), (l = u = t[1]);
						for (let e = n; e < r; e += n) (h = t[e]), (d = t[e + 1]), h < o && (o = h), d < l && (l = d), h > c && (c = h), d > u && (u = d);
						(p = Math.max(c - o, u - l)), (p = 0 !== p ? 1 / p : 0);
					}
					return Ro(a, s, n, o, l, p), s;
				};
				function Ao(t, e, n, i, r) {
					let a, s;
					if (
						r ===
						(function (t, e, n, i) {
							let r = 0;
							for (let a = e, s = n - i; a < n; a += i) (r += (t[s] - t[a]) * (t[a + 1] + t[s + 1])), (s = a);
							return r;
						})(t, e, n, i) >
							0
					)
						for (a = e; a < n; a += i) s = Ko(a, t[a], t[a + 1], s);
					else for (a = n - i; a >= e; a -= i) s = Ko(a, t[a], t[a + 1], s);
					return s && Wo(s, s.next) && (Jo(s), (s = s.next)), s;
				}
				function Lo(t, e) {
					if (!t) return t;
					e || (e = t);
					let n,
						i = t;
					do {
						if (((n = !1), i.steiner || (!Wo(i, i.next) && 0 !== Go(i.prev, i, i.next)))) i = i.next;
						else {
							if ((Jo(i), (i = e = i.prev), i === i.next)) break;
							n = !0;
						}
					} while (n || i !== e);
					return e;
				}
				function Ro(t, e, n, i, r, a, s) {
					if (!t) return;
					!s &&
						a &&
						(function (t, e, n, i) {
							let r = t;
							do {
								null === r.z && (r.z = Bo(r.x, r.y, e, n, i)), (r.prevZ = r.prev), (r.nextZ = r.next), (r = r.next);
							} while (r !== t);
							(r.prevZ.nextZ = null),
								(r.prevZ = null),
								(function (t) {
									let e,
										n,
										i,
										r,
										a,
										s,
										o,
										l,
										c = 1;
									do {
										for (n = t, t = null, a = null, s = 0; n; ) {
											for (s++, i = n, o = 0, e = 0; e < c && (o++, (i = i.nextZ), i); e++);
											for (l = c; o > 0 || (l > 0 && i); ) 0 !== o && (0 === l || !i || n.z <= i.z) ? ((r = n), (n = n.nextZ), o--) : ((r = i), (i = i.nextZ), l--), a ? (a.nextZ = r) : (t = r), (r.prevZ = a), (a = r);
											n = i;
										}
										(a.nextZ = null), (c *= 2);
									} while (s > 1);
								})(r);
						})(t, i, r, a);
					let o,
						l,
						c = t;
					for (; t.prev !== t.next; )
						if (((o = t.prev), (l = t.next), a ? Oo(t, i, r, a) : Do(t))) e.push(o.i / n), e.push(t.i / n), e.push(l.i / n), Jo(t), (t = l.next), (c = l.next);
						else if ((t = l) === c) {
							s ? (1 === s ? Ro((t = zo(Lo(t), e, n)), e, n, i, r, a, 2) : 2 === s && Io(t, e, n, i, r, a)) : Ro(Lo(t), e, n, i, r, a, 1);
							break;
						}
				}
				function Do(t) {
					const e = t.prev,
						n = t,
						i = t.next;
					if (Go(e, n, i) >= 0) return !1;
					let r = t.next.next;
					for (; r !== t.prev; ) {
						if (Uo(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && Go(r.prev, r, r.next) >= 0) return !1;
						r = r.next;
					}
					return !0;
				}
				function Oo(t, e, n, i) {
					const r = t.prev,
						a = t,
						s = t.next;
					if (Go(r, a, s) >= 0) return !1;
					const o = r.x < a.x ? (r.x < s.x ? r.x : s.x) : a.x < s.x ? a.x : s.x,
						l = r.y < a.y ? (r.y < s.y ? r.y : s.y) : a.y < s.y ? a.y : s.y,
						c = r.x > a.x ? (r.x > s.x ? r.x : s.x) : a.x > s.x ? a.x : s.x,
						u = r.y > a.y ? (r.y > s.y ? r.y : s.y) : a.y > s.y ? a.y : s.y,
						h = Bo(o, l, e, n, i),
						d = Bo(c, u, e, n, i);
					let p = t.prevZ,
						f = t.nextZ;
					for (; p && p.z >= h && f && f.z <= d; ) {
						if (p !== t.prev && p !== t.next && Uo(r.x, r.y, a.x, a.y, s.x, s.y, p.x, p.y) && Go(p.prev, p, p.next) >= 0) return !1;
						if (((p = p.prevZ), f !== t.prev && f !== t.next && Uo(r.x, r.y, a.x, a.y, s.x, s.y, f.x, f.y) && Go(f.prev, f, f.next) >= 0)) return !1;
						f = f.nextZ;
					}
					for (; p && p.z >= h; ) {
						if (p !== t.prev && p !== t.next && Uo(r.x, r.y, a.x, a.y, s.x, s.y, p.x, p.y) && Go(p.prev, p, p.next) >= 0) return !1;
						p = p.prevZ;
					}
					for (; f && f.z <= d; ) {
						if (f !== t.prev && f !== t.next && Uo(r.x, r.y, a.x, a.y, s.x, s.y, f.x, f.y) && Go(f.prev, f, f.next) >= 0) return !1;
						f = f.nextZ;
					}
					return !0;
				}
				function zo(t, e, n) {
					let i = t;
					do {
						const r = i.prev,
							a = i.next.next;
						!Wo(r, a) && jo(r, i, i.next, a) && Yo(r, a) && Yo(a, r) && (e.push(r.i / n), e.push(i.i / n), e.push(a.i / n), Jo(i), Jo(i.next), (i = t = a)), (i = i.next);
					} while (i !== t);
					return Lo(i);
				}
				function Io(t, e, n, i, r, a) {
					let s = t;
					do {
						let t = s.next.next;
						for (; t !== s.prev; ) {
							if (s.i !== t.i && Ho(s, t)) {
								let o = Zo(s, t);
								return (s = Lo(s, s.next)), (o = Lo(o, o.next)), Ro(s, e, n, i, r, a), void Ro(o, e, n, i, r, a);
							}
							t = t.next;
						}
						s = s.next;
					} while (s !== t);
				}
				function ko(t, e) {
					return t.x - e.x;
				}
				function No(t, e) {
					if (
						(e = (function (t, e) {
							let n = e;
							const i = t.x,
								r = t.y;
							let a,
								s = -1 / 0;
							do {
								if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
									const t = n.x + ((r - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
									if (t <= i && t > s) {
										if (((s = t), t === i)) {
											if (r === n.y) return n;
											if (r === n.next.y) return n.next;
										}
										a = n.x < n.next.x ? n : n.next;
									}
								}
								n = n.next;
							} while (n !== e);
							if (!a) return null;
							if (i === s) return a;
							const o = a,
								l = a.x,
								c = a.y;
							let u,
								h = 1 / 0;
							n = a;
							do {
								i >= n.x && n.x >= l && i !== n.x && Uo(r < c ? i : s, r, l, c, r < c ? s : i, r, n.x, n.y) && ((u = Math.abs(r - n.y) / (i - n.x)), Yo(n, t) && (u < h || (u === h && (n.x > a.x || (n.x === a.x && Vo(a, n))))) && ((a = n), (h = u))), (n = n.next);
							} while (n !== o);
							return a;
						})(t, e))
					) {
						const n = Zo(e, t);
						Lo(e, e.next), Lo(n, n.next);
					}
				}
				function Vo(t, e) {
					return Go(t.prev, t, e.prev) < 0 && Go(e.next, t, t.next) < 0;
				}
				function Bo(t, e, n, i, r) {
					return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | (t << 8))) | (t << 4))) | (t << 2))) | (t << 1))) | ((e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | (e << 8))) | (e << 4))) | (e << 2))) | (e << 1))) << 1);
				}
				function Fo(t) {
					let e = t,
						n = t;
					do {
						(e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next);
					} while (e !== t);
					return n;
				}
				function Uo(t, e, n, i, r, a, s, o) {
					return (r - s) * (e - o) - (t - s) * (a - o) >= 0 && (t - s) * (i - o) - (n - s) * (e - o) >= 0 && (n - s) * (a - o) - (r - s) * (i - o) >= 0;
				}
				function Ho(t, e) {
					return (
						t.next.i !== e.i &&
						t.prev.i !== e.i &&
						!(function (t, e) {
							let n = t;
							do {
								if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && jo(n, n.next, t, e)) return !0;
								n = n.next;
							} while (n !== t);
							return !1;
						})(t, e) &&
						((Yo(t, e) &&
							Yo(e, t) &&
							(function (t, e) {
								let n = t,
									i = !1;
								const r = (t.x + e.x) / 2,
									a = (t.y + e.y) / 2;
								do {
									n.y > a != n.next.y > a && n.next.y !== n.y && r < ((n.next.x - n.x) * (a - n.y)) / (n.next.y - n.y) + n.x && (i = !i), (n = n.next);
								} while (n !== t);
								return i;
							})(t, e) &&
							(Go(t.prev, t, e.prev) || Go(t, e.prev, e))) ||
							(Wo(t, e) && Go(t.prev, t, t.next) > 0 && Go(e.prev, e, e.next) > 0))
					);
				}
				function Go(t, e, n) {
					return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
				}
				function Wo(t, e) {
					return t.x === e.x && t.y === e.y;
				}
				function jo(t, e, n, i) {
					const r = qo(Go(t, e, n)),
						a = qo(Go(t, e, i)),
						s = qo(Go(n, i, t)),
						o = qo(Go(n, i, e));
					return (r !== a && s !== o) || !(0 !== r || !Xo(t, n, e)) || !(0 !== a || !Xo(t, i, e)) || !(0 !== s || !Xo(n, t, i)) || !(0 !== o || !Xo(n, e, i));
				}
				function Xo(t, e, n) {
					return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y);
				}
				function qo(t) {
					return t > 0 ? 1 : t < 0 ? -1 : 0;
				}
				function Yo(t, e) {
					return Go(t.prev, t, t.next) < 0 ? Go(t, e, t.next) >= 0 && Go(t, t.prev, e) >= 0 : Go(t, e, t.prev) < 0 || Go(t, t.next, e) < 0;
				}
				function Zo(t, e) {
					const n = new Qo(t.i, t.x, t.y),
						i = new Qo(e.i, e.x, e.y),
						r = t.next,
						a = e.prev;
					return (t.next = e), (e.prev = t), (n.next = r), (r.prev = n), (i.next = n), (n.prev = i), (a.next = i), (i.prev = a), i;
				}
				function Ko(t, e, n, i) {
					const r = new Qo(t, e, n);
					return i ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r)) : ((r.prev = r), (r.next = r)), r;
				}
				function Jo(t) {
					(t.next.prev = t.prev), (t.prev.next = t.next), t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);
				}
				function Qo(t, e, n) {
					(this.i = t), (this.x = e), (this.y = n), (this.prev = null), (this.next = null), (this.z = null), (this.prevZ = null), (this.nextZ = null), (this.steiner = !1);
				}
				class $o {
					static area(t) {
						const e = t.length;
						let n = 0;
						for (let i = e - 1, r = 0; r < e; i = r++) n += t[i].x * t[r].y - t[r].x * t[i].y;
						return 0.5 * n;
					}
					static isClockWise(t) {
						return $o.area(t) < 0;
					}
					static triangulateShape(t, e) {
						const n = [],
							i = [],
							r = [];
						tl(t), el(n, t);
						let a = t.length;
						e.forEach(tl);
						for (let t = 0; t < e.length; t++) i.push(a), (a += e[t].length), el(n, e[t]);
						const s = Po(n, i);
						for (let t = 0; t < s.length; t += 3) r.push(s.slice(t, t + 3));
						return r;
					}
				}
				function tl(t) {
					const e = t.length;
					e > 2 && t[e - 1].equals(t[0]) && t.pop();
				}
				function el(t, e) {
					for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y);
				}
				class nl extends Ln {
					constructor(t = new Co([new Ot(0.5, 0.5), new Ot(-0.5, 0.5), new Ot(-0.5, -0.5), new Ot(0.5, -0.5)]), e = {}) {
						super(), (this.type = "ExtrudeGeometry"), (this.parameters = { shapes: t, options: e }), (t = Array.isArray(t) ? t : [t]);
						const n = this,
							i = [],
							r = [];
						for (let e = 0, n = t.length; e < n; e++) {
							a(t[e]);
						}
						function a(t) {
							const a = [],
								s = void 0 !== e.curveSegments ? e.curveSegments : 12,
								o = void 0 !== e.steps ? e.steps : 1;
							let l = void 0 !== e.depth ? e.depth : 1,
								c = void 0 === e.bevelEnabled || e.bevelEnabled,
								u = void 0 !== e.bevelThickness ? e.bevelThickness : 0.2,
								h = void 0 !== e.bevelSize ? e.bevelSize : u - 0.1,
								d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
								p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
							const f = e.extrudePath,
								m = void 0 !== e.UVGenerator ? e.UVGenerator : il;
							void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), (l = e.amount));
							let v,
								g,
								b,
								x,
								y,
								_ = !1;
							f && ((v = f.getSpacedPoints(o)), (_ = !0), (c = !1), (g = f.computeFrenetFrames(o, !1)), (b = new Xt()), (x = new Xt()), (y = new Xt())), c || ((p = 0), (u = 0), (h = 0), (d = 0));
							const w = t.extractPoints(s);
							let M = w.shape;
							const S = w.holes;
							if (!$o.isClockWise(M)) {
								M = M.reverse();
								for (let t = 0, e = S.length; t < e; t++) {
									const e = S[t];
									$o.isClockWise(e) && (S[t] = e.reverse());
								}
							}
							const T = $o.triangulateShape(M, S),
								E = M;
							for (let t = 0, e = S.length; t < e; t++) {
								const e = S[t];
								M = M.concat(e);
							}
							function C(t, e, n) {
								return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t);
							}
							const P = M.length,
								A = T.length;
							function L(t, e, n) {
								let i, r, a;
								const s = t.x - e.x,
									o = t.y - e.y,
									l = n.x - t.x,
									c = n.y - t.y,
									u = s * s + o * o,
									h = s * c - o * l;
								if (Math.abs(h) > Number.EPSILON) {
									const h = Math.sqrt(u),
										d = Math.sqrt(l * l + c * c),
										p = e.x - o / h,
										f = e.y + s / h,
										m = ((n.x - c / d - p) * c - (n.y + l / d - f) * l) / (s * c - o * l);
									(i = p + s * m - t.x), (r = f + o * m - t.y);
									const v = i * i + r * r;
									if (v <= 2) return new Ot(i, r);
									a = Math.sqrt(v / 2);
								} else {
									let t = !1;
									s > Number.EPSILON ? l > Number.EPSILON && (t = !0) : s < -Number.EPSILON ? l < -Number.EPSILON && (t = !0) : Math.sign(o) === Math.sign(c) && (t = !0), t ? ((i = -o), (r = s), (a = Math.sqrt(u))) : ((i = s), (r = o), (a = Math.sqrt(u / 2)));
								}
								return new Ot(i / a, r / a);
							}
							const R = [];
							for (let t = 0, e = E.length, n = e - 1, i = t + 1; t < e; t++, n++, i++) n === e && (n = 0), i === e && (i = 0), (R[t] = L(E[t], E[n], E[i]));
							const D = [];
							let O,
								z = R.concat();
							for (let t = 0, e = S.length; t < e; t++) {
								const e = S[t];
								O = [];
								for (let t = 0, n = e.length, i = n - 1, r = t + 1; t < n; t++, i++, r++) i === n && (i = 0), r === n && (r = 0), (O[t] = L(e[t], e[i], e[r]));
								D.push(O), (z = z.concat(O));
							}
							for (let t = 0; t < p; t++) {
								const e = t / p,
									n = u * Math.cos((e * Math.PI) / 2),
									i = h * Math.sin((e * Math.PI) / 2) + d;
								for (let t = 0, e = E.length; t < e; t++) {
									const e = C(E[t], R[t], i);
									N(e.x, e.y, -n);
								}
								for (let t = 0, e = S.length; t < e; t++) {
									const e = S[t];
									O = D[t];
									for (let t = 0, r = e.length; t < r; t++) {
										const r = C(e[t], O[t], i);
										N(r.x, r.y, -n);
									}
								}
							}
							const I = h + d;
							for (let t = 0; t < P; t++) {
								const e = c ? C(M[t], z[t], I) : M[t];
								_ ? (x.copy(g.normals[0]).multiplyScalar(e.x), b.copy(g.binormals[0]).multiplyScalar(e.y), y.copy(v[0]).add(x).add(b), N(y.x, y.y, y.z)) : N(e.x, e.y, 0);
							}
							for (let t = 1; t <= o; t++)
								for (let e = 0; e < P; e++) {
									const n = c ? C(M[e], z[e], I) : M[e];
									_ ? (x.copy(g.normals[t]).multiplyScalar(n.x), b.copy(g.binormals[t]).multiplyScalar(n.y), y.copy(v[t]).add(x).add(b), N(y.x, y.y, y.z)) : N(n.x, n.y, (l / o) * t);
								}
							for (let t = p - 1; t >= 0; t--) {
								const e = t / p,
									n = u * Math.cos((e * Math.PI) / 2),
									i = h * Math.sin((e * Math.PI) / 2) + d;
								for (let t = 0, e = E.length; t < e; t++) {
									const e = C(E[t], R[t], i);
									N(e.x, e.y, l + n);
								}
								for (let t = 0, e = S.length; t < e; t++) {
									const e = S[t];
									O = D[t];
									for (let t = 0, r = e.length; t < r; t++) {
										const r = C(e[t], O[t], i);
										_ ? N(r.x, r.y + v[o - 1].y, v[o - 1].x + n) : N(r.x, r.y, l + n);
									}
								}
							}
							function k(t, e) {
								let n = t.length;
								for (; --n >= 0; ) {
									const i = n;
									let r = n - 1;
									r < 0 && (r = t.length - 1);
									for (let t = 0, n = o + 2 * p; t < n; t++) {
										const n = P * t,
											a = P * (t + 1);
										B(e + i + n, e + r + n, e + r + a, e + i + a);
									}
								}
							}
							function N(t, e, n) {
								a.push(t), a.push(e), a.push(n);
							}
							function V(t, e, r) {
								F(t), F(e), F(r);
								const a = i.length / 3,
									s = m.generateTopUV(n, i, a - 3, a - 2, a - 1);
								U(s[0]), U(s[1]), U(s[2]);
							}
							function B(t, e, r, a) {
								F(t), F(e), F(a), F(e), F(r), F(a);
								const s = i.length / 3,
									o = m.generateSideWallUV(n, i, s - 6, s - 3, s - 2, s - 1);
								U(o[0]), U(o[1]), U(o[3]), U(o[1]), U(o[2]), U(o[3]);
							}
							function F(t) {
								i.push(a[3 * t + 0]), i.push(a[3 * t + 1]), i.push(a[3 * t + 2]);
							}
							function U(t) {
								r.push(t.x), r.push(t.y);
							}
							!(function () {
								const t = i.length / 3;
								if (c) {
									let t = 0,
										e = P * t;
									for (let t = 0; t < A; t++) {
										const n = T[t];
										V(n[2] + e, n[1] + e, n[0] + e);
									}
									(t = o + 2 * p), (e = P * t);
									for (let t = 0; t < A; t++) {
										const n = T[t];
										V(n[0] + e, n[1] + e, n[2] + e);
									}
								} else {
									for (let t = 0; t < A; t++) {
										const e = T[t];
										V(e[2], e[1], e[0]);
									}
									for (let t = 0; t < A; t++) {
										const e = T[t];
										V(e[0] + P * o, e[1] + P * o, e[2] + P * o);
									}
								}
								n.addGroup(t, i.length / 3 - t, 0);
							})(),
								(function () {
									const t = i.length / 3;
									let e = 0;
									k(E, e), (e += E.length);
									for (let t = 0, n = S.length; t < n; t++) {
										const n = S[t];
										k(n, e), (e += n.length);
									}
									n.addGroup(t, i.length / 3 - t, 1);
								})();
						}
						this.setAttribute("position", new wn(i, 3)), this.setAttribute("uv", new wn(r, 2)), this.computeVertexNormals();
					}
					toJSON() {
						const t = super.toJSON();
						return (function (t, e, n) {
							if (((n.shapes = []), Array.isArray(t)))
								for (let e = 0, i = t.length; e < i; e++) {
									const i = t[e];
									n.shapes.push(i.uuid);
								}
							else n.shapes.push(t.uuid);
							void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON());
							return n;
						})(this.parameters.shapes, this.parameters.options, t);
					}
					static fromJSON(t, e) {
						const n = [];
						for (let i = 0, r = t.shapes.length; i < r; i++) {
							const r = e[t.shapes[i]];
							n.push(r);
						}
						const i = t.options.extrudePath;
						return void 0 !== i && (t.options.extrudePath = new So[i.type]().fromJSON(i)), new nl(n, t.options);
					}
				}
				const il = {
					generateTopUV: function (t, e, n, i, r) {
						const a = e[3 * n],
							s = e[3 * n + 1],
							o = e[3 * i],
							l = e[3 * i + 1],
							c = e[3 * r],
							u = e[3 * r + 1];
						return [new Ot(a, s), new Ot(o, l), new Ot(c, u)];
					},
					generateSideWallUV: function (t, e, n, i, r, a) {
						const s = e[3 * n],
							o = e[3 * n + 1],
							l = e[3 * n + 2],
							c = e[3 * i],
							u = e[3 * i + 1],
							h = e[3 * i + 2],
							d = e[3 * r],
							p = e[3 * r + 1],
							f = e[3 * r + 2],
							m = e[3 * a],
							v = e[3 * a + 1],
							g = e[3 * a + 2];
						return Math.abs(o - u) < Math.abs(s - c) ? [new Ot(s, 1 - l), new Ot(c, 1 - h), new Ot(d, 1 - f), new Ot(m, 1 - g)] : [new Ot(o, 1 - l), new Ot(u, 1 - h), new Ot(p, 1 - f), new Ot(v, 1 - g)];
					},
				};
				class rl extends Ln {
					constructor(t = new Co([new Ot(0, 0.5), new Ot(-0.5, -0.5), new Ot(0.5, -0.5)]), e = 12) {
						super(), (this.type = "ShapeGeometry"), (this.parameters = { shapes: t, curveSegments: e });
						const n = [],
							i = [],
							r = [],
							a = [];
						let s = 0,
							o = 0;
						if (!1 === Array.isArray(t)) l(t);
						else for (let e = 0; e < t.length; e++) l(t[e]), this.addGroup(s, o, e), (s += o), (o = 0);
						function l(t) {
							const s = i.length / 3,
								l = t.extractPoints(e);
							let c = l.shape;
							const u = l.holes;
							!1 === $o.isClockWise(c) && (c = c.reverse());
							for (let t = 0, e = u.length; t < e; t++) {
								const e = u[t];
								!0 === $o.isClockWise(e) && (u[t] = e.reverse());
							}
							const h = $o.triangulateShape(c, u);
							for (let t = 0, e = u.length; t < e; t++) {
								const e = u[t];
								c = c.concat(e);
							}
							for (let t = 0, e = c.length; t < e; t++) {
								const e = c[t];
								i.push(e.x, e.y, 0), r.push(0, 0, 1), a.push(e.x, e.y);
							}
							for (let t = 0, e = h.length; t < e; t++) {
								const e = h[t],
									i = e[0] + s,
									r = e[1] + s,
									a = e[2] + s;
								n.push(i, r, a), (o += 3);
							}
						}
						this.setIndex(n), this.setAttribute("position", new wn(i, 3)), this.setAttribute("normal", new wn(r, 3)), this.setAttribute("uv", new wn(a, 2));
					}
					toJSON() {
						const t = super.toJSON();
						return (function (t, e) {
							if (((e.shapes = []), Array.isArray(t)))
								for (let n = 0, i = t.length; n < i; n++) {
									const i = t[n];
									e.shapes.push(i.uuid);
								}
							else e.shapes.push(t.uuid);
							return e;
						})(this.parameters.shapes, t);
					}
					static fromJSON(t, e) {
						const n = [];
						for (let i = 0, r = t.shapes.length; i < r; i++) {
							const r = e[t.shapes[i]];
							n.push(r);
						}
						return new rl(n, t.curveSegments);
					}
				}
				class al extends Ln {
					constructor(t = 1, e = 32, n = 16, i = 0, r = 2 * Math.PI, a = 0, s = Math.PI) {
						super(), (this.type = "SphereGeometry"), (this.parameters = { radius: t, widthSegments: e, heightSegments: n, phiStart: i, phiLength: r, thetaStart: a, thetaLength: s }), (e = Math.max(3, Math.floor(e))), (n = Math.max(2, Math.floor(n)));
						const o = Math.min(a + s, Math.PI);
						let l = 0;
						const c = [],
							u = new Xt(),
							h = new Xt(),
							d = [],
							p = [],
							f = [],
							m = [];
						for (let d = 0; d <= n; d++) {
							const v = [],
								g = d / n;
							let b = 0;
							0 == d && 0 == a ? (b = 0.5 / e) : d == n && o == Math.PI && (b = -0.5 / e);
							for (let n = 0; n <= e; n++) {
								const o = n / e;
								(u.x = -t * Math.cos(i + o * r) * Math.sin(a + g * s)), (u.y = t * Math.cos(a + g * s)), (u.z = t * Math.sin(i + o * r) * Math.sin(a + g * s)), p.push(u.x, u.y, u.z), h.copy(u).normalize(), f.push(h.x, h.y, h.z), m.push(o + b, 1 - g), v.push(l++);
							}
							c.push(v);
						}
						for (let t = 0; t < n; t++)
							for (let i = 0; i < e; i++) {
								const e = c[t][i + 1],
									r = c[t][i],
									s = c[t + 1][i],
									l = c[t + 1][i + 1];
								(0 !== t || a > 0) && d.push(e, r, l), (t !== n - 1 || o < Math.PI) && d.push(r, s, l);
							}
						this.setIndex(d), this.setAttribute("position", new wn(p, 3)), this.setAttribute("normal", new wn(f, 3)), this.setAttribute("uv", new wn(m, 2));
					}
					static fromJSON(t) {
						return new al(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength);
					}
				}
				class sl extends ln {
					constructor(t) {
						super(), (this.type = "ShadowMaterial"), (this.color = new mn(0)), (this.transparent = !0), this.setValues(t);
					}
					copy(t) {
						return super.copy(t), this.color.copy(t.color), this;
					}
				}
				sl.prototype.isShadowMaterial = !0;
				class ol extends ln {
					constructor(t) {
						super(),
							(this.defines = { STANDARD: "" }),
							(this.type = "MeshStandardMaterial"),
							(this.color = new mn(16777215)),
							(this.roughness = 1),
							(this.metalness = 0),
							(this.map = null),
							(this.lightMap = null),
							(this.lightMapIntensity = 1),
							(this.aoMap = null),
							(this.aoMapIntensity = 1),
							(this.emissive = new mn(0)),
							(this.emissiveIntensity = 1),
							(this.emissiveMap = null),
							(this.bumpMap = null),
							(this.bumpScale = 1),
							(this.normalMap = null),
							(this.normalMapType = 0),
							(this.normalScale = new Ot(1, 1)),
							(this.displacementMap = null),
							(this.displacementScale = 1),
							(this.displacementBias = 0),
							(this.roughnessMap = null),
							(this.metalnessMap = null),
							(this.alphaMap = null),
							(this.envMap = null),
							(this.envMapIntensity = 1),
							(this.refractionRatio = 0.98),
							(this.wireframe = !1),
							(this.wireframeLinewidth = 1),
							(this.wireframeLinecap = "round"),
							(this.wireframeLinejoin = "round"),
							(this.flatShading = !1),
							this.setValues(t);
					}
					copy(t) {
						return (
							super.copy(t),
							(this.defines = { STANDARD: "" }),
							this.color.copy(t.color),
							(this.roughness = t.roughness),
							(this.metalness = t.metalness),
							(this.map = t.map),
							(this.lightMap = t.lightMap),
							(this.lightMapIntensity = t.lightMapIntensity),
							(this.aoMap = t.aoMap),
							(this.aoMapIntensity = t.aoMapIntensity),
							this.emissive.copy(t.emissive),
							(this.emissiveMap = t.emissiveMap),
							(this.emissiveIntensity = t.emissiveIntensity),
							(this.bumpMap = t.bumpMap),
							(this.bumpScale = t.bumpScale),
							(this.normalMap = t.normalMap),
							(this.normalMapType = t.normalMapType),
							this.normalScale.copy(t.normalScale),
							(this.displacementMap = t.displacementMap),
							(this.displacementScale = t.displacementScale),
							(this.displacementBias = t.displacementBias),
							(this.roughnessMap = t.roughnessMap),
							(this.metalnessMap = t.metalnessMap),
							(this.alphaMap = t.alphaMap),
							(this.envMap = t.envMap),
							(this.envMapIntensity = t.envMapIntensity),
							(this.refractionRatio = t.refractionRatio),
							(this.wireframe = t.wireframe),
							(this.wireframeLinewidth = t.wireframeLinewidth),
							(this.wireframeLinecap = t.wireframeLinecap),
							(this.wireframeLinejoin = t.wireframeLinejoin),
							(this.flatShading = t.flatShading),
							this
						);
					}
				}
				ol.prototype.isMeshStandardMaterial = !0;
				class ll extends ol {
					constructor(t) {
						super(),
							(this.defines = { STANDARD: "", PHYSICAL: "" }),
							(this.type = "MeshPhysicalMaterial"),
							(this.clearcoatMap = null),
							(this.clearcoatRoughness = 0),
							(this.clearcoatRoughnessMap = null),
							(this.clearcoatNormalScale = new Ot(1, 1)),
							(this.clearcoatNormalMap = null),
							(this.ior = 1.5),
							Object.defineProperty(this, "reflectivity", {
								get: function () {
									return Et((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
								},
								set: function (t) {
									this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
								},
							}),
							(this.sheenTint = new mn(0)),
							(this.sheenRoughness = 1),
							(this.transmissionMap = null),
							(this.thickness = 0.01),
							(this.thicknessMap = null),
							(this.attenuationDistance = 0),
							(this.attenuationTint = new mn(1, 1, 1)),
							(this.specularIntensity = 1),
							(this.specularIntensityMap = null),
							(this.specularTint = new mn(1, 1, 1)),
							(this.specularTintMap = null),
							(this._sheen = 0),
							(this._clearcoat = 0),
							(this._transmission = 0),
							this.setValues(t);
					}
					get sheen() {
						return this._sheen;
					}
					set sheen(t) {
						this._sheen > 0 != t > 0 && this.version++, (this._sheen = t);
					}
					get clearcoat() {
						return this._clearcoat;
					}
					set clearcoat(t) {
						this._clearcoat > 0 != t > 0 && this.version++, (this._clearcoat = t);
					}
					get transmission() {
						return this._transmission;
					}
					set transmission(t) {
						this._transmission > 0 != t > 0 && this.version++, (this._transmission = t);
					}
					copy(t) {
						return (
							super.copy(t),
							(this.defines = { STANDARD: "", PHYSICAL: "" }),
							(this.clearcoat = t.clearcoat),
							(this.clearcoatMap = t.clearcoatMap),
							(this.clearcoatRoughness = t.clearcoatRoughness),
							(this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
							(this.clearcoatNormalMap = t.clearcoatNormalMap),
							this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
							(this.ior = t.ior),
							(this.sheen = t.sheen),
							this.sheenTint.copy(t.sheenTint),
							(this.sheenRoughness = t.sheenRoughness),
							(this.transmission = t.transmission),
							(this.transmissionMap = t.transmissionMap),
							(this.thickness = t.thickness),
							(this.thicknessMap = t.thicknessMap),
							(this.attenuationDistance = t.attenuationDistance),
							this.attenuationTint.copy(t.attenuationTint),
							(this.specularIntensity = t.specularIntensity),
							(this.specularIntensityMap = t.specularIntensityMap),
							this.specularTint.copy(t.specularTint),
							(this.specularTintMap = t.specularTintMap),
							this
						);
					}
				}
				ll.prototype.isMeshPhysicalMaterial = !0;
				class cl extends ln {
					constructor(t) {
						super(),
							(this.type = "MeshPhongMaterial"),
							(this.color = new mn(16777215)),
							(this.specular = new mn(1118481)),
							(this.shininess = 30),
							(this.map = null),
							(this.lightMap = null),
							(this.lightMapIntensity = 1),
							(this.aoMap = null),
							(this.aoMapIntensity = 1),
							(this.emissive = new mn(0)),
							(this.emissiveIntensity = 1),
							(this.emissiveMap = null),
							(this.bumpMap = null),
							(this.bumpScale = 1),
							(this.normalMap = null),
							(this.normalMapType = 0),
							(this.normalScale = new Ot(1, 1)),
							(this.displacementMap = null),
							(this.displacementScale = 1),
							(this.displacementBias = 0),
							(this.specularMap = null),
							(this.alphaMap = null),
							(this.envMap = null),
							(this.combine = 0),
							(this.reflectivity = 1),
							(this.refractionRatio = 0.98),
							(this.wireframe = !1),
							(this.wireframeLinewidth = 1),
							(this.wireframeLinecap = "round"),
							(this.wireframeLinejoin = "round"),
							(this.flatShading = !1),
							this.setValues(t);
					}
					copy(t) {
						return (
							super.copy(t),
							this.color.copy(t.color),
							this.specular.copy(t.specular),
							(this.shininess = t.shininess),
							(this.map = t.map),
							(this.lightMap = t.lightMap),
							(this.lightMapIntensity = t.lightMapIntensity),
							(this.aoMap = t.aoMap),
							(this.aoMapIntensity = t.aoMapIntensity),
							this.emissive.copy(t.emissive),
							(this.emissiveMap = t.emissiveMap),
							(this.emissiveIntensity = t.emissiveIntensity),
							(this.bumpMap = t.bumpMap),
							(this.bumpScale = t.bumpScale),
							(this.normalMap = t.normalMap),
							(this.normalMapType = t.normalMapType),
							this.normalScale.copy(t.normalScale),
							(this.displacementMap = t.displacementMap),
							(this.displacementScale = t.displacementScale),
							(this.displacementBias = t.displacementBias),
							(this.specularMap = t.specularMap),
							(this.alphaMap = t.alphaMap),
							(this.envMap = t.envMap),
							(this.combine = t.combine),
							(this.reflectivity = t.reflectivity),
							(this.refractionRatio = t.refractionRatio),
							(this.wireframe = t.wireframe),
							(this.wireframeLinewidth = t.wireframeLinewidth),
							(this.wireframeLinecap = t.wireframeLinecap),
							(this.wireframeLinejoin = t.wireframeLinejoin),
							(this.flatShading = t.flatShading),
							this
						);
					}
				}
				cl.prototype.isMeshPhongMaterial = !0;
				class ul extends ln {
					constructor(t) {
						super(),
							(this.defines = { TOON: "" }),
							(this.type = "MeshToonMaterial"),
							(this.color = new mn(16777215)),
							(this.map = null),
							(this.gradientMap = null),
							(this.lightMap = null),
							(this.lightMapIntensity = 1),
							(this.aoMap = null),
							(this.aoMapIntensity = 1),
							(this.emissive = new mn(0)),
							(this.emissiveIntensity = 1),
							(this.emissiveMap = null),
							(this.bumpMap = null),
							(this.bumpScale = 1),
							(this.normalMap = null),
							(this.normalMapType = 0),
							(this.normalScale = new Ot(1, 1)),
							(this.displacementMap = null),
							(this.displacementScale = 1),
							(this.displacementBias = 0),
							(this.alphaMap = null),
							(this.wireframe = !1),
							(this.wireframeLinewidth = 1),
							(this.wireframeLinecap = "round"),
							(this.wireframeLinejoin = "round"),
							this.setValues(t);
					}
					copy(t) {
						return (
							super.copy(t),
							this.color.copy(t.color),
							(this.map = t.map),
							(this.gradientMap = t.gradientMap),
							(this.lightMap = t.lightMap),
							(this.lightMapIntensity = t.lightMapIntensity),
							(this.aoMap = t.aoMap),
							(this.aoMapIntensity = t.aoMapIntensity),
							this.emissive.copy(t.emissive),
							(this.emissiveMap = t.emissiveMap),
							(this.emissiveIntensity = t.emissiveIntensity),
							(this.bumpMap = t.bumpMap),
							(this.bumpScale = t.bumpScale),
							(this.normalMap = t.normalMap),
							(this.normalMapType = t.normalMapType),
							this.normalScale.copy(t.normalScale),
							(this.displacementMap = t.displacementMap),
							(this.displacementScale = t.displacementScale),
							(this.displacementBias = t.displacementBias),
							(this.alphaMap = t.alphaMap),
							(this.wireframe = t.wireframe),
							(this.wireframeLinewidth = t.wireframeLinewidth),
							(this.wireframeLinecap = t.wireframeLinecap),
							(this.wireframeLinejoin = t.wireframeLinejoin),
							this
						);
					}
				}
				ul.prototype.isMeshToonMaterial = !0;
				class hl extends ln {
					constructor(t) {
						super(), (this.type = "MeshNormalMaterial"), (this.bumpMap = null), (this.bumpScale = 1), (this.normalMap = null), (this.normalMapType = 0), (this.normalScale = new Ot(1, 1)), (this.displacementMap = null), (this.displacementScale = 1), (this.displacementBias = 0), (this.wireframe = !1), (this.wireframeLinewidth = 1), (this.fog = !1), (this.flatShading = !1), this.setValues(t);
					}
					copy(t) {
						return super.copy(t), (this.bumpMap = t.bumpMap), (this.bumpScale = t.bumpScale), (this.normalMap = t.normalMap), (this.normalMapType = t.normalMapType), this.normalScale.copy(t.normalScale), (this.displacementMap = t.displacementMap), (this.displacementScale = t.displacementScale), (this.displacementBias = t.displacementBias), (this.wireframe = t.wireframe), (this.wireframeLinewidth = t.wireframeLinewidth), (this.flatShading = t.flatShading), this;
					}
				}
				hl.prototype.isMeshNormalMaterial = !0;
				class dl extends ln {
					constructor(t) {
						super(),
							(this.type = "MeshLambertMaterial"),
							(this.color = new mn(16777215)),
							(this.map = null),
							(this.lightMap = null),
							(this.lightMapIntensity = 1),
							(this.aoMap = null),
							(this.aoMapIntensity = 1),
							(this.emissive = new mn(0)),
							(this.emissiveIntensity = 1),
							(this.emissiveMap = null),
							(this.specularMap = null),
							(this.alphaMap = null),
							(this.envMap = null),
							(this.combine = 0),
							(this.reflectivity = 1),
							(this.refractionRatio = 0.98),
							(this.wireframe = !1),
							(this.wireframeLinewidth = 1),
							(this.wireframeLinecap = "round"),
							(this.wireframeLinejoin = "round"),
							this.setValues(t);
					}
					copy(t) {
						return (
							super.copy(t),
							this.color.copy(t.color),
							(this.map = t.map),
							(this.lightMap = t.lightMap),
							(this.lightMapIntensity = t.lightMapIntensity),
							(this.aoMap = t.aoMap),
							(this.aoMapIntensity = t.aoMapIntensity),
							this.emissive.copy(t.emissive),
							(this.emissiveMap = t.emissiveMap),
							(this.emissiveIntensity = t.emissiveIntensity),
							(this.specularMap = t.specularMap),
							(this.alphaMap = t.alphaMap),
							(this.envMap = t.envMap),
							(this.combine = t.combine),
							(this.reflectivity = t.reflectivity),
							(this.refractionRatio = t.refractionRatio),
							(this.wireframe = t.wireframe),
							(this.wireframeLinewidth = t.wireframeLinewidth),
							(this.wireframeLinecap = t.wireframeLinecap),
							(this.wireframeLinejoin = t.wireframeLinejoin),
							this
						);
					}
				}
				dl.prototype.isMeshLambertMaterial = !0;
				class pl extends ln {
					constructor(t) {
						super(), (this.defines = { MATCAP: "" }), (this.type = "MeshMatcapMaterial"), (this.color = new mn(16777215)), (this.matcap = null), (this.map = null), (this.bumpMap = null), (this.bumpScale = 1), (this.normalMap = null), (this.normalMapType = 0), (this.normalScale = new Ot(1, 1)), (this.displacementMap = null), (this.displacementScale = 1), (this.displacementBias = 0), (this.alphaMap = null), (this.flatShading = !1), this.setValues(t);
					}
					copy(t) {
						return (
							super.copy(t),
							(this.defines = { MATCAP: "" }),
							this.color.copy(t.color),
							(this.matcap = t.matcap),
							(this.map = t.map),
							(this.bumpMap = t.bumpMap),
							(this.bumpScale = t.bumpScale),
							(this.normalMap = t.normalMap),
							(this.normalMapType = t.normalMapType),
							this.normalScale.copy(t.normalScale),
							(this.displacementMap = t.displacementMap),
							(this.displacementScale = t.displacementScale),
							(this.displacementBias = t.displacementBias),
							(this.alphaMap = t.alphaMap),
							(this.flatShading = t.flatShading),
							this
						);
					}
				}
				pl.prototype.isMeshMatcapMaterial = !0;
				class fl extends Vs {
					constructor(t) {
						super(), (this.type = "LineDashedMaterial"), (this.scale = 1), (this.dashSize = 3), (this.gapSize = 1), this.setValues(t);
					}
					copy(t) {
						return super.copy(t), (this.scale = t.scale), (this.dashSize = t.dashSize), (this.gapSize = t.gapSize), this;
					}
				}
				fl.prototype.isLineDashedMaterial = !0;
				const ml = {
					arraySlice: function (t, e, n) {
						return ml.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n);
					},
					convertArray: function (t, e, n) {
						return !t || (!n && t.constructor === e) ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t);
					},
					isTypedArray: function (t) {
						return ArrayBuffer.isView(t) && !(t instanceof DataView);
					},
					getKeyframeOrder: function (t) {
						const e = t.length,
							n = new Array(e);
						for (let t = 0; t !== e; ++t) n[t] = t;
						return (
							n.sort(function (e, n) {
								return t[e] - t[n];
							}),
							n
						);
					},
					sortedArray: function (t, e, n) {
						const i = t.length,
							r = new t.constructor(i);
						for (let a = 0, s = 0; s !== i; ++a) {
							const i = n[a] * e;
							for (let n = 0; n !== e; ++n) r[s++] = t[i + n];
						}
						return r;
					},
					flattenJSON: function (t, e, n, i) {
						let r = 1,
							a = t[0];
						for (; void 0 !== a && void 0 === a[i]; ) a = t[r++];
						if (void 0 === a) return;
						let s = a[i];
						if (void 0 !== s)
							if (Array.isArray(s))
								do {
									(s = a[i]), void 0 !== s && (e.push(a.time), n.push.apply(n, s)), (a = t[r++]);
								} while (void 0 !== a);
							else if (void 0 !== s.toArray)
								do {
									(s = a[i]), void 0 !== s && (e.push(a.time), s.toArray(n, n.length)), (a = t[r++]);
								} while (void 0 !== a);
							else
								do {
									(s = a[i]), void 0 !== s && (e.push(a.time), n.push(s)), (a = t[r++]);
								} while (void 0 !== a);
					},
					subclip: function (t, e, n, i, r = 30) {
						const a = t.clone();
						a.name = e;
						const s = [];
						for (let t = 0; t < a.tracks.length; ++t) {
							const e = a.tracks[t],
								o = e.getValueSize(),
								l = [],
								c = [];
							for (let t = 0; t < e.times.length; ++t) {
								const a = e.times[t] * r;
								if (!(a < n || a >= i)) {
									l.push(e.times[t]);
									for (let n = 0; n < o; ++n) c.push(e.values[t * o + n]);
								}
							}
							0 !== l.length && ((e.times = ml.convertArray(l, e.times.constructor)), (e.values = ml.convertArray(c, e.values.constructor)), s.push(e));
						}
						a.tracks = s;
						let o = 1 / 0;
						for (let t = 0; t < a.tracks.length; ++t) o > a.tracks[t].times[0] && (o = a.tracks[t].times[0]);
						for (let t = 0; t < a.tracks.length; ++t) a.tracks[t].shift(-1 * o);
						return a.resetDuration(), a;
					},
					makeClipAdditive: function (t, e = 0, n = t, i = 30) {
						i <= 0 && (i = 30);
						const r = n.tracks.length,
							a = e / i;
						for (let e = 0; e < r; ++e) {
							const i = n.tracks[e],
								r = i.ValueTypeName;
							if ("bool" === r || "string" === r) continue;
							const s = t.tracks.find(function (t) {
								return t.name === i.name && t.ValueTypeName === r;
							});
							if (void 0 === s) continue;
							let o = 0;
							const l = i.getValueSize();
							i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o = l / 3);
							let c = 0;
							const u = s.getValueSize();
							s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = u / 3);
							const h = i.times.length - 1;
							let d;
							if (a <= i.times[0]) {
								const t = o,
									e = l - o;
								d = ml.arraySlice(i.values, t, e);
							} else if (a >= i.times[h]) {
								const t = h * l + o,
									e = t + l - o;
								d = ml.arraySlice(i.values, t, e);
							} else {
								const t = i.createInterpolant(),
									e = o,
									n = l - o;
								t.evaluate(a), (d = ml.arraySlice(t.resultBuffer, e, n));
							}
							if ("quaternion" === r) {
								new jt().fromArray(d).normalize().conjugate().toArray(d);
							}
							const p = s.times.length;
							for (let t = 0; t < p; ++t) {
								const e = t * u + c;
								if ("quaternion" === r) jt.multiplyQuaternionsFlat(s.values, e, d, 0, s.values, e);
								else {
									const t = u - 2 * c;
									for (let n = 0; n < t; ++n) s.values[e + n] -= d[n];
								}
							}
						}
						return (t.blendMode = 2501), t;
					},
				};
				class vl {
					constructor(t, e, n, i) {
						(this.parameterPositions = t), (this._cachedIndex = 0), (this.resultBuffer = void 0 !== i ? i : new e.constructor(n)), (this.sampleValues = e), (this.valueSize = n), (this.settings = null), (this.DefaultSettings_ = {});
					}
					evaluate(t) {
						const e = this.parameterPositions;
						let n = this._cachedIndex,
							i = e[n],
							r = e[n - 1];
						t: {
							e: {
								let a;
								n: {
									i: if (!(t < i)) {
										for (let a = n + 2; ; ) {
											if (void 0 === i) {
												if (t < r) break i;
												return (n = e.length), (this._cachedIndex = n), this.afterEnd_(n - 1, t, r);
											}
											if (n === a) break;
											if (((r = i), (i = e[++n]), t < i)) break e;
										}
										a = e.length;
										break n;
									}
									if (t >= r) break t;
									{
										const s = e[1];
										t < s && ((n = 2), (r = s));
										for (let a = n - 2; ; ) {
											if (void 0 === r) return (this._cachedIndex = 0), this.beforeStart_(0, t, i);
											if (n === a) break;
											if (((i = r), (r = e[--n - 1]), t >= r)) break e;
										}
										(a = n), (n = 0);
									}
								}
								for (; n < a; ) {
									const i = (n + a) >>> 1;
									t < e[i] ? (a = i) : (n = i + 1);
								}
								if (((i = e[n]), (r = e[n - 1]), void 0 === r)) return (this._cachedIndex = 0), this.beforeStart_(0, t, i);
								if (void 0 === i) return (n = e.length), (this._cachedIndex = n), this.afterEnd_(n - 1, r, t);
							}
							(this._cachedIndex = n), this.intervalChanged_(n, r, i);
						}
						return this.interpolate_(n, r, t, i);
					}
					getSettings_() {
						return this.settings || this.DefaultSettings_;
					}
					copySampleValue_(t) {
						const e = this.resultBuffer,
							n = this.sampleValues,
							i = this.valueSize,
							r = t * i;
						for (let t = 0; t !== i; ++t) e[t] = n[r + t];
						return e;
					}
					interpolate_() {
						throw new Error("call to abstract method");
					}
					intervalChanged_() {}
				}
				(vl.prototype.beforeStart_ = vl.prototype.copySampleValue_), (vl.prototype.afterEnd_ = vl.prototype.copySampleValue_);
				class gl extends vl {
					constructor(t, e, n, i) {
						super(t, e, n, i), (this._weightPrev = -0), (this._offsetPrev = -0), (this._weightNext = -0), (this._offsetNext = -0), (this.DefaultSettings_ = { endingStart: ot, endingEnd: ot });
					}
					intervalChanged_(t, e, n) {
						const i = this.parameterPositions;
						let r = t - 2,
							a = t + 1,
							s = i[r],
							o = i[a];
						if (void 0 === s)
							switch (this.getSettings_().endingStart) {
								case lt:
									(r = t), (s = 2 * e - n);
									break;
								case ct:
									(r = i.length - 2), (s = e + i[r] - i[r + 1]);
									break;
								default:
									(r = t), (s = n);
							}
						if (void 0 === o)
							switch (this.getSettings_().endingEnd) {
								case lt:
									(a = t), (o = 2 * n - e);
									break;
								case ct:
									(a = 1), (o = n + i[1] - i[0]);
									break;
								default:
									(a = t - 1), (o = e);
							}
						const l = 0.5 * (n - e),
							c = this.valueSize;
						(this._weightPrev = l / (e - s)), (this._weightNext = l / (o - n)), (this._offsetPrev = r * c), (this._offsetNext = a * c);
					}
					interpolate_(t, e, n, i) {
						const r = this.resultBuffer,
							a = this.sampleValues,
							s = this.valueSize,
							o = t * s,
							l = o - s,
							c = this._offsetPrev,
							u = this._offsetNext,
							h = this._weightPrev,
							d = this._weightNext,
							p = (n - e) / (i - e),
							f = p * p,
							m = f * p,
							v = -h * m + 2 * h * f - h * p,
							g = (1 + h) * m + (-1.5 - 2 * h) * f + (-0.5 + h) * p + 1,
							b = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
							x = d * m - d * f;
						for (let t = 0; t !== s; ++t) r[t] = v * a[c + t] + g * a[l + t] + b * a[o + t] + x * a[u + t];
						return r;
					}
				}
				class bl extends vl {
					constructor(t, e, n, i) {
						super(t, e, n, i);
					}
					interpolate_(t, e, n, i) {
						const r = this.resultBuffer,
							a = this.sampleValues,
							s = this.valueSize,
							o = t * s,
							l = o - s,
							c = (n - e) / (i - e),
							u = 1 - c;
						for (let t = 0; t !== s; ++t) r[t] = a[l + t] * u + a[o + t] * c;
						return r;
					}
				}
				class xl extends vl {
					constructor(t, e, n, i) {
						super(t, e, n, i);
					}
					interpolate_(t) {
						return this.copySampleValue_(t - 1);
					}
				}
				class yl {
					constructor(t, e, n, i) {
						if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
						if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
						(this.name = t), (this.times = ml.convertArray(e, this.TimeBufferType)), (this.values = ml.convertArray(n, this.ValueBufferType)), this.setInterpolation(i || this.DefaultInterpolation);
					}
					static toJSON(t) {
						const e = t.constructor;
						let n;
						if (e.toJSON !== this.toJSON) n = e.toJSON(t);
						else {
							n = { name: t.name, times: ml.convertArray(t.times, Array), values: ml.convertArray(t.values, Array) };
							const e = t.getInterpolation();
							e !== t.DefaultInterpolation && (n.interpolation = e);
						}
						return (n.type = t.ValueTypeName), n;
					}
					InterpolantFactoryMethodDiscrete(t) {
						return new xl(this.times, this.values, this.getValueSize(), t);
					}
					InterpolantFactoryMethodLinear(t) {
						return new bl(this.times, this.values, this.getValueSize(), t);
					}
					InterpolantFactoryMethodSmooth(t) {
						return new gl(this.times, this.values, this.getValueSize(), t);
					}
					setInterpolation(t) {
						let e;
						switch (t) {
							case rt:
								e = this.InterpolantFactoryMethodDiscrete;
								break;
							case at:
								e = this.InterpolantFactoryMethodLinear;
								break;
							case st:
								e = this.InterpolantFactoryMethodSmooth;
						}
						if (void 0 === e) {
							const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
							if (void 0 === this.createInterpolant) {
								if (t === this.DefaultInterpolation) throw new Error(e);
								this.setInterpolation(this.DefaultInterpolation);
							}
							return console.warn("THREE.KeyframeTrack:", e), this;
						}
						return (this.createInterpolant = e), this;
					}
					getInterpolation() {
						switch (this.createInterpolant) {
							case this.InterpolantFactoryMethodDiscrete:
								return rt;
							case this.InterpolantFactoryMethodLinear:
								return at;
							case this.InterpolantFactoryMethodSmooth:
								return st;
						}
					}
					getValueSize() {
						return this.values.length / this.times.length;
					}
					shift(t) {
						if (0 !== t) {
							const e = this.times;
							for (let n = 0, i = e.length; n !== i; ++n) e[n] += t;
						}
						return this;
					}
					scale(t) {
						if (1 !== t) {
							const e = this.times;
							for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t;
						}
						return this;
					}
					trim(t, e) {
						const n = this.times,
							i = n.length;
						let r = 0,
							a = i - 1;
						for (; r !== i && n[r] < t; ) ++r;
						for (; -1 !== a && n[a] > e; ) --a;
						if ((++a, 0 !== r || a !== i)) {
							r >= a && ((a = Math.max(a, 1)), (r = a - 1));
							const t = this.getValueSize();
							(this.times = ml.arraySlice(n, r, a)), (this.values = ml.arraySlice(this.values, r * t, a * t));
						}
						return this;
					}
					validate() {
						let t = !0;
						const e = this.getValueSize();
						e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), (t = !1));
						const n = this.times,
							i = this.values,
							r = n.length;
						0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), (t = !1));
						let a = null;
						for (let e = 0; e !== r; e++) {
							const i = n[e];
							if ("number" == typeof i && isNaN(i)) {
								console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, i), (t = !1);
								break;
							}
							if (null !== a && a > i) {
								console.error("THREE.KeyframeTrack: Out of order keys.", this, e, i, a), (t = !1);
								break;
							}
							a = i;
						}
						if (void 0 !== i && ml.isTypedArray(i))
							for (let e = 0, n = i.length; e !== n; ++e) {
								const n = i[e];
								if (isNaN(n)) {
									console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n), (t = !1);
									break;
								}
							}
						return t;
					}
					optimize() {
						const t = ml.arraySlice(this.times),
							e = ml.arraySlice(this.values),
							n = this.getValueSize(),
							i = this.getInterpolation() === st,
							r = t.length - 1;
						let a = 1;
						for (let s = 1; s < r; ++s) {
							let r = !1;
							const o = t[s];
							if (o !== t[s + 1] && (1 !== s || o !== t[0]))
								if (i) r = !0;
								else {
									const t = s * n,
										i = t - n,
										a = t + n;
									for (let s = 0; s !== n; ++s) {
										const n = e[t + s];
										if (n !== e[i + s] || n !== e[a + s]) {
											r = !0;
											break;
										}
									}
								}
							if (r) {
								if (s !== a) {
									t[a] = t[s];
									const i = s * n,
										r = a * n;
									for (let t = 0; t !== n; ++t) e[r + t] = e[i + t];
								}
								++a;
							}
						}
						if (r > 0) {
							t[a] = t[r];
							for (let t = r * n, i = a * n, s = 0; s !== n; ++s) e[i + s] = e[t + s];
							++a;
						}
						return a !== t.length ? ((this.times = ml.arraySlice(t, 0, a)), (this.values = ml.arraySlice(e, 0, a * n))) : ((this.times = t), (this.values = e)), this;
					}
					clone() {
						const t = ml.arraySlice(this.times, 0),
							e = ml.arraySlice(this.values, 0),
							n = new (0, this.constructor)(this.name, t, e);
						return (n.createInterpolant = this.createInterpolant), n;
					}
				}
				(yl.prototype.TimeBufferType = Float32Array), (yl.prototype.ValueBufferType = Float32Array), (yl.prototype.DefaultInterpolation = at);
				class _l extends yl {}
				(_l.prototype.ValueTypeName = "bool"), (_l.prototype.ValueBufferType = Array), (_l.prototype.DefaultInterpolation = rt), (_l.prototype.InterpolantFactoryMethodLinear = void 0), (_l.prototype.InterpolantFactoryMethodSmooth = void 0);
				class wl extends yl {}
				wl.prototype.ValueTypeName = "color";
				class Ml extends yl {}
				Ml.prototype.ValueTypeName = "number";
				class Sl extends vl {
					constructor(t, e, n, i) {
						super(t, e, n, i);
					}
					interpolate_(t, e, n, i) {
						const r = this.resultBuffer,
							a = this.sampleValues,
							s = this.valueSize,
							o = (n - e) / (i - e);
						let l = t * s;
						for (let t = l + s; l !== t; l += 4) jt.slerpFlat(r, 0, a, l - s, a, l, o);
						return r;
					}
				}
				class Tl extends yl {
					InterpolantFactoryMethodLinear(t) {
						return new Sl(this.times, this.values, this.getValueSize(), t);
					}
				}
				(Tl.prototype.ValueTypeName = "quaternion"), (Tl.prototype.DefaultInterpolation = at), (Tl.prototype.InterpolantFactoryMethodSmooth = void 0);
				class El extends yl {}
				(El.prototype.ValueTypeName = "string"), (El.prototype.ValueBufferType = Array), (El.prototype.DefaultInterpolation = rt), (El.prototype.InterpolantFactoryMethodLinear = void 0), (El.prototype.InterpolantFactoryMethodSmooth = void 0);
				class Cl extends yl {}
				Cl.prototype.ValueTypeName = "vector";
				class Pl {
					constructor(t, e = -1, n, i = 2500) {
						(this.name = t), (this.tracks = n), (this.duration = e), (this.blendMode = i), (this.uuid = Tt()), this.duration < 0 && this.resetDuration();
					}
					static parse(t) {
						const e = [],
							n = t.tracks,
							i = 1 / (t.fps || 1);
						for (let t = 0, r = n.length; t !== r; ++t) e.push(Al(n[t]).scale(i));
						const r = new this(t.name, t.duration, e, t.blendMode);
						return (r.uuid = t.uuid), r;
					}
					static toJSON(t) {
						const e = [],
							n = t.tracks,
							i = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid, blendMode: t.blendMode };
						for (let t = 0, i = n.length; t !== i; ++t) e.push(yl.toJSON(n[t]));
						return i;
					}
					static CreateFromMorphTargetSequence(t, e, n, i) {
						const r = e.length,
							a = [];
						for (let t = 0; t < r; t++) {
							let s = [],
								o = [];
							s.push((t + r - 1) % r, t, (t + 1) % r), o.push(0, 1, 0);
							const l = ml.getKeyframeOrder(s);
							(s = ml.sortedArray(s, 1, l)), (o = ml.sortedArray(o, 1, l)), i || 0 !== s[0] || (s.push(r), o.push(o[0])), a.push(new Ml(".morphTargetInfluences[" + e[t].name + "]", s, o).scale(1 / n));
						}
						return new this(t, -1, a);
					}
					static findByName(t, e) {
						let n = t;
						if (!Array.isArray(t)) {
							const e = t;
							n = (e.geometry && e.geometry.animations) || e.animations;
						}
						for (let t = 0; t < n.length; t++) if (n[t].name === e) return n[t];
						return null;
					}
					static CreateClipsFromMorphTargetSequences(t, e, n) {
						const i = {},
							r = /^([\w-]*?)([\d]+)$/;
						for (let e = 0, n = t.length; e < n; e++) {
							const n = t[e],
								a = n.name.match(r);
							if (a && a.length > 1) {
								const t = a[1];
								let e = i[t];
								e || (i[t] = e = []), e.push(n);
							}
						}
						const a = [];
						for (const t in i) a.push(this.CreateFromMorphTargetSequence(t, i[t], e, n));
						return a;
					}
					static parseAnimation(t, e) {
						if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
						const n = function (t, e, n, i, r) {
								if (0 !== n.length) {
									const a = [],
										s = [];
									ml.flattenJSON(n, a, s, i), 0 !== a.length && r.push(new t(e, a, s));
								}
							},
							i = [],
							r = t.name || "default",
							a = t.fps || 30,
							s = t.blendMode;
						let o = t.length || -1;
						const l = t.hierarchy || [];
						for (let t = 0; t < l.length; t++) {
							const r = l[t].keys;
							if (r && 0 !== r.length)
								if (r[0].morphTargets) {
									const t = {};
									let e;
									for (e = 0; e < r.length; e++) if (r[e].morphTargets) for (let n = 0; n < r[e].morphTargets.length; n++) t[r[e].morphTargets[n]] = -1;
									for (const n in t) {
										const t = [],
											a = [];
										for (let i = 0; i !== r[e].morphTargets.length; ++i) {
											const i = r[e];
											t.push(i.time), a.push(i.morphTarget === n ? 1 : 0);
										}
										i.push(new Ml(".morphTargetInfluence[" + n + "]", t, a));
									}
									o = t.length * (a || 1);
								} else {
									const a = ".bones[" + e[t].name + "]";
									n(Cl, a + ".position", r, "pos", i), n(Tl, a + ".quaternion", r, "rot", i), n(Cl, a + ".scale", r, "scl", i);
								}
						}
						if (0 === i.length) return null;
						return new this(r, o, i, s);
					}
					resetDuration() {
						let t = 0;
						for (let e = 0, n = this.tracks.length; e !== n; ++e) {
							const n = this.tracks[e];
							t = Math.max(t, n.times[n.times.length - 1]);
						}
						return (this.duration = t), this;
					}
					trim() {
						for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
						return this;
					}
					validate() {
						let t = !0;
						for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
						return t;
					}
					optimize() {
						for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
						return this;
					}
					clone() {
						const t = [];
						for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
						return new this.constructor(this.name, this.duration, t, this.blendMode);
					}
					toJSON() {
						return this.constructor.toJSON(this);
					}
				}
				function Al(t) {
					if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
					const e = (function (t) {
						switch (t.toLowerCase()) {
							case "scalar":
							case "double":
							case "float":
							case "number":
							case "integer":
								return Ml;
							case "vector":
							case "vector2":
							case "vector3":
							case "vector4":
								return Cl;
							case "color":
								return wl;
							case "quaternion":
								return Tl;
							case "bool":
							case "boolean":
								return _l;
							case "string":
								return El;
						}
						throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
					})(t.type);
					if (void 0 === t.times) {
						const e = [],
							n = [];
						ml.flattenJSON(t.keys, e, n, "value"), (t.times = e), (t.values = n);
					}
					return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation);
				}
				const Ll = {
					enabled: !1,
					files: {},
					add: function (t, e) {
						!1 !== this.enabled && (this.files[t] = e);
					},
					get: function (t) {
						if (!1 !== this.enabled) return this.files[t];
					},
					remove: function (t) {
						delete this.files[t];
					},
					clear: function () {
						this.files = {};
					},
				};
				class Rl {
					constructor(t, e, n) {
						const i = this;
						let r,
							a = !1,
							s = 0,
							o = 0;
						const l = [];
						(this.onStart = void 0),
							(this.onLoad = t),
							(this.onProgress = e),
							(this.onError = n),
							(this.itemStart = function (t) {
								o++, !1 === a && void 0 !== i.onStart && i.onStart(t, s, o), (a = !0);
							}),
							(this.itemEnd = function (t) {
								s++, void 0 !== i.onProgress && i.onProgress(t, s, o), s === o && ((a = !1), void 0 !== i.onLoad && i.onLoad());
							}),
							(this.itemError = function (t) {
								void 0 !== i.onError && i.onError(t);
							}),
							(this.resolveURL = function (t) {
								return r ? r(t) : t;
							}),
							(this.setURLModifier = function (t) {
								return (r = t), this;
							}),
							(this.addHandler = function (t, e) {
								return l.push(t, e), this;
							}),
							(this.removeHandler = function (t) {
								const e = l.indexOf(t);
								return -1 !== e && l.splice(e, 2), this;
							}),
							(this.getHandler = function (t) {
								for (let e = 0, n = l.length; e < n; e += 2) {
									const n = l[e],
										i = l[e + 1];
									if ((n.global && (n.lastIndex = 0), n.test(t))) return i;
								}
								return null;
							});
					}
				}
				const Dl = new Rl();
				class Ol {
					constructor(t) {
						(this.manager = void 0 !== t ? t : Dl), (this.crossOrigin = "anonymous"), (this.withCredentials = !1), (this.path = ""), (this.resourcePath = ""), (this.requestHeader = {});
					}
					load() {}
					loadAsync(t, e) {
						const n = this;
						return new Promise(function (i, r) {
							n.load(t, i, e, r);
						});
					}
					parse() {}
					setCrossOrigin(t) {
						return (this.crossOrigin = t), this;
					}
					setWithCredentials(t) {
						return (this.withCredentials = t), this;
					}
					setPath(t) {
						return (this.path = t), this;
					}
					setResourcePath(t) {
						return (this.resourcePath = t), this;
					}
					setRequestHeader(t) {
						return (this.requestHeader = t), this;
					}
				}
				const zl = {};
				class Il extends Ol {
					constructor(t) {
						super(t);
					}
					load(t, e, n, i) {
						void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), (t = this.manager.resolveURL(t));
						const r = this,
							a = Ll.get(t);
						if (void 0 !== a)
							return (
								r.manager.itemStart(t),
								setTimeout(function () {
									e && e(a), r.manager.itemEnd(t);
								}, 0),
								a
							);
						if (void 0 !== zl[t]) return void zl[t].push({ onLoad: e, onProgress: n, onError: i });
						const s = t.match(/^data:(.*?)(;base64)?,(.*)$/);
						let o;
						if (s) {
							const n = s[1],
								a = !!s[2];
							let o = s[3];
							(o = decodeURIComponent(o)), a && (o = atob(o));
							try {
								let i;
								const a = (this.responseType || "").toLowerCase();
								switch (a) {
									case "arraybuffer":
									case "blob":
										const t = new Uint8Array(o.length);
										for (let e = 0; e < o.length; e++) t[e] = o.charCodeAt(e);
										i = "blob" === a ? new Blob([t.buffer], { type: n }) : t.buffer;
										break;
									case "document":
										const e = new DOMParser();
										i = e.parseFromString(o, n);
										break;
									case "json":
										i = JSON.parse(o);
										break;
									default:
										i = o;
								}
								setTimeout(function () {
									e && e(i), r.manager.itemEnd(t);
								}, 0);
							} catch (e) {
								setTimeout(function () {
									i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
								}, 0);
							}
						} else {
							(zl[t] = []),
								zl[t].push({ onLoad: e, onProgress: n, onError: i }),
								(o = new XMLHttpRequest()),
								o.open("GET", t, !0),
								o.addEventListener(
									"load",
									function (e) {
										const n = this.response,
											i = zl[t];
										if ((delete zl[t], 200 === this.status || 0 === this.status)) {
											0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), Ll.add(t, n);
											for (let t = 0, e = i.length; t < e; t++) {
												const e = i[t];
												e.onLoad && e.onLoad(n);
											}
											r.manager.itemEnd(t);
										} else {
											for (let t = 0, n = i.length; t < n; t++) {
												const n = i[t];
												n.onError && n.onError(e);
											}
											r.manager.itemError(t), r.manager.itemEnd(t);
										}
									},
									!1
								),
								o.addEventListener(
									"progress",
									function (e) {
										const n = zl[t];
										for (let t = 0, i = n.length; t < i; t++) {
											const i = n[t];
											i.onProgress && i.onProgress(e);
										}
									},
									!1
								),
								o.addEventListener(
									"error",
									function (e) {
										const n = zl[t];
										delete zl[t];
										for (let t = 0, i = n.length; t < i; t++) {
											const i = n[t];
											i.onError && i.onError(e);
										}
										r.manager.itemError(t), r.manager.itemEnd(t);
									},
									!1
								),
								o.addEventListener(
									"abort",
									function (e) {
										const n = zl[t];
										delete zl[t];
										for (let t = 0, i = n.length; t < i; t++) {
											const i = n[t];
											i.onError && i.onError(e);
										}
										r.manager.itemError(t), r.manager.itemEnd(t);
									},
									!1
								),
								void 0 !== this.responseType && (o.responseType = this.responseType),
								void 0 !== this.withCredentials && (o.withCredentials = this.withCredentials),
								o.overrideMimeType && o.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
							for (const t in this.requestHeader) o.setRequestHeader(t, this.requestHeader[t]);
							o.send(null);
						}
						return r.manager.itemStart(t), o;
					}
					setResponseType(t) {
						return (this.responseType = t), this;
					}
					setMimeType(t) {
						return (this.mimeType = t), this;
					}
				}
				class kl extends Ol {
					constructor(t) {
						super(t);
					}
					load(t, e, n, i) {
						void 0 !== this.path && (t = this.path + t), (t = this.manager.resolveURL(t));
						const r = this,
							a = Ll.get(t);
						if (void 0 !== a)
							return (
								r.manager.itemStart(t),
								setTimeout(function () {
									e && e(a), r.manager.itemEnd(t);
								}, 0),
								a
							);
						const s = kt("img");
						function o() {
							s.removeEventListener("load", o, !1), s.removeEventListener("error", l, !1), Ll.add(t, this), e && e(this), r.manager.itemEnd(t);
						}
						function l(e) {
							s.removeEventListener("load", o, !1), s.removeEventListener("error", l, !1), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
						}
						return s.addEventListener("load", o, !1), s.addEventListener("error", l, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), r.manager.itemStart(t), (s.src = t), s;
					}
				}
				class Nl extends Ol {
					constructor(t) {
						super(t);
					}
					load(t, e, n, i) {
						const r = new ai(),
							a = new kl(this.manager);
						a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
						let s = 0;
						function o(n) {
							a.load(
								t[n],
								function (t) {
									(r.images[n] = t), s++, 6 === s && ((r.needsUpdate = !0), e && e(r));
								},
								void 0,
								i
							);
						}
						for (let e = 0; e < t.length; ++e) o(e);
						return r;
					}
				}
				class Vl extends Ol {
					constructor(t) {
						super(t);
					}
					load(t, e, n, i) {
						const r = new Ft(),
							a = new kl(this.manager);
						return (
							a.setCrossOrigin(this.crossOrigin),
							a.setPath(this.path),
							a.load(
								t,
								function (t) {
									(r.image = t), (r.needsUpdate = !0), void 0 !== e && e(r);
								},
								n,
								i
							),
							r
						);
					}
				}
				class Bl extends Ye {
					constructor(t, e = 1) {
						super(), (this.type = "Light"), (this.color = new mn(t)), (this.intensity = e);
					}
					dispose() {}
					copy(t) {
						return super.copy(t), this.color.copy(t.color), (this.intensity = t.intensity), this;
					}
					toJSON(t) {
						const e = super.toJSON(t);
						return (
							(e.object.color = this.color.getHex()),
							(e.object.intensity = this.intensity),
							void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
							void 0 !== this.distance && (e.object.distance = this.distance),
							void 0 !== this.angle && (e.object.angle = this.angle),
							void 0 !== this.decay && (e.object.decay = this.decay),
							void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
							void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
							e
						);
					}
				}
				Bl.prototype.isLight = !0;
				class Fl extends Bl {
					constructor(t, e, n) {
						super(t, n), (this.type = "HemisphereLight"), this.position.copy(Ye.DefaultUp), this.updateMatrix(), (this.groundColor = new mn(e));
					}
					copy(t) {
						return Bl.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this;
					}
				}
				Fl.prototype.isHemisphereLight = !0;
				const Ul = new Me(),
					Hl = new Xt(),
					Gl = new Xt();
				class Wl {
					constructor(t) {
						(this.camera = t), (this.bias = 0), (this.normalBias = 0), (this.radius = 1), (this.blurSamples = 8), (this.mapSize = new Ot(512, 512)), (this.map = null), (this.mapPass = null), (this.matrix = new Me()), (this.autoUpdate = !0), (this.needsUpdate = !1), (this._frustum = new pi()), (this._frameExtents = new Ot(1, 1)), (this._viewportCount = 1), (this._viewports = [new Ht(0, 0, 1, 1)]);
					}
					getViewportCount() {
						return this._viewportCount;
					}
					getFrustum() {
						return this._frustum;
					}
					updateMatrices(t) {
						const e = this.camera,
							n = this.matrix;
						Hl.setFromMatrixPosition(t.matrixWorld), e.position.copy(Hl), Gl.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(Gl), e.updateMatrixWorld(), Ul.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Ul), n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse);
					}
					getViewport(t) {
						return this._viewports[t];
					}
					getFrameExtents() {
						return this._frameExtents;
					}
					dispose() {
						this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
					}
					copy(t) {
						return (this.camera = t.camera.clone()), (this.bias = t.bias), (this.radius = t.radius), this.mapSize.copy(t.mapSize), this;
					}
					clone() {
						return new this.constructor().copy(this);
					}
					toJSON() {
						const t = {};
						return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), (512 === this.mapSize.x && 512 === this.mapSize.y) || (t.mapSize = this.mapSize.toArray()), (t.camera = this.camera.toJSON(!1).object), delete t.camera.matrix, t;
					}
				}
				class jl extends Wl {
					constructor() {
						super(new ni(50, 1, 0.5, 500)), (this.focus = 1);
					}
					updateMatrices(t) {
						const e = this.camera,
							n = 2 * wt * t.angle * this.focus,
							i = this.mapSize.width / this.mapSize.height,
							r = t.distance || e.far;
						(n === e.fov && i === e.aspect && r === e.far) || ((e.fov = n), (e.aspect = i), (e.far = r), e.updateProjectionMatrix()), super.updateMatrices(t);
					}
					copy(t) {
						return super.copy(t), (this.focus = t.focus), this;
					}
				}
				jl.prototype.isSpotLightShadow = !0;
				class Xl extends Bl {
					constructor(t, e, n = 0, i = Math.PI / 3, r = 0, a = 1) {
						super(t, e), (this.type = "SpotLight"), this.position.copy(Ye.DefaultUp), this.updateMatrix(), (this.target = new Ye()), (this.distance = n), (this.angle = i), (this.penumbra = r), (this.decay = a), (this.shadow = new jl());
					}
					get power() {
						return this.intensity * Math.PI;
					}
					set power(t) {
						this.intensity = t / Math.PI;
					}
					dispose() {
						this.shadow.dispose();
					}
					copy(t) {
						return super.copy(t), (this.distance = t.distance), (this.angle = t.angle), (this.penumbra = t.penumbra), (this.decay = t.decay), (this.target = t.target.clone()), (this.shadow = t.shadow.clone()), this;
					}
				}
				Xl.prototype.isSpotLight = !0;
				const ql = new Me(),
					Yl = new Xt(),
					Zl = new Xt();
				class Kl extends Wl {
					constructor() {
						super(new ni(90, 1, 0.5, 500)),
							(this._frameExtents = new Ot(4, 2)),
							(this._viewportCount = 6),
							(this._viewports = [new Ht(2, 1, 1, 1), new Ht(0, 1, 1, 1), new Ht(3, 1, 1, 1), new Ht(1, 1, 1, 1), new Ht(3, 0, 1, 1), new Ht(1, 0, 1, 1)]),
							(this._cubeDirections = [new Xt(1, 0, 0), new Xt(-1, 0, 0), new Xt(0, 0, 1), new Xt(0, 0, -1), new Xt(0, 1, 0), new Xt(0, -1, 0)]),
							(this._cubeUps = [new Xt(0, 1, 0), new Xt(0, 1, 0), new Xt(0, 1, 0), new Xt(0, 1, 0), new Xt(0, 0, 1), new Xt(0, 0, -1)]);
					}
					updateMatrices(t, e = 0) {
						const n = this.camera,
							i = this.matrix,
							r = t.distance || n.far;
						r !== n.far && ((n.far = r), n.updateProjectionMatrix()), Yl.setFromMatrixPosition(t.matrixWorld), n.position.copy(Yl), Zl.copy(n.position), Zl.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(Zl), n.updateMatrixWorld(), i.makeTranslation(-Yl.x, -Yl.y, -Yl.z), ql.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(ql);
					}
				}
				Kl.prototype.isPointLightShadow = !0;
				class Jl extends Bl {
					constructor(t, e, n = 0, i = 1) {
						super(t, e), (this.type = "PointLight"), (this.distance = n), (this.decay = i), (this.shadow = new Kl());
					}
					get power() {
						return 4 * this.intensity * Math.PI;
					}
					set power(t) {
						this.intensity = t / (4 * Math.PI);
					}
					dispose() {
						this.shadow.dispose();
					}
					copy(t) {
						return super.copy(t), (this.distance = t.distance), (this.decay = t.decay), (this.shadow = t.shadow.clone()), this;
					}
				}
				Jl.prototype.isPointLight = !0;
				class Ql extends Wl {
					constructor() {
						super(new Ei(-5, 5, 5, -5, 0.5, 500));
					}
				}
				Ql.prototype.isDirectionalLightShadow = !0;
				class $l extends Bl {
					constructor(t, e) {
						super(t, e), (this.type = "DirectionalLight"), this.position.copy(Ye.DefaultUp), this.updateMatrix(), (this.target = new Ye()), (this.shadow = new Ql());
					}
					dispose() {
						this.shadow.dispose();
					}
					copy(t) {
						return super.copy(t), (this.target = t.target.clone()), (this.shadow = t.shadow.clone()), this;
					}
				}
				$l.prototype.isDirectionalLight = !0;
				class tc extends Bl {
					constructor(t, e) {
						super(t, e), (this.type = "AmbientLight");
					}
				}
				tc.prototype.isAmbientLight = !0;
				class ec extends Bl {
					constructor(t, e, n = 10, i = 10) {
						super(t, e), (this.type = "RectAreaLight"), (this.width = n), (this.height = i);
					}
					get power() {
						return this.intensity * this.width * this.height * Math.PI;
					}
					set power(t) {
						this.intensity = t / (this.width * this.height * Math.PI);
					}
					copy(t) {
						return super.copy(t), (this.width = t.width), (this.height = t.height), this;
					}
					toJSON(t) {
						const e = super.toJSON(t);
						return (e.object.width = this.width), (e.object.height = this.height), e;
					}
				}
				ec.prototype.isRectAreaLight = !0;
				class nc {
					constructor() {
						this.coefficients = [];
						for (let t = 0; t < 9; t++) this.coefficients.push(new Xt());
					}
					set(t) {
						for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
						return this;
					}
					zero() {
						for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
						return this;
					}
					getAt(t, e) {
						const n = t.x,
							i = t.y,
							r = t.z,
							a = this.coefficients;
						return e.copy(a[0]).multiplyScalar(0.282095), e.addScaledVector(a[1], 0.488603 * i), e.addScaledVector(a[2], 0.488603 * r), e.addScaledVector(a[3], 0.488603 * n), e.addScaledVector(a[4], n * i * 1.092548), e.addScaledVector(a[5], i * r * 1.092548), e.addScaledVector(a[6], 0.315392 * (3 * r * r - 1)), e.addScaledVector(a[7], n * r * 1.092548), e.addScaledVector(a[8], 0.546274 * (n * n - i * i)), e;
					}
					getIrradianceAt(t, e) {
						const n = t.x,
							i = t.y,
							r = t.z,
							a = this.coefficients;
						return e.copy(a[0]).multiplyScalar(0.886227), e.addScaledVector(a[1], 1.023328 * i), e.addScaledVector(a[2], 1.023328 * r), e.addScaledVector(a[3], 1.023328 * n), e.addScaledVector(a[4], 0.858086 * n * i), e.addScaledVector(a[5], 0.858086 * i * r), e.addScaledVector(a[6], 0.743125 * r * r - 0.247708), e.addScaledVector(a[7], 0.858086 * n * r), e.addScaledVector(a[8], 0.429043 * (n * n - i * i)), e;
					}
					add(t) {
						for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
						return this;
					}
					addScaledSH(t, e) {
						for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(t.coefficients[n], e);
						return this;
					}
					scale(t) {
						for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
						return this;
					}
					lerp(t, e) {
						for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e);
						return this;
					}
					equals(t) {
						for (let e = 0; e < 9; e++) if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
						return !0;
					}
					copy(t) {
						return this.set(t.coefficients);
					}
					clone() {
						return new this.constructor().copy(this);
					}
					fromArray(t, e = 0) {
						const n = this.coefficients;
						for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i);
						return this;
					}
					toArray(t = [], e = 0) {
						const n = this.coefficients;
						for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i);
						return t;
					}
					static getBasisAt(t, e) {
						const n = t.x,
							i = t.y,
							r = t.z;
						(e[0] = 0.282095), (e[1] = 0.488603 * i), (e[2] = 0.488603 * r), (e[3] = 0.488603 * n), (e[4] = 1.092548 * n * i), (e[5] = 1.092548 * i * r), (e[6] = 0.315392 * (3 * r * r - 1)), (e[7] = 1.092548 * n * r), (e[8] = 0.546274 * (n * n - i * i));
					}
				}
				nc.prototype.isSphericalHarmonics3 = !0;
				class ic extends Bl {
					constructor(t = new nc(), e = 1) {
						super(void 0, e), (this.sh = t);
					}
					copy(t) {
						return super.copy(t), this.sh.copy(t.sh), this;
					}
					fromJSON(t) {
						return (this.intensity = t.intensity), this.sh.fromArray(t.sh), this;
					}
					toJSON(t) {
						const e = super.toJSON(t);
						return (e.object.sh = this.sh.toArray()), e;
					}
				}
				ic.prototype.isLightProbe = !0;
				class rc {
					static decodeText(t) {
						if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(t);
						let e = "";
						for (let n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n]);
						try {
							return decodeURIComponent(escape(e));
						} catch (t) {
							return e;
						}
					}
					static extractUrlBase(t) {
						const e = t.lastIndexOf("/");
						return -1 === e ? "./" : t.substr(0, e + 1);
					}
				}
				class ac extends Ln {
					constructor() {
						super(), (this.type = "InstancedBufferGeometry"), (this.instanceCount = 1 / 0);
					}
					copy(t) {
						return super.copy(t), (this.instanceCount = t.instanceCount), this;
					}
					clone() {
						return new this.constructor().copy(this);
					}
					toJSON() {
						const t = super.toJSON(this);
						return (t.instanceCount = this.instanceCount), (t.isInstancedBufferGeometry = !0), t;
					}
				}
				ac.prototype.isInstancedBufferGeometry = !0;
				let sc;
				(class extends Ol {
					constructor(t) {
						super(t), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), (this.options = { premultiplyAlpha: "none" });
					}
					setOptions(t) {
						return (this.options = t), this;
					}
					load(t, e, n, i) {
						void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), (t = this.manager.resolveURL(t));
						const r = this,
							a = Ll.get(t);
						if (void 0 !== a)
							return (
								r.manager.itemStart(t),
								setTimeout(function () {
									e && e(a), r.manager.itemEnd(t);
								}, 0),
								a
							);
						const s = {};
						(s.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include"),
							(s.headers = this.requestHeader),
							fetch(t, s)
								.then(function (t) {
									return t.blob();
								})
								.then(function (t) {
									return createImageBitmap(t, Object.assign(r.options, { colorSpaceConversion: "none" }));
								})
								.then(function (n) {
									Ll.add(t, n), e && e(n), r.manager.itemEnd(t);
								})
								.catch(function (e) {
									i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
								}),
							r.manager.itemStart(t);
					}
				}.prototype.isImageBitmapLoader = !0);
				const oc = function () {
					return void 0 === sc && (sc = new (window.AudioContext || window.webkitAudioContext)()), sc;
				};
				class lc extends Ol {
					constructor(t) {
						super(t);
					}
					load(t, e, n, i) {
						const r = this,
							a = new Il(this.manager);
						a.setResponseType("arraybuffer"),
							a.setPath(this.path),
							a.setRequestHeader(this.requestHeader),
							a.setWithCredentials(this.withCredentials),
							a.load(
								t,
								function (n) {
									try {
										const t = n.slice(0);
										oc().decodeAudioData(t, function (t) {
											e(t);
										});
									} catch (e) {
										i ? i(e) : console.error(e), r.manager.itemError(t);
									}
								},
								n,
								i
							);
					}
				}
				(class extends ic {
					constructor(t, e, n = 1) {
						super(void 0, n);
						const i = new mn().set(t),
							r = new mn().set(e),
							a = new Xt(i.r, i.g, i.b),
							s = new Xt(r.r, r.g, r.b),
							o = Math.sqrt(Math.PI),
							l = o * Math.sqrt(0.75);
						this.sh.coefficients[0].copy(a).add(s).multiplyScalar(o), this.sh.coefficients[1].copy(a).sub(s).multiplyScalar(l);
					}
				}.prototype.isHemisphereLightProbe = !0);
				(class extends ic {
					constructor(t, e = 1) {
						super(void 0, e);
						const n = new mn().set(t);
						this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI));
					}
				}.prototype.isAmbientLightProbe = !0);
				class cc {
					constructor(t = !0) {
						(this.autoStart = t), (this.startTime = 0), (this.oldTime = 0), (this.elapsedTime = 0), (this.running = !1);
					}
					start() {
						(this.startTime = uc()), (this.oldTime = this.startTime), (this.elapsedTime = 0), (this.running = !0);
					}
					stop() {
						this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
					}
					getElapsedTime() {
						return this.getDelta(), this.elapsedTime;
					}
					getDelta() {
						let t = 0;
						if (this.autoStart && !this.running) return this.start(), 0;
						if (this.running) {
							const e = uc();
							(t = (e - this.oldTime) / 1e3), (this.oldTime = e), (this.elapsedTime += t);
						}
						return t;
					}
				}
				function uc() {
					return ("undefined" == typeof performance ? Date : performance).now();
				}
				class hc extends Ye {
					constructor(t) {
						super(),
							(this.type = "Audio"),
							(this.listener = t),
							(this.context = t.context),
							(this.gain = this.context.createGain()),
							this.gain.connect(t.getInput()),
							(this.autoplay = !1),
							(this.buffer = null),
							(this.detune = 0),
							(this.loop = !1),
							(this.loopStart = 0),
							(this.loopEnd = 0),
							(this.offset = 0),
							(this.duration = void 0),
							(this.playbackRate = 1),
							(this.isPlaying = !1),
							(this.hasPlaybackControl = !0),
							(this.source = null),
							(this.sourceType = "empty"),
							(this._startedAt = 0),
							(this._progress = 0),
							(this._connected = !1),
							(this.filters = []);
					}
					getOutput() {
						return this.gain;
					}
					setNodeSource(t) {
						return (this.hasPlaybackControl = !1), (this.sourceType = "audioNode"), (this.source = t), this.connect(), this;
					}
					setMediaElementSource(t) {
						return (this.hasPlaybackControl = !1), (this.sourceType = "mediaNode"), (this.source = this.context.createMediaElementSource(t)), this.connect(), this;
					}
					setMediaStreamSource(t) {
						return (this.hasPlaybackControl = !1), (this.sourceType = "mediaStreamNode"), (this.source = this.context.createMediaStreamSource(t)), this.connect(), this;
					}
					setBuffer(t) {
						return (this.buffer = t), (this.sourceType = "buffer"), this.autoplay && this.play(), this;
					}
					play(t = 0) {
						if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
						if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
						this._startedAt = this.context.currentTime + t;
						const e = this.context.createBufferSource();
						return (e.buffer = this.buffer), (e.loop = this.loop), (e.loopStart = this.loopStart), (e.loopEnd = this.loopEnd), (e.onended = this.onEnded.bind(this)), e.start(this._startedAt, this._progress + this.offset, this.duration), (this.isPlaying = !0), (this.source = e), this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
					}
					pause() {
						if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && ((this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate), !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), (this.source.onended = null), (this.isPlaying = !1)), this;
						console.warn("THREE.Audio: this Audio has no playback control.");
					}
					stop() {
						if (!1 !== this.hasPlaybackControl) return (this._progress = 0), this.source.stop(), (this.source.onended = null), (this.isPlaying = !1), this;
						console.warn("THREE.Audio: this Audio has no playback control.");
					}
					connect() {
						if (this.filters.length > 0) {
							this.source.connect(this.filters[0]);
							for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
							this.filters[this.filters.length - 1].connect(this.getOutput());
						} else this.source.connect(this.getOutput());
						return (this._connected = !0), this;
					}
					disconnect() {
						if (this.filters.length > 0) {
							this.source.disconnect(this.filters[0]);
							for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
							this.filters[this.filters.length - 1].disconnect(this.getOutput());
						} else this.source.disconnect(this.getOutput());
						return (this._connected = !1), this;
					}
					getFilters() {
						return this.filters;
					}
					setFilters(t) {
						return t || (t = []), !0 === this._connected ? (this.disconnect(), (this.filters = t.slice()), this.connect()) : (this.filters = t.slice()), this;
					}
					setDetune(t) {
						if (((this.detune = t), void 0 !== this.source.detune)) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
					}
					getDetune() {
						return this.detune;
					}
					getFilter() {
						return this.getFilters()[0];
					}
					setFilter(t) {
						return this.setFilters(t ? [t] : []);
					}
					setPlaybackRate(t) {
						if (!1 !== this.hasPlaybackControl) return (this.playbackRate = t), !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
						console.warn("THREE.Audio: this Audio has no playback control.");
					}
					getPlaybackRate() {
						return this.playbackRate;
					}
					onEnded() {
						this.isPlaying = !1;
					}
					getLoop() {
						return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
					}
					setLoop(t) {
						if (!1 !== this.hasPlaybackControl) return (this.loop = t), !0 === this.isPlaying && (this.source.loop = this.loop), this;
						console.warn("THREE.Audio: this Audio has no playback control.");
					}
					setLoopStart(t) {
						return (this.loopStart = t), this;
					}
					setLoopEnd(t) {
						return (this.loopEnd = t), this;
					}
					getVolume() {
						return this.gain.gain.value;
					}
					setVolume(t) {
						return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this;
					}
				}
				class dc {
					constructor(t, e, n) {
						let i, r, a;
						switch (((this.binding = t), (this.valueSize = n), e)) {
							case "quaternion":
								(i = this._slerp), (r = this._slerpAdditive), (a = this._setAdditiveIdentityQuaternion), (this.buffer = new Float64Array(6 * n)), (this._workIndex = 5);
								break;
							case "string":
							case "bool":
								(i = this._select), (r = this._select), (a = this._setAdditiveIdentityOther), (this.buffer = new Array(5 * n));
								break;
							default:
								(i = this._lerp), (r = this._lerpAdditive), (a = this._setAdditiveIdentityNumeric), (this.buffer = new Float64Array(5 * n));
						}
						(this._mixBufferRegion = i), (this._mixBufferRegionAdditive = r), (this._setIdentity = a), (this._origIndex = 3), (this._addIndex = 4), (this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), (this.useCount = 0), (this.referenceCount = 0);
					}
					accumulate(t, e) {
						const n = this.buffer,
							i = this.valueSize,
							r = t * i + i;
						let a = this.cumulativeWeight;
						if (0 === a) {
							for (let t = 0; t !== i; ++t) n[r + t] = n[t];
							a = e;
						} else {
							a += e;
							const t = e / a;
							this._mixBufferRegion(n, r, 0, t, i);
						}
						this.cumulativeWeight = a;
					}
					accumulateAdditive(t) {
						const e = this.buffer,
							n = this.valueSize,
							i = n * this._addIndex;
						0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, i, 0, t, n), (this.cumulativeWeightAdditive += t);
					}
					apply(t) {
						const e = this.valueSize,
							n = this.buffer,
							i = t * e + e,
							r = this.cumulativeWeight,
							a = this.cumulativeWeightAdditive,
							s = this.binding;
						if (((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), r < 1)) {
							const t = e * this._origIndex;
							this._mixBufferRegion(n, i, t, 1 - r, e);
						}
						a > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
						for (let t = e, r = e + e; t !== r; ++t)
							if (n[t] !== n[t + e]) {
								s.setValue(n, i);
								break;
							}
					}
					saveOriginalState() {
						const t = this.binding,
							e = this.buffer,
							n = this.valueSize,
							i = n * this._origIndex;
						t.getValue(e, i);
						for (let t = n, r = i; t !== r; ++t) e[t] = e[i + (t % n)];
						this._setIdentity(), (this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0);
					}
					restoreOriginalState() {
						const t = 3 * this.valueSize;
						this.binding.setValue(this.buffer, t);
					}
					_setAdditiveIdentityNumeric() {
						const t = this._addIndex * this.valueSize,
							e = t + this.valueSize;
						for (let n = t; n < e; n++) this.buffer[n] = 0;
					}
					_setAdditiveIdentityQuaternion() {
						this._setAdditiveIdentityNumeric(), (this.buffer[this._addIndex * this.valueSize + 3] = 1);
					}
					_setAdditiveIdentityOther() {
						const t = this._origIndex * this.valueSize,
							e = this._addIndex * this.valueSize;
						for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n];
					}
					_select(t, e, n, i, r) {
						if (i >= 0.5) for (let i = 0; i !== r; ++i) t[e + i] = t[n + i];
					}
					_slerp(t, e, n, i) {
						jt.slerpFlat(t, e, t, e, t, n, i);
					}
					_slerpAdditive(t, e, n, i, r) {
						const a = this._workIndex * r;
						jt.multiplyQuaternionsFlat(t, a, t, e, t, n), jt.slerpFlat(t, e, t, e, t, a, i);
					}
					_lerp(t, e, n, i, r) {
						const a = 1 - i;
						for (let s = 0; s !== r; ++s) {
							const r = e + s;
							t[r] = t[r] * a + t[n + s] * i;
						}
					}
					_lerpAdditive(t, e, n, i, r) {
						for (let a = 0; a !== r; ++a) {
							const r = e + a;
							t[r] = t[r] + t[n + a] * i;
						}
					}
				}
				const pc = "\\[\\]\\.:\\/",
					fc = new RegExp("[\\[\\]\\.:\\/]", "g"),
					mc = "[^\\[\\]\\.:\\/]",
					vc = "[^" + pc.replace("\\.", "") + "]",
					gc = /((?:WC+[\/:])*)/.source.replace("WC", mc),
					bc = /(WCOD+)?/.source.replace("WCOD", vc),
					xc = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", mc),
					yc = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", mc),
					_c = new RegExp("^" + gc + bc + xc + yc + "$"),
					wc = ["material", "materials", "bones"];
				class Mc {
					constructor(t, e, n) {
						(this.path = e), (this.parsedPath = n || Mc.parseTrackName(e)), (this.node = Mc.findNode(t, this.parsedPath.nodeName) || t), (this.rootNode = t), (this.getValue = this._getValue_unbound), (this.setValue = this._setValue_unbound);
					}
					static create(t, e, n) {
						return t && t.isAnimationObjectGroup ? new Mc.Composite(t, e, n) : new Mc(t, e, n);
					}
					static sanitizeNodeName(t) {
						return t.replace(/\s/g, "_").replace(fc, "");
					}
					static parseTrackName(t) {
						const e = _c.exec(t);
						if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
						const n = { nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6] },
							i = n.nodeName && n.nodeName.lastIndexOf(".");
						if (void 0 !== i && -1 !== i) {
							const t = n.nodeName.substring(i + 1);
							-1 !== wc.indexOf(t) && ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = t));
						}
						if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
						return n;
					}
					static findNode(t, e) {
						if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
						if (t.skeleton) {
							const n = t.skeleton.getBoneByName(e);
							if (void 0 !== n) return n;
						}
						if (t.children) {
							const n = function (t) {
									for (let i = 0; i < t.length; i++) {
										const r = t[i];
										if (r.name === e || r.uuid === e) return r;
										const a = n(r.children);
										if (a) return a;
									}
									return null;
								},
								i = n(t.children);
							if (i) return i;
						}
						return null;
					}
					_getValue_unavailable() {}
					_setValue_unavailable() {}
					_getValue_direct(t, e) {
						t[e] = this.targetObject[this.propertyName];
					}
					_getValue_array(t, e) {
						const n = this.resolvedProperty;
						for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i];
					}
					_getValue_arrayElement(t, e) {
						t[e] = this.resolvedProperty[this.propertyIndex];
					}
					_getValue_toArray(t, e) {
						this.resolvedProperty.toArray(t, e);
					}
					_setValue_direct(t, e) {
						this.targetObject[this.propertyName] = t[e];
					}
					_setValue_direct_setNeedsUpdate(t, e) {
						(this.targetObject[this.propertyName] = t[e]), (this.targetObject.needsUpdate = !0);
					}
					_setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
						(this.targetObject[this.propertyName] = t[e]), (this.targetObject.matrixWorldNeedsUpdate = !0);
					}
					_setValue_array(t, e) {
						const n = this.resolvedProperty;
						for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
					}
					_setValue_array_setNeedsUpdate(t, e) {
						const n = this.resolvedProperty;
						for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
						this.targetObject.needsUpdate = !0;
					}
					_setValue_array_setMatrixWorldNeedsUpdate(t, e) {
						const n = this.resolvedProperty;
						for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
						this.targetObject.matrixWorldNeedsUpdate = !0;
					}
					_setValue_arrayElement(t, e) {
						this.resolvedProperty[this.propertyIndex] = t[e];
					}
					_setValue_arrayElement_setNeedsUpdate(t, e) {
						(this.resolvedProperty[this.propertyIndex] = t[e]), (this.targetObject.needsUpdate = !0);
					}
					_setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
						(this.resolvedProperty[this.propertyIndex] = t[e]), (this.targetObject.matrixWorldNeedsUpdate = !0);
					}
					_setValue_fromArray(t, e) {
						this.resolvedProperty.fromArray(t, e);
					}
					_setValue_fromArray_setNeedsUpdate(t, e) {
						this.resolvedProperty.fromArray(t, e), (this.targetObject.needsUpdate = !0);
					}
					_setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
						this.resolvedProperty.fromArray(t, e), (this.targetObject.matrixWorldNeedsUpdate = !0);
					}
					_getValue_unbound(t, e) {
						this.bind(), this.getValue(t, e);
					}
					_setValue_unbound(t, e) {
						this.bind(), this.setValue(t, e);
					}
					bind() {
						let t = this.node;
						const e = this.parsedPath,
							n = e.objectName,
							i = e.propertyName;
						let r = e.propertyIndex;
						if ((t || ((t = Mc.findNode(this.rootNode, e.nodeName) || this.rootNode), (this.node = t)), (this.getValue = this._getValue_unavailable), (this.setValue = this._setValue_unavailable), !t)) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
						if (n) {
							let i = e.objectIndex;
							switch (n) {
								case "materials":
									if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
									if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
									t = t.material.materials;
									break;
								case "bones":
									if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
									t = t.skeleton.bones;
									for (let e = 0; e < t.length; e++)
										if (t[e].name === i) {
											i = e;
											break;
										}
									break;
								default:
									if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
									t = t[n];
							}
							if (void 0 !== i) {
								if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
								t = t[i];
							}
						}
						const a = t[i];
						if (void 0 === a) {
							const n = e.nodeName;
							return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", t);
						}
						let s = this.Versioning.None;
						(this.targetObject = t), void 0 !== t.needsUpdate ? (s = this.Versioning.NeedsUpdate) : void 0 !== t.matrixWorldNeedsUpdate && (s = this.Versioning.MatrixWorldNeedsUpdate);
						let o = this.BindingType.Direct;
						if (void 0 !== r) {
							if ("morphTargetInfluences" === i) {
								if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
								if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
								if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
								void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r]);
							}
							(o = this.BindingType.ArrayElement), (this.resolvedProperty = a), (this.propertyIndex = r);
						} else void 0 !== a.fromArray && void 0 !== a.toArray ? ((o = this.BindingType.HasFromToArray), (this.resolvedProperty = a)) : Array.isArray(a) ? ((o = this.BindingType.EntireArray), (this.resolvedProperty = a)) : (this.propertyName = i);
						(this.getValue = this.GetterByBindingType[o]), (this.setValue = this.SetterByBindingTypeAndVersioning[o][s]);
					}
					unbind() {
						(this.node = null), (this.getValue = this._getValue_unbound), (this.setValue = this._setValue_unbound);
					}
				}
				(Mc.Composite = class {
					constructor(t, e, n) {
						const i = n || Mc.parseTrackName(e);
						(this._targetGroup = t), (this._bindings = t.subscribe_(e, i));
					}
					getValue(t, e) {
						this.bind();
						const n = this._targetGroup.nCachedObjects_,
							i = this._bindings[n];
						void 0 !== i && i.getValue(t, e);
					}
					setValue(t, e) {
						const n = this._bindings;
						for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(t, e);
					}
					bind() {
						const t = this._bindings;
						for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind();
					}
					unbind() {
						const t = this._bindings;
						for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind();
					}
				}),
					(Mc.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }),
					(Mc.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }),
					(Mc.prototype.GetterByBindingType = [Mc.prototype._getValue_direct, Mc.prototype._getValue_array, Mc.prototype._getValue_arrayElement, Mc.prototype._getValue_toArray]),
					(Mc.prototype.SetterByBindingTypeAndVersioning = [
						[Mc.prototype._setValue_direct, Mc.prototype._setValue_direct_setNeedsUpdate, Mc.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
						[Mc.prototype._setValue_array, Mc.prototype._setValue_array_setNeedsUpdate, Mc.prototype._setValue_array_setMatrixWorldNeedsUpdate],
						[Mc.prototype._setValue_arrayElement, Mc.prototype._setValue_arrayElement_setNeedsUpdate, Mc.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
						[Mc.prototype._setValue_fromArray, Mc.prototype._setValue_fromArray_setNeedsUpdate, Mc.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate],
					]);
				class Sc {
					constructor(t, e, n = null, i = e.blendMode) {
						(this._mixer = t), (this._clip = e), (this._localRoot = n), (this.blendMode = i);
						const r = e.tracks,
							a = r.length,
							s = new Array(a),
							o = { endingStart: ot, endingEnd: ot };
						for (let t = 0; t !== a; ++t) {
							const e = r[t].createInterpolant(null);
							(s[t] = e), (e.settings = o);
						}
						(this._interpolantSettings = o),
							(this._interpolants = s),
							(this._propertyBindings = new Array(a)),
							(this._cacheIndex = null),
							(this._byClipCacheIndex = null),
							(this._timeScaleInterpolant = null),
							(this._weightInterpolant = null),
							(this.loop = 2201),
							(this._loopCount = -1),
							(this._startTime = null),
							(this.time = 0),
							(this.timeScale = 1),
							(this._effectiveTimeScale = 1),
							(this.weight = 1),
							(this._effectiveWeight = 1),
							(this.repetitions = 1 / 0),
							(this.paused = !1),
							(this.enabled = !0),
							(this.clampWhenFinished = !1),
							(this.zeroSlopeAtStart = !0),
							(this.zeroSlopeAtEnd = !0);
					}
					play() {
						return this._mixer._activateAction(this), this;
					}
					stop() {
						return this._mixer._deactivateAction(this), this.reset();
					}
					reset() {
						return (this.paused = !1), (this.enabled = !0), (this.time = 0), (this._loopCount = -1), (this._startTime = null), this.stopFading().stopWarping();
					}
					isRunning() {
						return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
					}
					isScheduled() {
						return this._mixer._isActiveAction(this);
					}
					startAt(t) {
						return (this._startTime = t), this;
					}
					setLoop(t, e) {
						return (this.loop = t), (this.repetitions = e), this;
					}
					setEffectiveWeight(t) {
						return (this.weight = t), (this._effectiveWeight = this.enabled ? t : 0), this.stopFading();
					}
					getEffectiveWeight() {
						return this._effectiveWeight;
					}
					fadeIn(t) {
						return this._scheduleFading(t, 0, 1);
					}
					fadeOut(t) {
						return this._scheduleFading(t, 1, 0);
					}
					crossFadeFrom(t, e, n) {
						if ((t.fadeOut(e), this.fadeIn(e), n)) {
							const n = this._clip.duration,
								i = t._clip.duration,
								r = i / n,
								a = n / i;
							t.warp(1, r, e), this.warp(a, 1, e);
						}
						return this;
					}
					crossFadeTo(t, e, n) {
						return t.crossFadeFrom(this, e, n);
					}
					stopFading() {
						const t = this._weightInterpolant;
						return null !== t && ((this._weightInterpolant = null), this._mixer._takeBackControlInterpolant(t)), this;
					}
					setEffectiveTimeScale(t) {
						return (this.timeScale = t), (this._effectiveTimeScale = this.paused ? 0 : t), this.stopWarping();
					}
					getEffectiveTimeScale() {
						return this._effectiveTimeScale;
					}
					setDuration(t) {
						return (this.timeScale = this._clip.duration / t), this.stopWarping();
					}
					syncWith(t) {
						return (this.time = t.time), (this.timeScale = t.timeScale), this.stopWarping();
					}
					halt(t) {
						return this.warp(this._effectiveTimeScale, 0, t);
					}
					warp(t, e, n) {
						const i = this._mixer,
							r = i.time,
							a = this.timeScale;
						let s = this._timeScaleInterpolant;
						null === s && ((s = i._lendControlInterpolant()), (this._timeScaleInterpolant = s));
						const o = s.parameterPositions,
							l = s.sampleValues;
						return (o[0] = r), (o[1] = r + n), (l[0] = t / a), (l[1] = e / a), this;
					}
					stopWarping() {
						const t = this._timeScaleInterpolant;
						return null !== t && ((this._timeScaleInterpolant = null), this._mixer._takeBackControlInterpolant(t)), this;
					}
					getMixer() {
						return this._mixer;
					}
					getClip() {
						return this._clip;
					}
					getRoot() {
						return this._localRoot || this._mixer._root;
					}
					_update(t, e, n, i) {
						if (!this.enabled) return void this._updateWeight(t);
						const r = this._startTime;
						if (null !== r) {
							const i = (t - r) * n;
							if (i < 0 || 0 === n) return;
							(this._startTime = null), (e = n * i);
						}
						e *= this._updateTimeScale(t);
						const a = this._updateTime(e),
							s = this._updateWeight(t);
						if (s > 0) {
							const t = this._interpolants,
								e = this._propertyBindings;
							switch (this.blendMode) {
								case 2501:
									for (let n = 0, i = t.length; n !== i; ++n) t[n].evaluate(a), e[n].accumulateAdditive(s);
									break;
								case ut:
								default:
									for (let n = 0, r = t.length; n !== r; ++n) t[n].evaluate(a), e[n].accumulate(i, s);
							}
						}
					}
					_updateWeight(t) {
						let e = 0;
						if (this.enabled) {
							e = this.weight;
							const n = this._weightInterpolant;
							if (null !== n) {
								const i = n.evaluate(t)[0];
								(e *= i), t > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1));
							}
						}
						return (this._effectiveWeight = e), e;
					}
					_updateTimeScale(t) {
						let e = 0;
						if (!this.paused) {
							e = this.timeScale;
							const n = this._timeScaleInterpolant;
							if (null !== n) {
								(e *= n.evaluate(t)[0]), t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? (this.paused = !0) : (this.timeScale = e));
							}
						}
						return (this._effectiveTimeScale = e), e;
					}
					_updateTime(t) {
						const e = this._clip.duration,
							n = this.loop;
						let i = this.time + t,
							r = this._loopCount;
						const a = 2202 === n;
						if (0 === t) return -1 === r ? i : a && 1 == (1 & r) ? e - i : i;
						if (2200 === n) {
							-1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
							t: {
								if (i >= e) i = e;
								else {
									if (!(i < 0)) {
										this.time = i;
										break t;
									}
									i = 0;
								}
								this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1), (this.time = i), this._mixer.dispatchEvent({ type: "finished", action: this, direction: t < 0 ? -1 : 1 });
							}
						} else {
							if ((-1 === r && (t >= 0 ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), i >= e || i < 0)) {
								const n = Math.floor(i / e);
								(i -= e * n), (r += Math.abs(n));
								const s = this.repetitions - r;
								if (s <= 0) this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1), (i = t > 0 ? e : 0), (this.time = i), this._mixer.dispatchEvent({ type: "finished", action: this, direction: t > 0 ? 1 : -1 });
								else {
									if (1 === s) {
										const e = t < 0;
										this._setEndings(e, !e, a);
									} else this._setEndings(!1, !1, a);
									(this._loopCount = r), (this.time = i), this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: n });
								}
							} else this.time = i;
							if (a && 1 == (1 & r)) return e - i;
						}
						return i;
					}
					_setEndings(t, e, n) {
						const i = this._interpolantSettings;
						n ? ((i.endingStart = lt), (i.endingEnd = lt)) : ((i.endingStart = t ? (this.zeroSlopeAtStart ? lt : ot) : ct), (i.endingEnd = e ? (this.zeroSlopeAtEnd ? lt : ot) : ct));
					}
					_scheduleFading(t, e, n) {
						const i = this._mixer,
							r = i.time;
						let a = this._weightInterpolant;
						null === a && ((a = i._lendControlInterpolant()), (this._weightInterpolant = a));
						const s = a.parameterPositions,
							o = a.sampleValues;
						return (s[0] = r), (o[0] = e), (s[1] = r + t), (o[1] = n), this;
					}
				}
				(class extends xt {
					constructor(t) {
						super(), (this._root = t), this._initMemoryManager(), (this._accuIndex = 0), (this.time = 0), (this.timeScale = 1);
					}
					_bindAction(t, e) {
						const n = t._localRoot || this._root,
							i = t._clip.tracks,
							r = i.length,
							a = t._propertyBindings,
							s = t._interpolants,
							o = n.uuid,
							l = this._bindingsByRootAndName;
						let c = l[o];
						void 0 === c && ((c = {}), (l[o] = c));
						for (let t = 0; t !== r; ++t) {
							const r = i[t],
								l = r.name;
							let u = c[l];
							if (void 0 !== u) a[t] = u;
							else {
								if (((u = a[t]), void 0 !== u)) {
									null === u._cacheIndex && (++u.referenceCount, this._addInactiveBinding(u, o, l));
									continue;
								}
								const i = e && e._propertyBindings[t].binding.parsedPath;
								(u = new dc(Mc.create(n, l, i), r.ValueTypeName, r.getValueSize())), ++u.referenceCount, this._addInactiveBinding(u, o, l), (a[t] = u);
							}
							s[t].resultBuffer = u.buffer;
						}
					}
					_activateAction(t) {
						if (!this._isActiveAction(t)) {
							if (null === t._cacheIndex) {
								const e = (t._localRoot || this._root).uuid,
									n = t._clip.uuid,
									i = this._actionsByClip[n];
								this._bindAction(t, i && i.knownActions[0]), this._addInactiveAction(t, n, e);
							}
							const e = t._propertyBindings;
							for (let t = 0, n = e.length; t !== n; ++t) {
								const n = e[t];
								0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState());
							}
							this._lendAction(t);
						}
					}
					_deactivateAction(t) {
						if (this._isActiveAction(t)) {
							const e = t._propertyBindings;
							for (let t = 0, n = e.length; t !== n; ++t) {
								const n = e[t];
								0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n));
							}
							this._takeBackAction(t);
						}
					}
					_initMemoryManager() {
						(this._actions = []), (this._nActiveActions = 0), (this._actionsByClip = {}), (this._bindings = []), (this._nActiveBindings = 0), (this._bindingsByRootAndName = {}), (this._controlInterpolants = []), (this._nActiveControlInterpolants = 0);
						const t = this;
						this.stats = {
							actions: {
								get total() {
									return t._actions.length;
								},
								get inUse() {
									return t._nActiveActions;
								},
							},
							bindings: {
								get total() {
									return t._bindings.length;
								},
								get inUse() {
									return t._nActiveBindings;
								},
							},
							controlInterpolants: {
								get total() {
									return t._controlInterpolants.length;
								},
								get inUse() {
									return t._nActiveControlInterpolants;
								},
							},
						};
					}
					_isActiveAction(t) {
						const e = t._cacheIndex;
						return null !== e && e < this._nActiveActions;
					}
					_addInactiveAction(t, e, n) {
						const i = this._actions,
							r = this._actionsByClip;
						let a = r[e];
						if (void 0 === a) (a = { knownActions: [t], actionByRoot: {} }), (t._byClipCacheIndex = 0), (r[e] = a);
						else {
							const e = a.knownActions;
							(t._byClipCacheIndex = e.length), e.push(t);
						}
						(t._cacheIndex = i.length), i.push(t), (a.actionByRoot[n] = t);
					}
					_removeInactiveAction(t) {
						const e = this._actions,
							n = e[e.length - 1],
							i = t._cacheIndex;
						(n._cacheIndex = i), (e[i] = n), e.pop(), (t._cacheIndex = null);
						const r = t._clip.uuid,
							a = this._actionsByClip,
							s = a[r],
							o = s.knownActions,
							l = o[o.length - 1],
							c = t._byClipCacheIndex;
						(l._byClipCacheIndex = c), (o[c] = l), o.pop(), (t._byClipCacheIndex = null);
						delete s.actionByRoot[(t._localRoot || this._root).uuid], 0 === o.length && delete a[r], this._removeInactiveBindingsForAction(t);
					}
					_removeInactiveBindingsForAction(t) {
						const e = t._propertyBindings;
						for (let t = 0, n = e.length; t !== n; ++t) {
							const n = e[t];
							0 == --n.referenceCount && this._removeInactiveBinding(n);
						}
					}
					_lendAction(t) {
						const e = this._actions,
							n = t._cacheIndex,
							i = this._nActiveActions++,
							r = e[i];
						(t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
					}
					_takeBackAction(t) {
						const e = this._actions,
							n = t._cacheIndex,
							i = --this._nActiveActions,
							r = e[i];
						(t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
					}
					_addInactiveBinding(t, e, n) {
						const i = this._bindingsByRootAndName,
							r = this._bindings;
						let a = i[e];
						void 0 === a && ((a = {}), (i[e] = a)), (a[n] = t), (t._cacheIndex = r.length), r.push(t);
					}
					_removeInactiveBinding(t) {
						const e = this._bindings,
							n = t.binding,
							i = n.rootNode.uuid,
							r = n.path,
							a = this._bindingsByRootAndName,
							s = a[i],
							o = e[e.length - 1],
							l = t._cacheIndex;
						(o._cacheIndex = l), (e[l] = o), e.pop(), delete s[r], 0 === Object.keys(s).length && delete a[i];
					}
					_lendBinding(t) {
						const e = this._bindings,
							n = t._cacheIndex,
							i = this._nActiveBindings++,
							r = e[i];
						(t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
					}
					_takeBackBinding(t) {
						const e = this._bindings,
							n = t._cacheIndex,
							i = --this._nActiveBindings,
							r = e[i];
						(t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
					}
					_lendControlInterpolant() {
						const t = this._controlInterpolants,
							e = this._nActiveControlInterpolants++;
						let n = t[e];
						return void 0 === n && ((n = new bl(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)), (n.__cacheIndex = e), (t[e] = n)), n;
					}
					_takeBackControlInterpolant(t) {
						const e = this._controlInterpolants,
							n = t.__cacheIndex,
							i = --this._nActiveControlInterpolants,
							r = e[i];
						(t.__cacheIndex = i), (e[i] = t), (r.__cacheIndex = n), (e[n] = r);
					}
					clipAction(t, e, n) {
						const i = e || this._root,
							r = i.uuid;
						let a = "string" == typeof t ? Pl.findByName(i, t) : t;
						const s = null !== a ? a.uuid : t,
							o = this._actionsByClip[s];
						let l = null;
						if ((void 0 === n && (n = null !== a ? a.blendMode : ut), void 0 !== o)) {
							const t = o.actionByRoot[r];
							if (void 0 !== t && t.blendMode === n) return t;
							(l = o.knownActions[0]), null === a && (a = l._clip);
						}
						if (null === a) return null;
						const c = new Sc(this, a, e, n);
						return this._bindAction(c, l), this._addInactiveAction(c, s, r), c;
					}
					existingAction(t, e) {
						const n = e || this._root,
							i = n.uuid,
							r = "string" == typeof t ? Pl.findByName(n, t) : t,
							a = r ? r.uuid : t,
							s = this._actionsByClip[a];
						return (void 0 !== s && s.actionByRoot[i]) || null;
					}
					stopAllAction() {
						const t = this._actions;
						for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
						return this;
					}
					update(t) {
						t *= this.timeScale;
						const e = this._actions,
							n = this._nActiveActions,
							i = (this.time += t),
							r = Math.sign(t),
							a = (this._accuIndex ^= 1);
						for (let s = 0; s !== n; ++s) {
							e[s]._update(i, t, r, a);
						}
						const s = this._bindings,
							o = this._nActiveBindings;
						for (let t = 0; t !== o; ++t) s[t].apply(a);
						return this;
					}
					setTime(t) {
						this.time = 0;
						for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
						return this.update(t);
					}
					getRoot() {
						return this._root;
					}
					uncacheClip(t) {
						const e = this._actions,
							n = t.uuid,
							i = this._actionsByClip,
							r = i[n];
						if (void 0 !== r) {
							const t = r.knownActions;
							for (let n = 0, i = t.length; n !== i; ++n) {
								const i = t[n];
								this._deactivateAction(i);
								const r = i._cacheIndex,
									a = e[e.length - 1];
								(i._cacheIndex = null), (i._byClipCacheIndex = null), (a._cacheIndex = r), (e[r] = a), e.pop(), this._removeInactiveBindingsForAction(i);
							}
							delete i[n];
						}
					}
					uncacheRoot(t) {
						const e = t.uuid,
							n = this._actionsByClip;
						for (const t in n) {
							const i = n[t].actionByRoot[e];
							void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i));
						}
						const i = this._bindingsByRootAndName[e];
						if (void 0 !== i)
							for (const t in i) {
								const e = i[t];
								e.restoreOriginalState(), this._removeInactiveBinding(e);
							}
					}
					uncacheAction(t, e) {
						const n = this.existingAction(t, e);
						null !== n && (this._deactivateAction(n), this._removeInactiveAction(n));
					}
				}.prototype._controlInterpolantsResultBuffer = new Float32Array(1));
				class Tc {
					constructor(t) {
						"string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), (t = arguments[1])), (this.value = t);
					}
					clone() {
						return new Tc(void 0 === this.value.clone ? this.value : this.value.clone());
					}
				}
				(class extends as {
					constructor(t, e, n = 1) {
						super(t, e), (this.meshPerAttribute = n);
					}
					copy(t) {
						return super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this;
					}
					clone(t) {
						const e = super.clone(t);
						return (e.meshPerAttribute = this.meshPerAttribute), e;
					}
					toJSON(t) {
						const e = super.toJSON(t);
						return (e.isInstancedInterleavedBuffer = !0), (e.meshPerAttribute = this.meshPerAttribute), e;
					}
				}.prototype.isInstancedInterleavedBuffer = !0);
				class Ec {
					constructor(t, e, n = 0, i = 1 / 0) {
						(this.ray = new we(t, e)), (this.near = n), (this.far = i), (this.camera = null), (this.layers = new ze()), (this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} });
					}
					set(t, e) {
						this.ray.set(t, e);
					}
					setFromCamera(t, e) {
						e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, 0.5).unproject(e).sub(this.ray.origin).normalize(), (this.camera = e)) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), (this.camera = e)) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type);
					}
					intersectObject(t, e = !0, n = []) {
						return Pc(t, this, n, e), n.sort(Cc), n;
					}
					intersectObjects(t, e = !0, n = []) {
						for (let i = 0, r = t.length; i < r; i++) Pc(t[i], this, n, e);
						return n.sort(Cc), n;
					}
				}
				function Cc(t, e) {
					return t.distance - e.distance;
				}
				function Pc(t, e, n, i) {
					if ((t.layers.test(e.layers) && t.raycast(e, n), !0 === i)) {
						const i = t.children;
						for (let t = 0, r = i.length; t < r; t++) Pc(i[t], e, n, !0);
					}
				}
				class Ac {
					constructor(t = 1, e = 0, n = 0) {
						return (this.radius = t), (this.phi = e), (this.theta = n), this;
					}
					set(t, e, n) {
						return (this.radius = t), (this.phi = e), (this.theta = n), this;
					}
					copy(t) {
						return (this.radius = t.radius), (this.phi = t.phi), (this.theta = t.theta), this;
					}
					makeSafe() {
						const t = 1e-6;
						return (this.phi = Math.max(t, Math.min(Math.PI - t, this.phi))), this;
					}
					setFromVector3(t) {
						return this.setFromCartesianCoords(t.x, t.y, t.z);
					}
					setFromCartesianCoords(t, e, n) {
						return (this.radius = Math.sqrt(t * t + e * e + n * n)), 0 === this.radius ? ((this.theta = 0), (this.phi = 0)) : ((this.theta = Math.atan2(t, n)), (this.phi = Math.acos(Et(e / this.radius, -1, 1)))), this;
					}
					clone() {
						return new this.constructor().copy(this);
					}
				}
				const Lc = new Ot();
				class Rc {
					constructor(t = new Ot(1 / 0, 1 / 0), e = new Ot(-1 / 0, -1 / 0)) {
						(this.min = t), (this.max = e);
					}
					set(t, e) {
						return this.min.copy(t), this.max.copy(e), this;
					}
					setFromPoints(t) {
						this.makeEmpty();
						for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
						return this;
					}
					setFromCenterAndSize(t, e) {
						const n = Lc.copy(e).multiplyScalar(0.5);
						return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
					}
					clone() {
						return new this.constructor().copy(this);
					}
					copy(t) {
						return this.min.copy(t.min), this.max.copy(t.max), this;
					}
					makeEmpty() {
						return (this.min.x = this.min.y = 1 / 0), (this.max.x = this.max.y = -1 / 0), this;
					}
					isEmpty() {
						return this.max.x < this.min.x || this.max.y < this.min.y;
					}
					getCenter(t) {
						return this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
					}
					getSize(t) {
						return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min);
					}
					expandByPoint(t) {
						return this.min.min(t), this.max.max(t), this;
					}
					expandByVector(t) {
						return this.min.sub(t), this.max.add(t), this;
					}
					expandByScalar(t) {
						return this.min.addScalar(-t), this.max.addScalar(t), this;
					}
					containsPoint(t) {
						return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y);
					}
					containsBox(t) {
						return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y;
					}
					getParameter(t, e) {
						return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y));
					}
					intersectsBox(t) {
						return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y);
					}
					clampPoint(t, e) {
						return e.copy(t).clamp(this.min, this.max);
					}
					distanceToPoint(t) {
						return Lc.copy(t).clamp(this.min, this.max).sub(t).length();
					}
					intersect(t) {
						return this.min.max(t.min), this.max.min(t.max), this;
					}
					union(t) {
						return this.min.min(t.min), this.max.max(t.max), this;
					}
					translate(t) {
						return this.min.add(t), this.max.add(t), this;
					}
					equals(t) {
						return t.min.equals(this.min) && t.max.equals(this.max);
					}
				}
				Rc.prototype.isBox2 = !0;
				(class extends Ye {
					constructor(t) {
						super(), (this.material = t), (this.render = function () {}), (this.hasPositions = !1), (this.hasNormals = !1), (this.hasColors = !1), (this.hasUvs = !1), (this.positionArray = null), (this.normalArray = null), (this.colorArray = null), (this.uvArray = null), (this.count = 0);
					}
				}.prototype.isImmediateRenderObject = !0);
				const Dc = new Xt(),
					Oc = new Me(),
					zc = new Me();
				function Ic(t) {
					const e = [];
					t && t.isBone && e.push(t);
					for (let n = 0; n < t.children.length; n++) e.push.apply(e, Ic(t.children[n]));
					return e;
				}
				const kc = new Float32Array(1);
				new Int32Array(kc.buffer);
				(ao.create = function (t, e) {
					return console.log("THREE.Curve.create() has been deprecated"), (t.prototype = Object.create(ao.prototype)), (t.prototype.constructor = t), (t.prototype.getPoint = e), t;
				}),
					(Eo.prototype.fromPoints = function (t) {
						return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t);
					}),
					(class extends qs {
						constructor(t = 10, e = 10, n = 4473924, i = 8947848) {
							(n = new mn(n)), (i = new mn(i));
							const r = e / 2,
								a = t / e,
								s = t / 2,
								o = [],
								l = [];
							for (let t = 0, c = 0, u = -s; t <= e; t++, u += a) {
								o.push(-s, 0, u, s, 0, u), o.push(u, 0, -s, u, 0, s);
								const e = t === r ? n : i;
								e.toArray(l, c), (c += 3), e.toArray(l, c), (c += 3), e.toArray(l, c), (c += 3), e.toArray(l, c), (c += 3);
							}
							const c = new Ln();
							c.setAttribute("position", new wn(o, 3)), c.setAttribute("color", new wn(l, 3));
							super(c, new Vs({ vertexColors: !0, toneMapped: !1 })), (this.type = "GridHelper");
						}
					}.prototype.setColors = function () {
						console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
					}),
					(class extends qs {
						constructor(t) {
							const e = Ic(t),
								n = new Ln(),
								i = [],
								r = [],
								a = new mn(0, 0, 1),
								s = new mn(0, 1, 0);
							for (let t = 0; t < e.length; t++) {
								const n = e[t];
								n.parent && n.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(a.r, a.g, a.b), r.push(s.r, s.g, s.b));
							}
							n.setAttribute("position", new wn(i, 3)), n.setAttribute("color", new wn(r, 3));
							super(n, new Vs({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 })), (this.type = "SkeletonHelper"), (this.isSkeletonHelper = !0), (this.root = t), (this.bones = e), (this.matrix = t.matrixWorld), (this.matrixAutoUpdate = !1);
						}
						updateMatrixWorld(t) {
							const e = this.bones,
								n = this.geometry,
								i = n.getAttribute("position");
							zc.copy(this.root.matrixWorld).invert();
							for (let t = 0, n = 0; t < e.length; t++) {
								const r = e[t];
								r.parent && r.parent.isBone && (Oc.multiplyMatrices(zc, r.matrixWorld), Dc.setFromMatrixPosition(Oc), i.setXYZ(n, Dc.x, Dc.y, Dc.z), Oc.multiplyMatrices(zc, r.parent.matrixWorld), Dc.setFromMatrixPosition(Oc), i.setXYZ(n + 1, Dc.x, Dc.y, Dc.z), (n += 2));
							}
							(n.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(t);
						}
					}.prototype.update = function () {
						console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
					}),
					(Ol.prototype.extractUrlBase = function (t) {
						return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), rc.extractUrlBase(t);
					}),
					(Ol.Handlers = {
						add: function () {
							console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
						},
						get: function () {
							console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
						},
					}),
					(Rc.prototype.center = function (t) {
						return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t);
					}),
					(Rc.prototype.empty = function () {
						return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
					}),
					(Rc.prototype.isIntersectionBox = function (t) {
						return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
					}),
					(Rc.prototype.size = function (t) {
						return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t);
					}),
					(Zt.prototype.center = function (t) {
						return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t);
					}),
					(Zt.prototype.empty = function () {
						return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
					}),
					(Zt.prototype.isIntersectionBox = function (t) {
						return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
					}),
					(Zt.prototype.isIntersectionSphere = function (t) {
						return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t);
					}),
					(Zt.prototype.size = function (t) {
						return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t);
					}),
					(fe.prototype.empty = function () {
						return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty();
					}),
					(pi.prototype.setFromMatrix = function (t) {
						return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t);
					}),
					(zt.prototype.flattenToArrayOffset = function (t, e) {
						return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e);
					}),
					(zt.prototype.multiplyVector3 = function (t) {
						return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this);
					}),
					(zt.prototype.multiplyVector3Array = function () {
						console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
					}),
					(zt.prototype.applyToBufferAttribute = function (t) {
						return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this);
					}),
					(zt.prototype.applyToVector3Array = function () {
						console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
					}),
					(zt.prototype.getInverse = function (t) {
						return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert();
					}),
					(Me.prototype.extractPosition = function (t) {
						return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t);
					}),
					(Me.prototype.flattenToArrayOffset = function (t, e) {
						return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e);
					}),
					(Me.prototype.getPosition = function () {
						return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), new Xt().setFromMatrixColumn(this, 3);
					}),
					(Me.prototype.setRotationFromQuaternion = function (t) {
						return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t);
					}),
					(Me.prototype.multiplyToArray = function () {
						console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
					}),
					(Me.prototype.multiplyVector3 = function (t) {
						return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
					}),
					(Me.prototype.multiplyVector4 = function (t) {
						return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
					}),
					(Me.prototype.multiplyVector3Array = function () {
						console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
					}),
					(Me.prototype.rotateAxis = function (t) {
						console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this);
					}),
					(Me.prototype.crossVector = function (t) {
						return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
					}),
					(Me.prototype.translate = function () {
						console.error("THREE.Matrix4: .translate() has been removed.");
					}),
					(Me.prototype.rotateX = function () {
						console.error("THREE.Matrix4: .rotateX() has been removed.");
					}),
					(Me.prototype.rotateY = function () {
						console.error("THREE.Matrix4: .rotateY() has been removed.");
					}),
					(Me.prototype.rotateZ = function () {
						console.error("THREE.Matrix4: .rotateZ() has been removed.");
					}),
					(Me.prototype.rotateByAxis = function () {
						console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
					}),
					(Me.prototype.applyToBufferAttribute = function (t) {
						return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
					}),
					(Me.prototype.applyToVector3Array = function () {
						console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
					}),
					(Me.prototype.makeFrustum = function (t, e, n, i, r, a) {
						return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, i, n, r, a);
					}),
					(Me.prototype.getInverse = function (t) {
						return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert();
					}),
					(ui.prototype.isIntersectionLine = function (t) {
						return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t);
					}),
					(jt.prototype.multiplyVector3 = function (t) {
						return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this);
					}),
					(jt.prototype.inverse = function () {
						return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert();
					}),
					(we.prototype.isIntersectionBox = function (t) {
						return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
					}),
					(we.prototype.isIntersectionPlane = function (t) {
						return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t);
					}),
					(we.prototype.isIntersectionSphere = function (t) {
						return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t);
					}),
					(sn.prototype.area = function () {
						return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
					}),
					(sn.prototype.barycoordFromPoint = function (t, e) {
						return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e);
					}),
					(sn.prototype.midpoint = function (t) {
						return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t);
					}),
					(sn.prototypenormal = function (t) {
						return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t);
					}),
					(sn.prototype.plane = function (t) {
						return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t);
					}),
					(sn.barycoordFromPoint = function (t, e, n, i, r) {
						return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), sn.getBarycoord(t, e, n, i, r);
					}),
					(sn.normal = function (t, e, n, i) {
						return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), sn.getNormal(t, e, n, i);
					}),
					(Co.prototype.extractAllPoints = function (t) {
						return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t);
					}),
					(Co.prototype.extrude = function (t) {
						return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new nl(this, t);
					}),
					(Co.prototype.makeGeometry = function (t) {
						return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new rl(this, t);
					}),
					(Ot.prototype.fromAttribute = function (t, e, n) {
						return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n);
					}),
					(Ot.prototype.distanceToManhattan = function (t) {
						return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t);
					}),
					(Ot.prototype.lengthManhattan = function () {
						return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
					}),
					(Xt.prototype.setEulerFromRotationMatrix = function () {
						console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
					}),
					(Xt.prototype.setEulerFromQuaternion = function () {
						console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
					}),
					(Xt.prototype.getPositionFromMatrix = function (t) {
						return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t);
					}),
					(Xt.prototype.getScaleFromMatrix = function (t) {
						return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t);
					}),
					(Xt.prototype.getColumnFromMatrix = function (t, e) {
						return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t);
					}),
					(Xt.prototype.applyProjection = function (t) {
						return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t);
					}),
					(Xt.prototype.fromAttribute = function (t, e, n) {
						return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n);
					}),
					(Xt.prototype.distanceToManhattan = function (t) {
						return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t);
					}),
					(Xt.prototype.lengthManhattan = function () {
						return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
					}),
					(Ht.prototype.fromAttribute = function (t, e, n) {
						return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n);
					}),
					(Ht.prototype.lengthManhattan = function () {
						return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
					}),
					(Ye.prototype.getChildByName = function (t) {
						return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t);
					}),
					(Ye.prototype.renderDepth = function () {
						console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
					}),
					(Ye.prototype.translate = function (t, e) {
						return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t);
					}),
					(Ye.prototype.getWorldRotation = function () {
						console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
					}),
					(Ye.prototype.applyMatrix = function (t) {
						return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t);
					}),
					Object.defineProperties(Ye.prototype, {
						eulerOrder: {
							get: function () {
								return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
							},
							set: function (t) {
								console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), (this.rotation.order = t);
							},
						},
						useQuaternion: {
							get: function () {
								console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
							},
							set: function () {
								console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
							},
						},
					}),
					(Yn.prototype.setDrawMode = function () {
						console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
					}),
					Object.defineProperties(Yn.prototype, {
						drawMode: {
							get: function () {
								return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0;
							},
							set: function () {
								console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
							},
						},
					}),
					(As.prototype.initBones = function () {
						console.error("THREE.SkinnedMesh: initBones() has been removed.");
					}),
					(ni.prototype.setLens = function (t, e) {
						console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t);
					}),
					Object.defineProperties(Bl.prototype, {
						onlyShadow: {
							set: function () {
								console.warn("THREE.Light: .onlyShadow has been removed.");
							},
						},
						shadowCameraFov: {
							set: function (t) {
								console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), (this.shadow.camera.fov = t);
							},
						},
						shadowCameraLeft: {
							set: function (t) {
								console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), (this.shadow.camera.left = t);
							},
						},
						shadowCameraRight: {
							set: function (t) {
								console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), (this.shadow.camera.right = t);
							},
						},
						shadowCameraTop: {
							set: function (t) {
								console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), (this.shadow.camera.top = t);
							},
						},
						shadowCameraBottom: {
							set: function (t) {
								console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), (this.shadow.camera.bottom = t);
							},
						},
						shadowCameraNear: {
							set: function (t) {
								console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), (this.shadow.camera.near = t);
							},
						},
						shadowCameraFar: {
							set: function (t) {
								console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), (this.shadow.camera.far = t);
							},
						},
						shadowCameraVisible: {
							set: function () {
								console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
							},
						},
						shadowBias: {
							set: function (t) {
								console.warn("THREE.Light: .shadowBias is now .shadow.bias."), (this.shadow.bias = t);
							},
						},
						shadowDarkness: {
							set: function () {
								console.warn("THREE.Light: .shadowDarkness has been removed.");
							},
						},
						shadowMapWidth: {
							set: function (t) {
								console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), (this.shadow.mapSize.width = t);
							},
						},
						shadowMapHeight: {
							set: function (t) {
								console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), (this.shadow.mapSize.height = t);
							},
						},
					}),
					Object.defineProperties(xn.prototype, {
						length: {
							get: function () {
								return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
							},
						},
						dynamic: {
							get: function () {
								return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === gt;
							},
							set: function () {
								console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(gt);
							},
						},
					}),
					(xn.prototype.setDynamic = function (t) {
						return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? gt : vt), this;
					}),
					(xn.prototype.copyIndicesArray = function () {
						console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
					}),
					(xn.prototype.setArray = function () {
						console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
					}),
					(Ln.prototype.addIndex = function (t) {
						console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t);
					}),
					(Ln.prototype.addAttribute = function (t, e) {
						return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), (e && e.isBufferAttribute) || (e && e.isInterleavedBufferAttribute) ? ("index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e)) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new xn(arguments[1], arguments[2])));
					}),
					(Ln.prototype.addDrawCall = function (t, e, n) {
						void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e);
					}),
					(Ln.prototype.clearDrawCalls = function () {
						console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
					}),
					(Ln.prototype.computeOffsets = function () {
						console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
					}),
					(Ln.prototype.removeAttribute = function (t) {
						return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t);
					}),
					(Ln.prototype.applyMatrix = function (t) {
						return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t);
					}),
					Object.defineProperties(Ln.prototype, {
						drawcalls: {
							get: function () {
								return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
							},
						},
						offsets: {
							get: function () {
								return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
							},
						},
					}),
					(as.prototype.setDynamic = function (t) {
						return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? gt : vt), this;
					}),
					(as.prototype.setArray = function () {
						console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
					}),
					(nl.prototype.getArrays = function () {
						console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
					}),
					(nl.prototype.addShapeList = function () {
						console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
					}),
					(nl.prototype.addShape = function () {
						console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
					}),
					(rs.prototype.dispose = function () {
						console.error("THREE.Scene: .dispose() has been removed.");
					}),
					(Tc.prototype.onUpdate = function () {
						return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this;
					}),
					Object.defineProperties(ln.prototype, {
						wrapAround: {
							get: function () {
								console.warn("THREE.Material: .wrapAround has been removed.");
							},
							set: function () {
								console.warn("THREE.Material: .wrapAround has been removed.");
							},
						},
						overdraw: {
							get: function () {
								console.warn("THREE.Material: .overdraw has been removed.");
							},
							set: function () {
								console.warn("THREE.Material: .overdraw has been removed.");
							},
						},
						wrapRGB: {
							get: function () {
								return console.warn("THREE.Material: .wrapRGB has been removed."), new mn();
							},
						},
						shading: {
							get: function () {
								console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
							},
							set: function (t) {
								console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), (this.flatShading = 1 === t);
							},
						},
						stencilMask: {
							get: function () {
								return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask;
							},
							set: function (t) {
								console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), (this.stencilFuncMask = t);
							},
						},
						vertexTangents: {
							get: function () {
								console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
							},
							set: function () {
								console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
							},
						},
					}),
					Object.defineProperties(ti.prototype, {
						derivatives: {
							get: function () {
								return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
							},
							set: function (t) {
								console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), (this.extensions.derivatives = t);
							},
						},
					}),
					(es.prototype.clearTarget = function (t, e, n, i) {
						console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, i);
					}),
					(es.prototype.animate = function (t) {
						console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t);
					}),
					(es.prototype.getCurrentRenderTarget = function () {
						return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
					}),
					(es.prototype.getMaxAnisotropy = function () {
						return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
					}),
					(es.prototype.getPrecision = function () {
						return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
					}),
					(es.prototype.resetGLState = function () {
						return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
					}),
					(es.prototype.supportsFloatTextures = function () {
						return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
					}),
					(es.prototype.supportsHalfFloatTextures = function () {
						return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
					}),
					(es.prototype.supportsStandardDerivatives = function () {
						return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
					}),
					(es.prototype.supportsCompressedTextureS3TC = function () {
						return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
					}),
					(es.prototype.supportsCompressedTexturePVRTC = function () {
						return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
					}),
					(es.prototype.supportsBlendMinMax = function () {
						return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
					}),
					(es.prototype.supportsVertexTextures = function () {
						return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
					}),
					(es.prototype.supportsInstancedArrays = function () {
						return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
					}),
					(es.prototype.enableScissorTest = function (t) {
						console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t);
					}),
					(es.prototype.initMaterial = function () {
						console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
					}),
					(es.prototype.addPrePlugin = function () {
						console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
					}),
					(es.prototype.addPostPlugin = function () {
						console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
					}),
					(es.prototype.updateShadowMap = function () {
						console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
					}),
					(es.prototype.setFaceCulling = function () {
						console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
					}),
					(es.prototype.allocTextureUnit = function () {
						console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
					}),
					(es.prototype.setTexture = function () {
						console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
					}),
					(es.prototype.setTexture2D = function () {
						console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
					}),
					(es.prototype.setTextureCube = function () {
						console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
					}),
					(es.prototype.getActiveMipMapLevel = function () {
						return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel();
					}),
					Object.defineProperties(es.prototype, {
						shadowMapEnabled: {
							get: function () {
								return this.shadowMap.enabled;
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), (this.shadowMap.enabled = t);
							},
						},
						shadowMapType: {
							get: function () {
								return this.shadowMap.type;
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), (this.shadowMap.type = t);
							},
						},
						shadowMapCullFace: {
							get: function () {
								console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
							},
							set: function () {
								console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
							},
						},
						context: {
							get: function () {
								return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext();
							},
						},
						vr: {
							get: function () {
								return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr;
							},
						},
						gammaInput: {
							get: function () {
								return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1;
							},
							set: function () {
								console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
							},
						},
						gammaOutput: {
							get: function () {
								return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1;
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), (this.outputEncoding = !0 === t ? dt : ht);
							},
						},
						toneMappingWhitePoint: {
							get: function () {
								return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1;
							},
							set: function () {
								console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
							},
						},
					}),
					Object.defineProperties(ja.prototype, {
						cullFace: {
							get: function () {
								console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
							},
							set: function () {
								console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
							},
						},
						renderReverseSided: {
							get: function () {
								console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
							},
							set: function () {
								console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
							},
						},
						renderSingleSided: {
							get: function () {
								console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
							},
							set: function () {
								console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
							},
						},
					}),
					Object.defineProperties(Gt.prototype, {
						wrapS: {
							get: function () {
								return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), (this.texture.wrapS = t);
							},
						},
						wrapT: {
							get: function () {
								return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), (this.texture.wrapT = t);
							},
						},
						magFilter: {
							get: function () {
								return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), (this.texture.magFilter = t);
							},
						},
						minFilter: {
							get: function () {
								return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), (this.texture.minFilter = t);
							},
						},
						anisotropy: {
							get: function () {
								return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), (this.texture.anisotropy = t);
							},
						},
						offset: {
							get: function () {
								return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), (this.texture.offset = t);
							},
						},
						repeat: {
							get: function () {
								return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), (this.texture.repeat = t);
							},
						},
						format: {
							get: function () {
								return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), (this.texture.format = t);
							},
						},
						type: {
							get: function () {
								return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), (this.texture.type = t);
							},
						},
						generateMipmaps: {
							get: function () {
								return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), (this.texture.generateMipmaps = t);
							},
						},
					}),
					(hc.prototype.load = function (t) {
						console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
						const e = this;
						return (
							new lc().load(t, function (t) {
								e.setBuffer(t);
							}),
							this
						);
					}),
					(ri.prototype.updateCubeMap = function (t, e) {
						return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e);
					}),
					(ri.prototype.clear = function (t, e, n, i) {
						return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, n, i);
					}),
					(Vt.crossOrigin = void 0),
					(Vt.loadTexture = function (t, e, n, i) {
						console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
						const r = new Vl();
						r.setCrossOrigin(this.crossOrigin);
						const a = r.load(t, n, void 0, i);
						return e && (a.mapping = e), a;
					}),
					(Vt.loadTextureCube = function (t, e, n, i) {
						console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
						const r = new Nl();
						r.setCrossOrigin(this.crossOrigin);
						const a = r.load(t, n, void 0, i);
						return e && (a.mapping = e), a;
					}),
					(Vt.loadCompressedTexture = function () {
						console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
					}),
					(Vt.loadCompressedTextureCube = function () {
						console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
					});
				"undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: "133" } })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : (window.__THREE__ = "133"));
				var Nc = function (t) {
						return t[Math.floor(Math.random() * t.length)];
					},
					Vc = function (t, e) {
						var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
							i = new CustomEvent(t, { detail: e }, { once: n });
						document.dispatchEvent(i);
					};
				function Bc(t) {
					if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
					return t;
				}
				function Fc(t, e) {
					(t.prototype = Object.create(e.prototype)), (t.prototype.constructor = t), (t.__proto__ = e);
				}
				Xt.prototype.damp = function (t, e, n) {
					return this.lerp(t, 1 - Math.exp(-e * n));
				};
				var Uc,
					Hc,
					Gc,
					Wc,
					jc,
					Xc,
					qc,
					Yc,
					Zc,
					Kc = { autoSleep: 120, force3D: "auto", nullTargetWarn: 1, units: { lineHeight: "" } },
					Jc = { duration: 0.5, overwrite: !1, delay: 0 },
					Qc = 1e8,
					$c = 1e-8,
					tu = 2 * Math.PI,
					eu = tu / 4,
					nu = 0,
					iu = Math.sqrt,
					ru = Math.cos,
					au = Math.sin,
					su = function (t) {
						return "string" == typeof t;
					},
					ou = function (t) {
						return "function" == typeof t;
					},
					lu = function (t) {
						return "number" == typeof t;
					},
					cu = function (t) {
						return void 0 === t;
					},
					uu = function (t) {
						return "object" == typeof t;
					},
					hu = function (t) {
						return !1 !== t;
					},
					du = function () {
						return "undefined" != typeof window;
					},
					pu = function (t) {
						return ou(t) || su(t);
					},
					fu = ("function" == typeof ArrayBuffer && ArrayBuffer.isView) || function () {},
					mu = Array.isArray,
					vu = /(?:-?\.?\d|\.)+/gi,
					gu = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
					bu = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
					xu = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
					yu = /[+-]=-?[.\d]+/,
					_u = /[^,'"\[\]\s]+/gi,
					wu = /[\d.+\-=]+(?:e[-+]\d*)*/i,
					Mu = {},
					Su = {},
					Tu = function (t) {
						return (Su = Ju(t, Mu)) && Vd;
					},
					Eu = function (t, e) {
						return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()");
					},
					Cu = function (t, e) {
						return !e && console.warn(t);
					},
					Pu = function (t, e) {
						return (t && (Mu[t] = e) && Su && (Su[t] = e)) || Mu;
					},
					Au = function () {
						return 0;
					},
					Lu = {},
					Ru = [],
					Du = {},
					Ou = {},
					zu = {},
					Iu = 30,
					ku = [],
					Nu = "",
					Vu = function (t) {
						var e,
							n,
							i = t[0];
						if ((uu(i) || ou(i) || (t = [t]), !(e = (i._gsap || {}).harness))) {
							for (n = ku.length; n-- && !ku[n].targetTest(i); );
							e = ku[n];
						}
						for (n = t.length; n--; ) (t[n] && (t[n]._gsap || (t[n]._gsap = new cd(t[n], e)))) || t.splice(n, 1);
						return t;
					},
					Bu = function (t) {
						return t._gsap || Vu(Ph(t))[0]._gsap;
					},
					Fu = function (t, e, n) {
						return (n = t[e]) && ou(n) ? t[e]() : (cu(n) && t.getAttribute && t.getAttribute(e)) || n;
					},
					Uu = function (t, e) {
						return (t = t.split(",")).forEach(e) || t;
					},
					Hu = function (t) {
						return Math.round(1e5 * t) / 1e5 || 0;
					},
					Gu = function (t) {
						return Math.round(1e7 * t) / 1e7 || 0;
					},
					Wu = function (t, e) {
						for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n; );
						return i < n;
					},
					ju = function () {
						var t,
							e,
							n = Ru.length,
							i = Ru.slice(0);
						for (Du = {}, Ru.length = 0, t = 0; t < n; t++) (e = i[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0);
					},
					Xu = function (t, e, n, i) {
						Ru.length && ju(), t.render(e, n, i), Ru.length && ju();
					},
					qu = function (t) {
						var e = parseFloat(t);
						return (e || 0 === e) && (t + "").match(_u).length < 2 ? e : su(t) ? t.trim() : t;
					},
					Yu = function (t) {
						return t;
					},
					Zu = function (t, e) {
						for (var n in e) n in t || (t[n] = e[n]);
						return t;
					},
					Ku = function (t, e) {
						for (var n in e) n in t || "duration" === n || "ease" === n || (t[n] = e[n]);
					},
					Ju = function (t, e) {
						for (var n in e) t[n] = e[n];
						return t;
					},
					Qu = function t(e, n) {
						for (var i in n) "__proto__" !== i && "constructor" !== i && "prototype" !== i && (e[i] = uu(n[i]) ? t(e[i] || (e[i] = {}), n[i]) : n[i]);
						return e;
					},
					$u = function (t, e) {
						var n,
							i = {};
						for (n in t) n in e || (i[n] = t[n]);
						return i;
					},
					th = function (t) {
						var e = t.parent || Hc,
							n = t.keyframes ? Ku : Zu;
						if (hu(t.inherit)) for (; e; ) n(t, e.vars.defaults), (e = e.parent || e._dp);
						return t;
					},
					eh = function (t, e, n, i) {
						void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
						var r = e._prev,
							a = e._next;
						r ? (r._next = a) : t[n] === e && (t[n] = a), a ? (a._prev = r) : t[i] === e && (t[i] = r), (e._next = e._prev = e.parent = null);
					},
					nh = function (t, e) {
						t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove(t), (t._act = 0);
					},
					ih = function (t, e) {
						if (t && (!e || e._end > t._dur || e._start < 0)) for (var n = t; n; ) (n._dirty = 1), (n = n.parent);
						return t;
					},
					rh = function (t) {
						for (var e = t.parent; e && e.parent; ) (e._dirty = 1), e.totalDuration(), (e = e.parent);
						return t;
					},
					ah = function t(e) {
						return !e || (e._ts && t(e.parent));
					},
					sh = function (t) {
						return t._repeat ? oh(t._tTime, (t = t.duration() + t._rDelay)) * t : 0;
					},
					oh = function (t, e) {
						var n = Math.floor((t /= e));
						return t && n === t ? n - 1 : n;
					},
					lh = function (t, e) {
						return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur);
					},
					ch = function (t) {
						return (t._end = Gu(t._start + (t._tDur / Math.abs(t._ts || t._rts || $c) || 0)));
					},
					uh = function (t, e) {
						var n = t._dp;
						return n && n.smoothChildTiming && t._ts && ((t._start = Gu(n._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts))), ch(t), n._dirty || ih(n, t)), t;
					},
					hh = function (t, e) {
						var n;
						if (((e._time || (e._initted && !e._dur)) && ((n = lh(t.rawTime(), e)), (!e._dur || Mh(0, e.totalDuration(), n) - e._tTime > $c) && e.render(n, !0)), ih(t, e)._dp && t._initted && t._time >= t._dur && t._ts)) {
							if (t._dur < t.duration()) for (n = t; n._dp; ) n.rawTime() >= 0 && n.totalTime(n._tTime), (n = n._dp);
							t._zTime = -1e-8;
						}
					},
					dh = function (t, e, n, i) {
						return (
							e.parent && nh(e),
							(e._start = Gu((lu(n) ? n : n || t !== Hc ? yh(t, n, e) : t._time) + e._delay)),
							(e._end = Gu(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0))),
							(function (t, e, n, i, r) {
								void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
								var a,
									s = t[i];
								if (r) for (a = e[r]; s && s[r] > a; ) s = s._prev;
								s ? ((e._next = s._next), (s._next = e)) : ((e._next = t[n]), (t[n] = e)), e._next ? (e._next._prev = e) : (t[i] = e), (e._prev = s), (e.parent = e._dp = t);
							})(t, e, "_first", "_last", t._sort ? "_start" : 0),
							vh(e) || (t._recent = e),
							i || hh(t, e),
							t
						);
					},
					ph = function (t, e) {
						return (Mu.ScrollTrigger || Eu("scrollTrigger", e)) && Mu.ScrollTrigger.create(e, t);
					},
					fh = function (t, e, n, i) {
						return vd(t, e), t._initted ? (!n && t._pt && ((t._dur && !1 !== t.vars.lazy) || (!t._dur && t.vars.lazy)) && qc !== Kh.frame ? (Ru.push(t), (t._lazy = [e, i]), 1) : void 0) : 1;
					},
					mh = function t(e) {
						var n = e.parent;
						return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || t(n));
					},
					vh = function (t) {
						var e = t.data;
						return "isFromStart" === e || "isStart" === e;
					},
					gh = function (t, e, n, i) {
						var r = t._repeat,
							a = Gu(e) || 0,
							s = t._tTime / t._tDur;
						return s && !i && (t._time *= a / t._dur), (t._dur = a), (t._tDur = r ? (r < 0 ? 1e10 : Gu(a * (r + 1) + t._rDelay * r)) : a), s && !i ? uh(t, (t._tTime = t._tDur * s)) : t.parent && ch(t), n || ih(t.parent, t), t;
					},
					bh = function (t) {
						return t instanceof hd ? ih(t) : gh(t, t._dur);
					},
					xh = { _start: 0, endTime: Au, totalDuration: Au },
					yh = function t(e, n, i) {
						var r,
							a,
							s,
							o = e.labels,
							l = e._recent || xh,
							c = e.duration() >= Qc ? l.endTime(!1) : e._dur;
						return su(n) && (isNaN(n) || n in o)
							? ((a = n.charAt(0)),
							  (s = "%" === n.substr(-1)),
							  (r = n.indexOf("=")),
							  "<" === a || ">" === a ? (r >= 0 && (n = n.replace(/=/, "")), ("<" === a ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (s ? (r < 0 ? l : i).totalDuration() / 100 : 1)) : r < 0 ? (n in o || (o[n] = c), o[n]) : ((a = parseFloat(n.charAt(r - 1) + n.substr(r + 1))), s && i && (a = (a / 100) * (mu(i) ? i[0] : i).totalDuration()), r > 1 ? t(e, n.substr(0, r - 1), i) + a : c + a))
							: null == n
							? c
							: +n;
					},
					_h = function (t, e, n) {
						var i,
							r,
							a = lu(e[1]),
							s = (a ? 2 : 1) + (t < 2 ? 0 : 1),
							o = e[s];
						if ((a && (o.duration = e[1]), (o.parent = n), t)) {
							for (i = o, r = n; r && !("immediateRender" in i); ) (i = r.vars.defaults || {}), (r = hu(r.vars.inherit) && r.parent);
							(o.immediateRender = hu(i.immediateRender)), t < 2 ? (o.runBackwards = 1) : (o.startAt = e[s - 1]);
						}
						return new yd(e[0], o, e[s + 1]);
					},
					wh = function (t, e) {
						return t || 0 === t ? e(t) : e;
					},
					Mh = function (t, e, n) {
						return n < t ? t : n > e ? e : n;
					},
					Sh = function (t) {
						if ("string" != typeof t) return "";
						var e = wu.exec(t);
						return e ? t.substr(e.index + e[0].length) : "";
					},
					Th = [].slice,
					Eh = function (t, e) {
						return t && uu(t) && "length" in t && ((!e && !t.length) || (t.length - 1 in t && uu(t[0]))) && !t.nodeType && t !== Gc;
					},
					Ch = function (t, e, n) {
						return (
							void 0 === n && (n = []),
							t.forEach(function (t) {
								var i;
								return (su(t) && !e) || Eh(t, 1) ? (i = n).push.apply(i, Ph(t)) : n.push(t);
							}) || n
						);
					},
					Ph = function (t, e, n) {
						return !su(t) || n || (!Wc && Jh()) ? (mu(t) ? Ch(t, n) : Eh(t) ? Th.call(t, 0) : t ? [t] : []) : Th.call((e || jc).querySelectorAll(t), 0);
					},
					Ah = function (t) {
						return t.sort(function () {
							return 0.5 - Math.random();
						});
					},
					Lh = function (t) {
						if (ou(t)) return t;
						var e = uu(t) ? t : { each: t },
							n = rd(e.ease),
							i = e.from || 0,
							r = parseFloat(e.base) || 0,
							a = {},
							s = i > 0 && i < 1,
							o = isNaN(i) || s,
							l = e.axis,
							c = i,
							u = i;
						return (
							su(i) ? (c = u = { center: 0.5, edges: 0.5, end: 1 }[i] || 0) : !s && o && ((c = i[0]), (u = i[1])),
							function (t, s, h) {
								var d,
									p,
									f,
									m,
									v,
									g,
									b,
									x,
									y,
									_ = (h || e).length,
									w = a[_];
								if (!w) {
									if (!(y = "auto" === e.grid ? 0 : (e.grid || [1, Qc])[1])) {
										for (b = -Qc; b < (b = h[y++].getBoundingClientRect().left) && y < _; );
										y--;
									}
									for (w = a[_] = [], d = o ? Math.min(y, _) * c - 0.5 : i % y, p = o ? (_ * u) / y - 0.5 : (i / y) | 0, b = 0, x = Qc, g = 0; g < _; g++) (f = (g % y) - d), (m = p - ((g / y) | 0)), (w[g] = v = l ? Math.abs("y" === l ? m : f) : iu(f * f + m * m)), v > b && (b = v), v < x && (x = v);
									"random" === i && Ah(w), (w.max = b - x), (w.min = x), (w.v = _ = (parseFloat(e.amount) || parseFloat(e.each) * (y > _ ? _ - 1 : l ? ("y" === l ? _ / y : y) : Math.max(y, _ / y)) || 0) * ("edges" === i ? -1 : 1)), (w.b = _ < 0 ? r - _ : r), (w.u = Sh(e.amount || e.each) || 0), (n = n && _ < 0 ? nd(n) : n);
								}
								return (_ = (w[t] - w.min) / w.max || 0), Gu(w.b + (n ? n(_) : _) * w.v) + w.u;
							}
						);
					},
					Rh = function (t) {
						var e = Math.pow(10, ((t + "").split(".")[1] || "").length);
						return function (n) {
							var i = Math.round(parseFloat(n) / t) * t * e;
							return (i - (i % 1)) / e + (lu(n) ? 0 : Sh(n));
						};
					},
					Dh = function (t, e) {
						var n,
							i,
							r = mu(t);
						return (
							!r && uu(t) && ((n = r = t.radius || Qc), t.values ? ((t = Ph(t.values)), (i = !lu(t[0])) && (n *= n)) : (t = Rh(t.increment))),
							wh(
								e,
								r
									? ou(t)
										? function (e) {
												return (i = t(e)), Math.abs(i - e) <= n ? i : e;
										  }
										: function (e) {
												for (var r, a, s = parseFloat(i ? e.x : e), o = parseFloat(i ? e.y : 0), l = Qc, c = 0, u = t.length; u--; ) (r = i ? (r = t[u].x - s) * r + (a = t[u].y - o) * a : Math.abs(t[u] - s)) < l && ((l = r), (c = u));
												return (c = !n || l <= n ? t[c] : e), i || c === e || lu(e) ? c : c + Sh(e);
										  }
									: Rh(t)
							)
						);
					},
					Oh = function (t, e, n, i) {
						return wh(mu(t) ? !e : !0 === n ? !!(n = 0) : !i, function () {
							return mu(t) ? t[~~(Math.random() * t.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((t - n / 2 + Math.random() * (e - t + 0.99 * n)) / n) * n * i) / i;
						});
					},
					zh = function (t, e, n) {
						return wh(n, function (n) {
							return t[~~e(n)];
						});
					},
					Ih = function (t) {
						for (var e, n, i, r, a = 0, s = ""; ~(e = t.indexOf("random(", a)); ) (i = t.indexOf(")", e)), (r = "[" === t.charAt(e + 7)), (n = t.substr(e + 7, i - e - 7).match(r ? _u : vu)), (s += t.substr(a, e - a) + Oh(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5)), (a = i + 1);
						return s + t.substr(a, t.length - a);
					},
					kh = function (t, e, n, i, r) {
						var a = e - t,
							s = i - n;
						return wh(r, function (e) {
							return n + (((e - t) / a) * s || 0);
						});
					},
					Nh = function (t, e, n) {
						var i,
							r,
							a,
							s = t.labels,
							o = Qc;
						for (i in s) (r = s[i] - e) < 0 == !!n && r && o > (r = Math.abs(r)) && ((a = i), (o = r));
						return a;
					},
					Vh = function (t, e, n) {
						var i,
							r,
							a = t.vars,
							s = a[e];
						if (s) return (i = a[e + "Params"]), (r = a.callbackScope || t), n && Ru.length && ju(), i ? s.apply(r, i) : s.call(r);
					},
					Bh = function (t) {
						return nh(t), t.scrollTrigger && t.scrollTrigger.kill(!1), t.progress() < 1 && Vh(t, "onInterrupt"), t;
					},
					Fh = function (t) {
						var e = (t = (!t.name && t.default) || t).name,
							n = ou(t),
							i =
								e && !n && t.init
									? function () {
											this._props = [];
									  }
									: t,
							r = { init: Au, render: Ad, add: fd, kill: Rd, modifier: Ld, rawVars: 0 },
							a = { targetTest: 0, get: 0, getSetter: Td, aliases: {}, register: 0 };
						if ((Jh(), t !== i)) {
							if (Ou[e]) return;
							Zu(i, Zu($u(t, r), a)), Ju(i.prototype, Ju(r, $u(t, a))), (Ou[(i.prop = e)] = i), t.targetTest && (ku.push(i), (Lu[e] = 1)), (e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin");
						}
						Pu(e, i), t.register && t.register(Vd, i, zd);
					},
					Uh = 255,
					Hh = { aqua: [0, Uh, Uh], lime: [0, Uh, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, Uh], navy: [0, 0, 128], white: [Uh, Uh, Uh], olive: [128, 128, 0], yellow: [Uh, Uh, 0], orange: [Uh, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [Uh, 0, 0], pink: [Uh, 192, 203], cyan: [0, Uh, Uh], transparent: [Uh, Uh, Uh, 0] },
					Gh = function (t, e, n) {
						return ((6 * (t = t < 0 ? t + 1 : t > 1 ? t - 1 : t) < 1 ? e + (n - e) * t * 6 : t < 0.5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) * Uh + 0.5) | 0;
					},
					Wh = function (t, e, n) {
						var i,
							r,
							a,
							s,
							o,
							l,
							c,
							u,
							h,
							d,
							p = t ? (lu(t) ? [t >> 16, (t >> 8) & Uh, t & Uh] : 0) : Hh.black;
						if (!p) {
							if (("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), Hh[t])) p = Hh[t];
							else if ("#" === t.charAt(0)) {
								if ((t.length < 6 && ((i = t.charAt(1)), (r = t.charAt(2)), (a = t.charAt(3)), (t = "#" + i + i + r + r + a + a + (5 === t.length ? t.charAt(4) + t.charAt(4) : ""))), 9 === t.length)) return [(p = parseInt(t.substr(1, 6), 16)) >> 16, (p >> 8) & Uh, p & Uh, parseInt(t.substr(7), 16) / 255];
								p = [(t = parseInt(t.substr(1), 16)) >> 16, (t >> 8) & Uh, t & Uh];
							} else if ("hsl" === t.substr(0, 3))
								if (((p = d = t.match(vu)), e)) {
									if (~t.indexOf("=")) return (p = t.match(gu)), n && p.length < 4 && (p[3] = 1), p;
								} else (s = (+p[0] % 360) / 360), (o = +p[1] / 100), (i = 2 * (l = +p[2] / 100) - (r = l <= 0.5 ? l * (o + 1) : l + o - l * o)), p.length > 3 && (p[3] *= 1), (p[0] = Gh(s + 1 / 3, i, r)), (p[1] = Gh(s, i, r)), (p[2] = Gh(s - 1 / 3, i, r));
							else p = t.match(vu) || Hh.transparent;
							p = p.map(Number);
						}
						return e && !d && ((i = p[0] / Uh), (r = p[1] / Uh), (a = p[2] / Uh), (l = ((c = Math.max(i, r, a)) + (u = Math.min(i, r, a))) / 2), c === u ? (s = o = 0) : ((h = c - u), (o = l > 0.5 ? h / (2 - c - u) : h / (c + u)), (s = c === i ? (r - a) / h + (r < a ? 6 : 0) : c === r ? (a - i) / h + 2 : (i - r) / h + 4), (s *= 60)), (p[0] = ~~(s + 0.5)), (p[1] = ~~(100 * o + 0.5)), (p[2] = ~~(100 * l + 0.5))), n && p.length < 4 && (p[3] = 1), p;
					},
					jh = function (t) {
						var e = [],
							n = [],
							i = -1;
						return (
							t.split(qh).forEach(function (t) {
								var r = t.match(bu) || [];
								e.push.apply(e, r), n.push((i += r.length + 1));
							}),
							(e.c = n),
							e
						);
					},
					Xh = function (t, e, n) {
						var i,
							r,
							a,
							s,
							o = "",
							l = (t + o).match(qh),
							c = e ? "hsla(" : "rgba(",
							u = 0;
						if (!l) return t;
						if (
							((l = l.map(function (t) {
								return (t = Wh(t, e, 1)) && c + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")";
							})),
							n && ((a = jh(t)), (i = n.c).join(o) !== a.c.join(o)))
						)
							for (s = (r = t.replace(qh, "1").split(bu)).length - 1; u < s; u++) o += r[u] + (~i.indexOf(u) ? l.shift() || c + "0,0,0,0)" : (a.length ? a : l.length ? l : n).shift());
						if (!r) for (s = (r = t.split(qh)).length - 1; u < s; u++) o += r[u] + l[u];
						return o + r[s];
					},
					qh = (function () {
						var t,
							e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
						for (t in Hh) e += "|" + t + "\\b";
						return new RegExp(e + ")", "gi");
					})(),
					Yh = /hsl[a]?\(/,
					Zh = function (t) {
						var e,
							n = t.join(" ");
						if (((qh.lastIndex = 0), qh.test(n))) return (e = Yh.test(n)), (t[1] = Xh(t[1], e)), (t[0] = Xh(t[0], e, jh(t[1]))), !0;
					},
					Kh = (function () {
						var t,
							e,
							n,
							i,
							r,
							a,
							s = Date.now,
							o = 500,
							l = 33,
							c = s(),
							u = c,
							h = 1e3 / 240,
							d = h,
							p = [],
							f = function n(f) {
								var m,
									v,
									g,
									b,
									x = s() - u,
									y = !0 === f;
								if ((x > o && (c += x - l), ((m = (g = (u += x) - c) - d) > 0 || y) && ((b = ++i.frame), (r = g - 1e3 * i.time), (i.time = g /= 1e3), (d += m + (m >= h ? 4 : h - m)), (v = 1)), y || (t = e(n)), v)) for (a = 0; a < p.length; a++) p[a](g, r, b, f);
							};
						return (i = {
							time: 0,
							frame: 0,
							tick: function () {
								f(!0);
							},
							deltaRatio: function (t) {
								return r / (1e3 / (t || 60));
							},
							wake: function () {
								Xc &&
									(!Wc && du() && ((Gc = Wc = window), (jc = Gc.document || {}), (Mu.gsap = Vd), (Gc.gsapVersions || (Gc.gsapVersions = [])).push(Vd.version), Tu(Su || Gc.GreenSockGlobals || (!Gc.gsap && Gc) || {}), (n = Gc.requestAnimationFrame)),
									t && i.sleep(),
									(e =
										n ||
										function (t) {
											return setTimeout(t, (d - 1e3 * i.time + 1) | 0);
										}),
									(Zc = 1),
									f(2));
							},
							sleep: function () {
								(n ? Gc.cancelAnimationFrame : clearTimeout)(t), (Zc = 0), (e = Au);
							},
							lagSmoothing: function (t, e) {
								(o = t || 1e8), (l = Math.min(e, o, 0));
							},
							fps: function (t) {
								(h = 1e3 / (t || 240)), (d = 1e3 * i.time + h);
							},
							add: function (t) {
								p.indexOf(t) < 0 && p.push(t), Jh();
							},
							remove: function (t) {
								var e;
								~(e = p.indexOf(t)) && p.splice(e, 1) && a >= e && a--;
							},
							_listeners: p,
						});
					})(),
					Jh = function () {
						return !Zc && Kh.wake();
					},
					Qh = {},
					$h = /^[\d.\-M][\d.\-,\s]/,
					td = /["']/g,
					ed = function (t) {
						for (var e, n, i, r = {}, a = t.substr(1, t.length - 3).split(":"), s = a[0], o = 1, l = a.length; o < l; o++) (n = a[o]), (e = o !== l - 1 ? n.lastIndexOf(",") : n.length), (i = n.substr(0, e)), (r[s] = isNaN(i) ? i.replace(td, "").trim() : +i), (s = n.substr(e + 1).trim());
						return r;
					},
					nd = function (t) {
						return function (e) {
							return 1 - t(1 - e);
						};
					},
					id = function t(e, n) {
						for (var i, r = e._first; r; ) r instanceof hd ? t(r, n) : !r.vars.yoyoEase || (r._yoyo && r._repeat) || r._yoyo === n || (r.timeline ? t(r.timeline, n) : ((i = r._ease), (r._ease = r._yEase), (r._yEase = i), (r._yoyo = n))), (r = r._next);
					},
					rd = function (t, e) {
						return (
							(t &&
								(ou(t)
									? t
									: Qh[t] ||
									  (function (t) {
											var e,
												n,
												i,
												r,
												a = (t + "").split("("),
												s = Qh[a[0]];
											return s && a.length > 1 && s.config ? s.config.apply(null, ~t.indexOf("{") ? [ed(a[1])] : ((e = t), (n = e.indexOf("(") + 1), (i = e.indexOf(")")), (r = e.indexOf("(", n)), e.substring(n, ~r && r < i ? e.indexOf(")", i + 1) : i)).split(",").map(qu)) : Qh._CE && $h.test(t) ? Qh._CE("", t) : s;
									  })(t))) ||
							e
						);
					},
					ad = function (t, e, n, i) {
						void 0 === n &&
							(n = function (t) {
								return 1 - e(1 - t);
							}),
							void 0 === i &&
								(i = function (t) {
									return t < 0.5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2;
								});
						var r,
							a = { easeIn: e, easeOut: n, easeInOut: i };
						return (
							Uu(t, function (t) {
								for (var e in ((Qh[t] = Mu[t] = a), (Qh[(r = t.toLowerCase())] = n), a)) Qh[r + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = Qh[t + "." + e] = a[e];
							}),
							a
						);
					},
					sd = function (t) {
						return function (e) {
							return e < 0.5 ? (1 - t(1 - 2 * e)) / 2 : 0.5 + t(2 * (e - 0.5)) / 2;
						};
					},
					od = function t(e, n, i) {
						var r = n >= 1 ? n : 1,
							a = (i || (e ? 0.3 : 0.45)) / (n < 1 ? n : 1),
							s = (a / tu) * (Math.asin(1 / r) || 0),
							o = function (t) {
								return 1 === t ? 1 : r * Math.pow(2, -10 * t) * au((t - s) * a) + 1;
							},
							l =
								"out" === e
									? o
									: "in" === e
									? function (t) {
											return 1 - o(1 - t);
									  }
									: sd(o);
						return (
							(a = tu / a),
							(l.config = function (n, i) {
								return t(e, n, i);
							}),
							l
						);
					},
					ld = function t(e, n) {
						void 0 === n && (n = 1.70158);
						var i = function (t) {
								return t ? --t * t * ((n + 1) * t + n) + 1 : 0;
							},
							r =
								"out" === e
									? i
									: "in" === e
									? function (t) {
											return 1 - i(1 - t);
									  }
									: sd(i);
						return (
							(r.config = function (n) {
								return t(e, n);
							}),
							r
						);
					};
				Uu("Linear,Quad,Cubic,Quart,Quint,Strong", function (t, e) {
					var n = e < 5 ? e + 1 : e;
					ad(
						t + ",Power" + (n - 1),
						e
							? function (t) {
									return Math.pow(t, n);
							  }
							: function (t) {
									return t;
							  },
						function (t) {
							return 1 - Math.pow(1 - t, n);
						},
						function (t) {
							return t < 0.5 ? Math.pow(2 * t, n) / 2 : 1 - Math.pow(2 * (1 - t), n) / 2;
						}
					);
				}),
					(Qh.Linear.easeNone = Qh.none = Qh.Linear.easeIn),
					ad("Elastic", od("in"), od("out"), od()),
					(function (t, e) {
						var n = 1 / e,
							i = function (i) {
								return i < n ? t * i * i : i < 0.7272727272727273 ? t * Math.pow(i - 1.5 / e, 2) + 0.75 : i < 0.9090909090909092 ? t * (i -= 2.25 / e) * i + 0.9375 : t * Math.pow(i - 2.625 / e, 2) + 0.984375;
							};
						ad(
							"Bounce",
							function (t) {
								return 1 - i(1 - t);
							},
							i
						);
					})(7.5625, 2.75),
					ad("Expo", function (t) {
						return t ? Math.pow(2, 10 * (t - 1)) : 0;
					}),
					ad("Circ", function (t) {
						return -(iu(1 - t * t) - 1);
					}),
					ad("Sine", function (t) {
						return 1 === t ? 1 : 1 - ru(t * eu);
					}),
					ad("Back", ld("in"), ld("out"), ld()),
					(Qh.SteppedEase =
						Qh.steps =
						Mu.SteppedEase =
							{
								config: function (t, e) {
									void 0 === t && (t = 1);
									var n = 1 / t,
										i = t + (e ? 0 : 1),
										r = e ? 1 : 0;
									return function (t) {
										return (((i * Mh(0, 0.99999999, t)) | 0) + r) * n;
									};
								},
							}),
					(Jc.ease = Qh["quad.out"]),
					Uu("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (t) {
						return (Nu += t + "," + t + "Params,");
					});
				var cd = function (t, e) {
						(this.id = nu++), (t._gsap = this), (this.target = t), (this.harness = e), (this.get = e ? e.get : Fu), (this.set = e ? e.getSetter : Td);
					},
					ud = (function () {
						function t(t) {
							(this.vars = t), (this._delay = +t.delay || 0), (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && ((this._rDelay = t.repeatDelay || 0), (this._yoyo = !!t.yoyo || !!t.yoyoEase)), (this._ts = 1), gh(this, +t.duration, 1, 1), (this.data = t.data), Zc || Kh.wake();
						}
						var e = t.prototype;
						return (
							(e.delay = function (t) {
								return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), (this._delay = t), this) : this._delay;
							}),
							(e.duration = function (t) {
								return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur;
							}),
							(e.totalDuration = function (t) {
								return arguments.length ? ((this._dirty = 0), gh(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur;
							}),
							(e.totalTime = function (t, e) {
								if ((Jh(), !arguments.length)) return this._tTime;
								var n = this._dp;
								if (n && n.smoothChildTiming && this._ts) {
									for (uh(this, t), !n._dp || n.parent || hh(n, this); n && n.parent; ) n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0), (n = n.parent);
									!this.parent && this._dp.autoRemoveChildren && ((this._ts > 0 && t < this._tDur) || (this._ts < 0 && t > 0) || (!this._tDur && !t)) && dh(this._dp, this, this._start - this._delay);
								}
								return (this._tTime !== t || (!this._dur && !e) || (this._initted && Math.abs(this._zTime) === $c) || (!t && !this._initted && (this.add || this._ptLookup))) && (this._ts || (this._pTime = t), Xu(this, t, e)), this;
							}),
							(e.time = function (t, e) {
								return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + sh(this)) % (this._dur + this._rDelay) || (t ? this._dur : 0), e) : this._time;
							}),
							(e.totalProgress = function (t, e) {
								return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
							}),
							(e.progress = function (t, e) {
								return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + sh(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
							}),
							(e.iteration = function (t, e) {
								var n = this.duration() + this._rDelay;
								return arguments.length ? this.totalTime(this._time + (t - 1) * n, e) : this._repeat ? oh(this._tTime, n) + 1 : 1;
							}),
							(e.timeScale = function (t) {
								if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
								if (this._rts === t) return this;
								var e = this.parent && this._ts ? lh(this.parent._time, this) : this._tTime;
								return (this._rts = +t || 0), (this._ts = this._ps || -1e-8 === t ? 0 : this._rts), rh(this.totalTime(Mh(-this._delay, this._tDur, e), !0)), ch(this), this;
							}),
							(e.paused = function (t) {
								return arguments.length ? (this._ps !== t && ((this._ps = t), t ? ((this._pTime = this._tTime || Math.max(-this._delay, this.rawTime())), (this._ts = this._act = 0)) : (Jh(), (this._ts = this._rts), this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== $c && (this._tTime -= $c)))), this) : this._ps;
							}),
							(e.startTime = function (t) {
								if (arguments.length) {
									this._start = t;
									var e = this.parent || this._dp;
									return e && (e._sort || !this.parent) && dh(e, this, t - this._delay), this;
								}
								return this._start;
							}),
							(e.endTime = function (t) {
								return this._start + (hu(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
							}),
							(e.rawTime = function (t) {
								var e = this.parent || this._dp;
								return e ? (t && (!this._ts || (this._repeat && this._time && this.totalProgress() < 1)) ? this._tTime % (this._dur + this._rDelay) : this._ts ? lh(e.rawTime(t), this) : this._tTime) : this._tTime;
							}),
							(e.globalTime = function (t) {
								for (var e = this, n = arguments.length ? t : e.rawTime(); e; ) (n = e._start + n / (e._ts || 1)), (e = e._dp);
								return n;
							}),
							(e.repeat = function (t) {
								return arguments.length ? ((this._repeat = t === 1 / 0 ? -2 : t), bh(this)) : -2 === this._repeat ? 1 / 0 : this._repeat;
							}),
							(e.repeatDelay = function (t) {
								if (arguments.length) {
									var e = this._time;
									return (this._rDelay = t), bh(this), e ? this.time(e) : this;
								}
								return this._rDelay;
							}),
							(e.yoyo = function (t) {
								return arguments.length ? ((this._yoyo = t), this) : this._yoyo;
							}),
							(e.seek = function (t, e) {
								return this.totalTime(yh(this, t), hu(e));
							}),
							(e.restart = function (t, e) {
								return this.play().totalTime(t ? -this._delay : 0, hu(e));
							}),
							(e.play = function (t, e) {
								return null != t && this.seek(t, e), this.reversed(!1).paused(!1);
							}),
							(e.reverse = function (t, e) {
								return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1);
							}),
							(e.pause = function (t, e) {
								return null != t && this.seek(t, e), this.paused(!0);
							}),
							(e.resume = function () {
								return this.paused(!1);
							}),
							(e.reversed = function (t) {
								return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)), this) : this._rts < 0;
							}),
							(e.invalidate = function () {
								return (this._initted = this._act = 0), (this._zTime = -1e-8), this;
							}),
							(e.isActive = function () {
								var t,
									e = this.parent || this._dp,
									n = this._start;
								return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= n && t < this.endTime(!0) - $c));
							}),
							(e.eventCallback = function (t, e, n) {
								var i = this.vars;
								return arguments.length > 1 ? (e ? ((i[t] = e), n && (i[t + "Params"] = n), "onUpdate" === t && (this._onUpdate = e)) : delete i[t], this) : i[t];
							}),
							(e.then = function (t) {
								var e = this;
								return new Promise(function (n) {
									var i = ou(t) ? t : Yu,
										r = function () {
											var t = e.then;
											(e.then = null), ou(i) && (i = i(e)) && (i.then || i === e) && (e.then = t), n(i), (e.then = t);
										};
									(e._initted && 1 === e.totalProgress() && e._ts >= 0) || (!e._tTime && e._ts < 0) ? r() : (e._prom = r);
								});
							}),
							(e.kill = function () {
								Bh(this);
							}),
							t
						);
					})();
				Zu(ud.prototype, { _time: 0, _start: 0, _end: 0, _tTime: 0, _tDur: 0, _dirty: 0, _repeat: 0, _yoyo: !1, parent: null, _initted: !1, _rDelay: 0, _ts: 1, _dp: 0, ratio: 0, _zTime: -1e-8, _prom: 0, _ps: !1, _rts: 1 });
				var hd = (function (t) {
					function e(e, n) {
						var i;
						return void 0 === e && (e = {}), ((i = t.call(this, e) || this).labels = {}), (i.smoothChildTiming = !!e.smoothChildTiming), (i.autoRemoveChildren = !!e.autoRemoveChildren), (i._sort = hu(e.sortChildren)), Hc && dh(e.parent || Hc, Bc(i), n), e.reversed && i.reverse(), e.paused && i.paused(!0), e.scrollTrigger && ph(Bc(i), e.scrollTrigger), i;
					}
					Fc(e, t);
					var n = e.prototype;
					return (
						(n.to = function (t, e, n) {
							return _h(0, arguments, this), this;
						}),
						(n.from = function (t, e, n) {
							return _h(1, arguments, this), this;
						}),
						(n.fromTo = function (t, e, n, i) {
							return _h(2, arguments, this), this;
						}),
						(n.set = function (t, e, n) {
							return (e.duration = 0), (e.parent = this), th(e).repeatDelay || (e.repeat = 0), (e.immediateRender = !!e.immediateRender), new yd(t, e, yh(this, n), 1), this;
						}),
						(n.call = function (t, e, n) {
							return dh(this, yd.delayedCall(0, t, e), n);
						}),
						(n.staggerTo = function (t, e, n, i, r, a, s) {
							return (n.duration = e), (n.stagger = n.stagger || i), (n.onComplete = a), (n.onCompleteParams = s), (n.parent = this), new yd(t, n, yh(this, r)), this;
						}),
						(n.staggerFrom = function (t, e, n, i, r, a, s) {
							return (n.runBackwards = 1), (th(n).immediateRender = hu(n.immediateRender)), this.staggerTo(t, e, n, i, r, a, s);
						}),
						(n.staggerFromTo = function (t, e, n, i, r, a, s, o) {
							return (i.startAt = n), (th(i).immediateRender = hu(i.immediateRender)), this.staggerTo(t, e, i, r, a, s, o);
						}),
						(n.render = function (t, e, n) {
							var i,
								r,
								a,
								s,
								o,
								l,
								c,
								u,
								h,
								d,
								p,
								f,
								m = this._time,
								v = this._dirty ? this.totalDuration() : this._tDur,
								g = this._dur,
								b = t <= 0 ? 0 : Gu(t),
								x = this._zTime < 0 != t < 0 && (this._initted || !g);
							if ((this !== Hc && b > v && t >= 0 && (b = v), b !== this._tTime || n || x)) {
								if ((m !== this._time && g && ((b += this._time - m), (t += this._time - m)), (i = b), (h = this._start), (l = !(u = this._ts)), x && (g || (m = this._zTime), (t || !e) && (this._zTime = t)), this._repeat)) {
									if (((p = this._yoyo), (o = g + this._rDelay), this._repeat < -1 && t < 0)) return this.totalTime(100 * o + t, e, n);
									if (((i = Gu(b % o)), b === v ? ((s = this._repeat), (i = g)) : ((s = ~~(b / o)) && s === b / o && ((i = g), s--), i > g && (i = g)), (d = oh(this._tTime, o)), !m && this._tTime && d !== s && (d = s), p && 1 & s && ((i = g - i), (f = 1)), s !== d && !this._lock)) {
										var y = p && 1 & d,
											_ = y === (p && 1 & s);
										if ((s < d && (y = !y), (m = y ? 0 : g), (this._lock = 1), (this.render(m || (f ? 0 : Gu(s * o)), e, !g)._lock = 0), (this._tTime = b), !e && this.parent && Vh(this, "onRepeat"), this.vars.repeatRefresh && !f && (this.invalidate()._lock = 1), (m && m !== this._time) || l !== !this._ts || (this.vars.onRepeat && !this.parent && !this._act))) return this;
										if (((g = this._dur), (v = this._tDur), _ && ((this._lock = 2), (m = y ? g : -1e-4), this.render(m, !0), this.vars.repeatRefresh && !f && this.invalidate()), (this._lock = 0), !this._ts && !l)) return this;
										id(this, f);
									}
								}
								if (
									(this._hasPause &&
										!this._forcing &&
										this._lock < 2 &&
										(c = (function (t, e, n) {
											var i;
											if (n > e)
												for (i = t._first; i && i._start <= n; ) {
													if (!i._dur && "isPause" === i.data && i._start > e) return i;
													i = i._next;
												}
											else
												for (i = t._last; i && i._start >= n; ) {
													if (!i._dur && "isPause" === i.data && i._start < e) return i;
													i = i._prev;
												}
										})(this, Gu(m), Gu(i))) &&
										(b -= i - (i = c._start)),
									(this._tTime = b),
									(this._time = i),
									(this._act = !u),
									this._initted || ((this._onUpdate = this.vars.onUpdate), (this._initted = 1), (this._zTime = t), (m = 0)),
									!m && i && !e && (Vh(this, "onStart"), this._tTime !== b))
								)
									return this;
								if (i >= m && t >= 0)
									for (r = this._first; r; ) {
										if (((a = r._next), (r._act || i >= r._start) && r._ts && c !== r)) {
											if (r.parent !== this) return this.render(t, e, n);
											if ((r.render(r._ts > 0 ? (i - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (i - r._start) * r._ts, e, n), i !== this._time || (!this._ts && !l))) {
												(c = 0), a && (b += this._zTime = -1e-8);
												break;
											}
										}
										r = a;
									}
								else {
									r = this._last;
									for (var w = t < 0 ? t : i; r; ) {
										if (((a = r._prev), (r._act || w <= r._end) && r._ts && c !== r)) {
											if (r.parent !== this) return this.render(t, e, n);
											if ((r.render(r._ts > 0 ? (w - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (w - r._start) * r._ts, e, n), i !== this._time || (!this._ts && !l))) {
												(c = 0), a && (b += this._zTime = w ? -1e-8 : $c);
												break;
											}
										}
										r = a;
									}
								}
								if (c && !e && (this.pause(), (c.render(i >= m ? 0 : -1e-8)._zTime = i >= m ? 1 : -1), this._ts)) return (this._start = h), ch(this), this.render(t, e, n);
								this._onUpdate && !e && Vh(this, "onUpdate", !0), ((b === v && v >= this.totalDuration()) || (!b && m)) && ((h !== this._start && Math.abs(u) === Math.abs(this._ts)) || this._lock || ((t || !g) && ((b === v && this._ts > 0) || (!b && this._ts < 0)) && nh(this, 1), e || (t < 0 && !m) || (!b && !m && v) || (Vh(this, b === v && t >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(b < v && this.timeScale() > 0) && this._prom())));
							}
							return this;
						}),
						(n.add = function (t, e) {
							var n = this;
							if ((lu(e) || (e = yh(this, e, t)), !(t instanceof ud))) {
								if (mu(t))
									return (
										t.forEach(function (t) {
											return n.add(t, e);
										}),
										this
									);
								if (su(t)) return this.addLabel(t, e);
								if (!ou(t)) return this;
								t = yd.delayedCall(0, t);
							}
							return this !== t ? dh(this, t, e) : this;
						}),
						(n.getChildren = function (t, e, n, i) {
							void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === n && (n = !0), void 0 === i && (i = -Qc);
							for (var r = [], a = this._first; a; ) a._start >= i && (a instanceof yd ? e && r.push(a) : (n && r.push(a), t && r.push.apply(r, a.getChildren(!0, e, n)))), (a = a._next);
							return r;
						}),
						(n.getById = function (t) {
							for (var e = this.getChildren(1, 1, 1), n = e.length; n--; ) if (e[n].vars.id === t) return e[n];
						}),
						(n.remove = function (t) {
							return su(t) ? this.removeLabel(t) : ou(t) ? this.killTweensOf(t) : (eh(this, t), t === this._recent && (this._recent = this._last), ih(this));
						}),
						(n.totalTime = function (e, n) {
							return arguments.length ? ((this._forcing = 1), !this._dp && this._ts && (this._start = Gu(Kh.time - (this._ts > 0 ? e / this._ts : (this.totalDuration() - e) / -this._ts))), t.prototype.totalTime.call(this, e, n), (this._forcing = 0), this) : this._tTime;
						}),
						(n.addLabel = function (t, e) {
							return (this.labels[t] = yh(this, e)), this;
						}),
						(n.removeLabel = function (t) {
							return delete this.labels[t], this;
						}),
						(n.addPause = function (t, e, n) {
							var i = yd.delayedCall(0, e || Au, n);
							return (i.data = "isPause"), (this._hasPause = 1), dh(this, i, yh(this, t));
						}),
						(n.removePause = function (t) {
							var e = this._first;
							for (t = yh(this, t); e; ) e._start === t && "isPause" === e.data && nh(e), (e = e._next);
						}),
						(n.killTweensOf = function (t, e, n) {
							for (var i = this.getTweensOf(t, n), r = i.length; r--; ) dd !== i[r] && i[r].kill(t, e);
							return this;
						}),
						(n.getTweensOf = function (t, e) {
							for (var n, i = [], r = Ph(t), a = this._first, s = lu(e); a; ) a instanceof yd ? Wu(a._targets, r) && (s ? (!dd || (a._initted && a._ts)) && a.globalTime(0) <= e && a.globalTime(a.totalDuration()) > e : !e || a.isActive()) && i.push(a) : (n = a.getTweensOf(r, e)).length && i.push.apply(i, n), (a = a._next);
							return i;
						}),
						(n.tweenTo = function (t, e) {
							e = e || {};
							var n,
								i = this,
								r = yh(i, t),
								a = e,
								s = a.startAt,
								o = a.onStart,
								l = a.onStartParams,
								c = a.immediateRender,
								u = yd.to(
									i,
									Zu(
										{
											ease: e.ease || "none",
											lazy: !1,
											immediateRender: !1,
											time: r,
											overwrite: "auto",
											duration: e.duration || Math.abs((r - (s && "time" in s ? s.time : i._time)) / i.timeScale()) || $c,
											onStart: function () {
												if ((i.pause(), !n)) {
													var t = e.duration || Math.abs((r - (s && "time" in s ? s.time : i._time)) / i.timeScale());
													u._dur !== t && gh(u, t, 0, 1).render(u._time, !0, !0), (n = 1);
												}
												o && o.apply(u, l || []);
											},
										},
										e
									)
								);
							return c ? u.render(0) : u;
						}),
						(n.tweenFromTo = function (t, e, n) {
							return this.tweenTo(e, Zu({ startAt: { time: yh(this, t) } }, n));
						}),
						(n.recent = function () {
							return this._recent;
						}),
						(n.nextLabel = function (t) {
							return void 0 === t && (t = this._time), Nh(this, yh(this, t));
						}),
						(n.previousLabel = function (t) {
							return void 0 === t && (t = this._time), Nh(this, yh(this, t), 1);
						}),
						(n.currentLabel = function (t) {
							return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + $c);
						}),
						(n.shiftChildren = function (t, e, n) {
							void 0 === n && (n = 0);
							for (var i, r = this._first, a = this.labels; r; ) r._start >= n && ((r._start += t), (r._end += t)), (r = r._next);
							if (e) for (i in a) a[i] >= n && (a[i] += t);
							return ih(this);
						}),
						(n.invalidate = function () {
							var e = this._first;
							for (this._lock = 0; e; ) e.invalidate(), (e = e._next);
							return t.prototype.invalidate.call(this);
						}),
						(n.clear = function (t) {
							void 0 === t && (t = !0);
							for (var e, n = this._first; n; ) (e = n._next), this.remove(n), (n = e);
							return this._dp && (this._time = this._tTime = this._pTime = 0), t && (this.labels = {}), ih(this);
						}),
						(n.totalDuration = function (t) {
							var e,
								n,
								i,
								r = 0,
								a = this,
								s = a._last,
								o = Qc;
							if (arguments.length) return a.timeScale((a._repeat < 0 ? a.duration() : a.totalDuration()) / (a.reversed() ? -t : t));
							if (a._dirty) {
								for (i = a.parent; s; ) (e = s._prev), s._dirty && s.totalDuration(), (n = s._start) > o && a._sort && s._ts && !a._lock ? ((a._lock = 1), (dh(a, s, n - s._delay, 1)._lock = 0)) : (o = n), n < 0 && s._ts && ((r -= n), ((!i && !a._dp) || (i && i.smoothChildTiming)) && ((a._start += n / a._ts), (a._time -= n), (a._tTime -= n)), a.shiftChildren(-n, !1, -Infinity), (o = 0)), s._end > r && s._ts && (r = s._end), (s = e);
								gh(a, a === Hc && a._time > r ? a._time : r, 1, 1), (a._dirty = 0);
							}
							return a._tDur;
						}),
						(e.updateRoot = function (t) {
							if ((Hc._ts && (Xu(Hc, lh(t, Hc)), (qc = Kh.frame)), Kh.frame >= Iu)) {
								Iu += Kc.autoSleep || 120;
								var e = Hc._first;
								if ((!e || !e._ts) && Kc.autoSleep && Kh._listeners.length < 2) {
									for (; e && !e._ts; ) e = e._next;
									e || Kh.sleep();
								}
							}
						}),
						e
					);
				})(ud);
				Zu(hd.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
				var dd,
					pd = function (t, e, n, i, r, a, s) {
						var o,
							l,
							c,
							u,
							h,
							d,
							p,
							f,
							m = new zd(this._pt, t, e, 0, 1, Pd, null, r),
							v = 0,
							g = 0;
						for (m.b = n, m.e = i, n += "", (p = ~(i += "").indexOf("random(")) && (i = Ih(i)), a && (a((f = [n, i]), t, e), (n = f[0]), (i = f[1])), l = n.match(xu) || []; (o = xu.exec(i)); )
							(u = o[0]), (h = i.substring(v, o.index)), c ? (c = (c + 1) % 5) : "rgba(" === h.substr(-5) && (c = 1), u !== l[g++] && ((d = parseFloat(l[g - 1]) || 0), (m._pt = { _next: m._pt, p: h || 1 === g ? h : ",", s: d, c: "=" === u.charAt(1) ? parseFloat(u.substr(2)) * ("-" === u.charAt(0) ? -1 : 1) : parseFloat(u) - d, m: c && c < 4 ? Math.round : 0 }), (v = xu.lastIndex));
						return (m.c = v < i.length ? i.substring(v, i.length) : ""), (m.fp = s), (yu.test(i) || p) && (m.e = 0), (this._pt = m), m;
					},
					fd = function (t, e, n, i, r, a, s, o, l) {
						ou(i) && (i = i(r || 0, t, a));
						var c,
							u = t[e],
							h = "get" !== n ? n : ou(u) ? (l ? t[e.indexOf("set") || !ou(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : t[e]()) : u,
							d = ou(u) ? (l ? Md : wd) : _d;
						if ((su(i) && (~i.indexOf("random(") && (i = Ih(i)), "=" === i.charAt(1) && ((c = parseFloat(h) + parseFloat(i.substr(2)) * ("-" === i.charAt(0) ? -1 : 1) + (Sh(h) || 0)) || 0 === c) && (i = c)), h !== i))
							return isNaN(h * i) || "" === i ? (!u && !(e in t) && Eu(e, i), pd.call(this, t, e, h, i, d, o || Kc.stringFilter, l)) : ((c = new zd(this._pt, t, e, +h || 0, i - (h || 0), "boolean" == typeof u ? Cd : Ed, 0, d)), l && (c.fp = l), s && c.modifier(s, this, t), (this._pt = c));
					},
					md = function (t, e, n, i, r, a) {
						var s, o, l, c;
						if (
							Ou[t] &&
							!1 !==
								(s = new Ou[t]()).init(
									r,
									s.rawVars
										? e[t]
										: (function (t, e, n, i, r) {
												if ((ou(t) && (t = gd(t, r, e, n, i)), !uu(t) || (t.style && t.nodeType) || mu(t) || fu(t))) return su(t) ? gd(t, r, e, n, i) : t;
												var a,
													s = {};
												for (a in t) s[a] = gd(t[a], r, e, n, i);
												return s;
										  })(e[t], i, r, a, n),
									n,
									i,
									a
								) &&
							((n._pt = o = new zd(n._pt, r, t, 0, 1, s.render, s, 0, s.priority)), n !== Yc)
						)
							for (l = n._ptLookup[n._targets.indexOf(r)], c = s._props.length; c--; ) l[s._props[c]] = o;
						return s;
					},
					vd = function t(e, n) {
						var i,
							r,
							a,
							s,
							o,
							l,
							c,
							u,
							h,
							d,
							p,
							f,
							m,
							v = e.vars,
							g = v.ease,
							b = v.startAt,
							x = v.immediateRender,
							y = v.lazy,
							_ = v.onUpdate,
							w = v.onUpdateParams,
							M = v.callbackScope,
							S = v.runBackwards,
							T = v.yoyoEase,
							E = v.keyframes,
							C = v.autoRevert,
							P = e._dur,
							A = e._startAt,
							L = e._targets,
							R = e.parent,
							D = R && "nested" === R.data ? R.parent._targets : L,
							O = "auto" === e._overwrite && !Uc,
							z = e.timeline;
						if ((z && (!E || !g) && (g = "none"), (e._ease = rd(g, Jc.ease)), (e._yEase = T ? nd(rd(!0 === T ? g : T, Jc.ease)) : 0), T && e._yoyo && !e._repeat && ((T = e._yEase), (e._yEase = e._ease), (e._ease = T)), (e._from = !z && !!v.runBackwards), !z)) {
							if (((f = (u = L[0] ? Bu(L[0]).harness : 0) && v[u.prop]), (i = $u(v, Lu)), A && A.render(-1, !0).kill(), b))
								if ((nh((e._startAt = yd.set(L, Zu({ data: "isStart", overwrite: !1, parent: R, immediateRender: !0, lazy: hu(y), startAt: null, delay: 0, onUpdate: _, onUpdateParams: w, callbackScope: M, stagger: 0 }, b)))), n < 0 && !x && !C && e._startAt.render(-1, !0), x)) {
									if ((n > 0 && !C && (e._startAt = 0), P && n <= 0)) return void (n && (e._zTime = n));
								} else !1 === C && (e._startAt = 0);
							else if (S && P)
								if (A) !C && (e._startAt = 0);
								else if ((n && (x = !1), (a = Zu({ overwrite: !1, data: "isFromStart", lazy: x && hu(y), immediateRender: x, stagger: 0, parent: R }, i)), f && (a[u.prop] = f), nh((e._startAt = yd.set(L, a))), n < 0 && e._startAt.render(-1, !0), x)) {
									if (!n) return;
								} else t(e._startAt, $c);
							for (e._pt = 0, y = (P && hu(y)) || (y && !P), r = 0; r < L.length; r++) {
								if (
									((c = (o = L[r])._gsap || Vu(L)[r]._gsap),
									(e._ptLookup[r] = d = {}),
									Du[c.id] && Ru.length && ju(),
									(p = D === L ? r : D.indexOf(o)),
									u &&
										!1 !== (h = new u()).init(o, f || i, e, p, D) &&
										((e._pt = s = new zd(e._pt, o, h.name, 0, 1, h.render, h, 0, h.priority)),
										h._props.forEach(function (t) {
											d[t] = s;
										}),
										h.priority && (l = 1)),
									!u || f)
								)
									for (a in i) Ou[a] && (h = md(a, i, e, p, o, D)) ? h.priority && (l = 1) : (d[a] = s = fd.call(e, o, a, "get", i[a], p, D, 0, v.stringFilter));
								e._op && e._op[r] && e.kill(o, e._op[r]), O && e._pt && ((dd = e), Hc.killTweensOf(o, d, e.globalTime(n)), (m = !e.parent), (dd = 0)), e._pt && y && (Du[c.id] = 1);
							}
							l && Od(e), e._onInit && e._onInit(e);
						}
						(e._onUpdate = _), (e._initted = (!e._op || e._pt) && !m);
					},
					gd = function (t, e, n, i, r) {
						return ou(t) ? t.call(e, n, i, r) : su(t) && ~t.indexOf("random(") ? Ih(t) : t;
					},
					bd = Nu + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
					xd = (bd + ",id,stagger,delay,duration,paused,scrollTrigger").split(","),
					yd = (function (t) {
						function e(e, n, i, r) {
							var a;
							"number" == typeof n && ((i.duration = n), (n = i), (i = null));
							var s,
								o,
								l,
								c,
								u,
								h,
								d,
								p,
								f = (a = t.call(this, r ? n : th(n)) || this).vars,
								m = f.duration,
								v = f.delay,
								g = f.immediateRender,
								b = f.stagger,
								x = f.overwrite,
								y = f.keyframes,
								_ = f.defaults,
								w = f.scrollTrigger,
								M = f.yoyoEase,
								S = n.parent || Hc,
								T = (mu(e) || fu(e) ? lu(e[0]) : "length" in n) ? [e] : Ph(e);
							if (((a._targets = T.length ? Vu(T) : Cu("GSAP target " + e + " not found. https://greensock.com", !Kc.nullTargetWarn) || []), (a._ptLookup = []), (a._overwrite = x), y || b || pu(m) || pu(v))) {
								if (((n = a.vars), (s = a.timeline = new hd({ data: "nested", defaults: _ || {} })).kill(), (s.parent = s._dp = Bc(a)), (s._start = 0), y))
									th(Zu(s.vars.defaults, { ease: "none" })),
										b
											? T.forEach(function (t, e) {
													return y.forEach(function (n, i) {
														return s.to(t, n, i ? ">" : e * b);
													});
											  })
											: y.forEach(function (t) {
													return s.to(T, t, ">");
											  });
								else {
									if (((c = T.length), (d = b ? Lh(b) : Au), uu(b))) for (u in b) ~bd.indexOf(u) && (p || (p = {}), (p[u] = b[u]));
									for (o = 0; o < c; o++) {
										for (u in ((l = {}), n)) xd.indexOf(u) < 0 && (l[u] = n[u]);
										(l.stagger = 0), M && (l.yoyoEase = M), p && Ju(l, p), (h = T[o]), (l.duration = +gd(m, Bc(a), o, h, T)), (l.delay = (+gd(v, Bc(a), o, h, T) || 0) - a._delay), !b && 1 === c && l.delay && ((a._delay = v = l.delay), (a._start += v), (l.delay = 0)), s.to(h, l, d(o, h, T));
									}
									s.duration() ? (m = v = 0) : (a.timeline = 0);
								}
								m || a.duration((m = s.duration()));
							} else a.timeline = 0;
							return !0 !== x || Uc || ((dd = Bc(a)), Hc.killTweensOf(T), (dd = 0)), dh(S, Bc(a), i), n.reversed && a.reverse(), n.paused && a.paused(!0), (g || (!m && !y && a._start === Gu(S._time) && hu(g) && ah(Bc(a)) && "nested" !== S.data)) && ((a._tTime = -1e-8), a.render(Math.max(0, -v))), w && ph(Bc(a), w), a;
						}
						Fc(e, t);
						var n = e.prototype;
						return (
							(n.render = function (t, e, n) {
								var i,
									r,
									a,
									s,
									o,
									l,
									c,
									u,
									h,
									d = this._time,
									p = this._tDur,
									f = this._dur,
									m = t > p - $c && t >= 0 ? p : t < $c ? 0 : t;
								if (f) {
									if (m !== this._tTime || !t || n || (!this._initted && this._tTime) || (this._startAt && this._zTime < 0 != t < 0)) {
										if (((i = m), (u = this.timeline), this._repeat)) {
											if (((s = f + this._rDelay), this._repeat < -1 && t < 0)) return this.totalTime(100 * s + t, e, n);
											if (((i = Gu(m % s)), m === p ? ((a = this._repeat), (i = f)) : ((a = ~~(m / s)) && a === m / s && ((i = f), a--), i > f && (i = f)), (l = this._yoyo && 1 & a) && ((h = this._yEase), (i = f - i)), (o = oh(this._tTime, s)), i === d && !n && this._initted)) return this;
											a !== o && (u && this._yEase && id(u, l), !this.vars.repeatRefresh || l || this._lock || ((this._lock = n = 1), (this.render(Gu(s * a), !0).invalidate()._lock = 0)));
										}
										if (!this._initted) {
											if (fh(this, t < 0 ? t : i, n, e)) return (this._tTime = 0), this;
											if (f !== this._dur) return this.render(t, e, n);
										}
										if (((this._tTime = m), (this._time = i), !this._act && this._ts && ((this._act = 1), (this._lazy = 0)), (this.ratio = c = (h || this._ease)(i / f)), this._from && (this.ratio = c = 1 - c), i && !d && !e && (Vh(this, "onStart"), this._tTime !== m))) return this;
										for (r = this._pt; r; ) r.r(c, r.d), (r = r._next);
										(u && u.render(t < 0 ? t : !i && l ? -1e-8 : u._dur * c, e, n)) || (this._startAt && (this._zTime = t)),
											this._onUpdate && !e && (t < 0 && this._startAt && this._startAt.render(t, !0, n), Vh(this, "onUpdate")),
											this._repeat && a !== o && this.vars.onRepeat && !e && this.parent && Vh(this, "onRepeat"),
											(m !== this._tDur && m) || this._tTime !== m || (t < 0 && this._startAt && !this._onUpdate && this._startAt.render(t, !0, !0), (t || !f) && ((m === this._tDur && this._ts > 0) || (!m && this._ts < 0)) && nh(this, 1), e || (t < 0 && !d) || (!m && !d) || (Vh(this, m === p ? "onComplete" : "onReverseComplete", !0), this._prom && !(m < p && this.timeScale() > 0) && this._prom()));
									}
								} else
									!(function (t, e, n, i) {
										var r,
											a,
											s,
											o = t.ratio,
											l = e < 0 || (!e && ((!t._start && mh(t) && (t._initted || !vh(t))) || ((t._ts < 0 || t._dp._ts < 0) && !vh(t)))) ? 0 : 1,
											c = t._rDelay,
											u = 0;
										if ((c && t._repeat && ((u = Mh(0, t._tDur, e)), (a = oh(u, c)), (s = oh(t._tTime, c)), t._yoyo && 1 & a && (l = 1 - l), a !== s && ((o = 1 - l), t.vars.repeatRefresh && t._initted && t.invalidate())), l !== o || i || t._zTime === $c || (!e && t._zTime))) {
											if (!t._initted && fh(t, e, i, n)) return;
											for (s = t._zTime, t._zTime = e || (n ? $c : 0), n || (n = e && !s), t.ratio = l, t._from && (l = 1 - l), t._time = 0, t._tTime = u, r = t._pt; r; ) r.r(l, r.d), (r = r._next);
											t._startAt && e < 0 && t._startAt.render(e, !0, !0), t._onUpdate && !n && Vh(t, "onUpdate"), u && t._repeat && !n && t.parent && Vh(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === l && (l && nh(t, 1), n || (Vh(t, l ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom()));
										} else t._zTime || (t._zTime = e);
									})(this, t, e, n);
								return this;
							}),
							(n.targets = function () {
								return this._targets;
							}),
							(n.invalidate = function () {
								return (this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0), (this._ptLookup = []), this.timeline && this.timeline.invalidate(), t.prototype.invalidate.call(this);
							}),
							(n.kill = function (t, e) {
								if ((void 0 === e && (e = "all"), !(t || (e && "all" !== e)))) return (this._lazy = this._pt = 0), this.parent ? Bh(this) : this;
								if (this.timeline) {
									var n = this.timeline.totalDuration();
									return this.timeline.killTweensOf(t, e, dd && !0 !== dd.vars.overwrite)._first || Bh(this), this.parent && n !== this.timeline.totalDuration() && gh(this, (this._dur * this.timeline._tDur) / n, 0, 1), this;
								}
								var i,
									r,
									a,
									s,
									o,
									l,
									c,
									u = this._targets,
									h = t ? Ph(t) : u,
									d = this._ptLookup,
									p = this._pt;
								if (
									(!e || "all" === e) &&
									(function (t, e) {
										for (var n = t.length, i = n === e.length; i && n-- && t[n] === e[n]; );
										return n < 0;
									})(u, h)
								)
									return "all" === e && (this._pt = 0), Bh(this);
								for (
									i = this._op = this._op || [],
										"all" !== e &&
											(su(e) &&
												((o = {}),
												Uu(e, function (t) {
													return (o[t] = 1);
												}),
												(e = o)),
											(e = (function (t, e) {
												var n,
													i,
													r,
													a,
													s = t[0] ? Bu(t[0]).harness : 0,
													o = s && s.aliases;
												if (!o) return e;
												for (i in ((n = Ju({}, e)), o)) if ((i in n)) for (r = (a = o[i].split(",")).length; r--; ) n[a[r]] = n[i];
												return n;
											})(u, e))),
										c = u.length;
									c--;

								)
									if (~h.indexOf(u[c])) for (o in ((r = d[c]), "all" === e ? ((i[c] = e), (s = r), (a = {})) : ((a = i[c] = i[c] || {}), (s = e)), s)) (l = r && r[o]) && (("kill" in l.d && !0 !== l.d.kill(o)) || eh(this, l, "_pt"), delete r[o]), "all" !== a && (a[o] = 1);
								return this._initted && !this._pt && p && Bh(this), this;
							}),
							(e.to = function (t, n) {
								return new e(t, n, arguments[2]);
							}),
							(e.from = function (t, e) {
								return _h(1, arguments);
							}),
							(e.delayedCall = function (t, n, i, r) {
								return new e(n, 0, { immediateRender: !1, lazy: !1, overwrite: !1, delay: t, onComplete: n, onReverseComplete: n, onCompleteParams: i, onReverseCompleteParams: i, callbackScope: r });
							}),
							(e.fromTo = function (t, e, n) {
								return _h(2, arguments);
							}),
							(e.set = function (t, n) {
								return (n.duration = 0), n.repeatDelay || (n.repeat = 0), new e(t, n);
							}),
							(e.killTweensOf = function (t, e, n) {
								return Hc.killTweensOf(t, e, n);
							}),
							e
						);
					})(ud);
				Zu(yd.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 }),
					Uu("staggerTo,staggerFrom,staggerFromTo", function (t) {
						yd[t] = function () {
							var e = new hd(),
								n = Th.call(arguments, 0);
							return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n);
						};
					});
				var _d = function (t, e, n) {
						return (t[e] = n);
					},
					wd = function (t, e, n) {
						return t[e](n);
					},
					Md = function (t, e, n, i) {
						return t[e](i.fp, n);
					},
					Sd = function (t, e, n) {
						return t.setAttribute(e, n);
					},
					Td = function (t, e) {
						return ou(t[e]) ? wd : cu(t[e]) && t.setAttribute ? Sd : _d;
					},
					Ed = function (t, e) {
						return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e);
					},
					Cd = function (t, e) {
						return e.set(e.t, e.p, !!(e.s + e.c * t), e);
					},
					Pd = function (t, e) {
						var n = e._pt,
							i = "";
						if (!t && e.b) i = e.b;
						else if (1 === t && e.e) i = e.e;
						else {
							for (; n; ) (i = n.p + (n.m ? n.m(n.s + n.c * t) : Math.round(1e4 * (n.s + n.c * t)) / 1e4) + i), (n = n._next);
							i += e.c;
						}
						e.set(e.t, e.p, i, e);
					},
					Ad = function (t, e) {
						for (var n = e._pt; n; ) n.r(t, n.d), (n = n._next);
					},
					Ld = function (t, e, n, i) {
						for (var r, a = this._pt; a; ) (r = a._next), a.p === i && a.modifier(t, e, n), (a = r);
					},
					Rd = function (t) {
						for (var e, n, i = this._pt; i; ) (n = i._next), (i.p === t && !i.op) || i.op === t ? eh(this, i, "_pt") : i.dep || (e = 1), (i = n);
						return !e;
					},
					Dd = function (t, e, n, i) {
						i.mSet(t, e, i.m.call(i.tween, n, i.mt), i);
					},
					Od = function (t) {
						for (var e, n, i, r, a = t._pt; a; ) {
							for (e = a._next, n = i; n && n.pr > a.pr; ) n = n._next;
							(a._prev = n ? n._prev : r) ? (a._prev._next = a) : (i = a), (a._next = n) ? (n._prev = a) : (r = a), (a = e);
						}
						t._pt = i;
					},
					zd = (function () {
						function t(t, e, n, i, r, a, s, o, l) {
							(this.t = e), (this.s = i), (this.c = r), (this.p = n), (this.r = a || Ed), (this.d = s || this), (this.set = o || _d), (this.pr = l || 0), (this._next = t), t && (t._prev = this);
						}
						return (
							(t.prototype.modifier = function (t, e, n) {
								(this.mSet = this.mSet || this.set), (this.set = Dd), (this.m = t), (this.mt = n), (this.tween = e);
							}),
							t
						);
					})();
				Uu(Nu + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (t) {
					return (Lu[t] = 1);
				}),
					(Mu.TweenMax = Mu.TweenLite = yd),
					(Mu.TimelineLite = Mu.TimelineMax = hd),
					(Hc = new hd({ sortChildren: !1, defaults: Jc, autoRemoveChildren: !0, id: "root", smoothChildTiming: !0 })),
					(Kc.stringFilter = Zh);
				var Id = {
					registerPlugin: function () {
						for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
						e.forEach(function (t) {
							return Fh(t);
						});
					},
					timeline: function (t) {
						return new hd(t);
					},
					getTweensOf: function (t, e) {
						return Hc.getTweensOf(t, e);
					},
					getProperty: function (t, e, n, i) {
						su(t) && (t = Ph(t)[0]);
						var r = Bu(t || {}).get,
							a = n ? Yu : qu;
						return (
							"native" === n && (n = ""),
							t
								? e
									? a(((Ou[e] && Ou[e].get) || r)(t, e, n, i))
									: function (e, n, i) {
											return a(((Ou[e] && Ou[e].get) || r)(t, e, n, i));
									  }
								: t
						);
					},
					quickSetter: function (t, e, n) {
						if ((t = Ph(t)).length > 1) {
							var i = t.map(function (t) {
									return Vd.quickSetter(t, e, n);
								}),
								r = i.length;
							return function (t) {
								for (var e = r; e--; ) i[e](t);
							};
						}
						t = t[0] || {};
						var a = Ou[e],
							s = Bu(t),
							o = (s.harness && (s.harness.aliases || {})[e]) || e,
							l = a
								? function (e) {
										var i = new a();
										(Yc._pt = 0), i.init(t, n ? e + n : e, Yc, 0, [t]), i.render(1, i), Yc._pt && Ad(1, Yc);
								  }
								: s.set(t, o);
						return a
							? l
							: function (e) {
									return l(t, o, n ? e + n : e, s, 1);
							  };
					},
					isTweening: function (t) {
						return Hc.getTweensOf(t, !0).length > 0;
					},
					defaults: function (t) {
						return t && t.ease && (t.ease = rd(t.ease, Jc.ease)), Qu(Jc, t || {});
					},
					config: function (t) {
						return Qu(Kc, t || {});
					},
					registerEffect: function (t) {
						var e = t.name,
							n = t.effect,
							i = t.plugins,
							r = t.defaults,
							a = t.extendTimeline;
						(i || "").split(",").forEach(function (t) {
							return t && !Ou[t] && !Mu[t] && Cu(e + " effect requires " + t + " plugin.");
						}),
							(zu[e] = function (t, e, i) {
								return n(Ph(t), Zu(e || {}, r), i);
							}),
							a &&
								(hd.prototype[e] = function (t, n, i) {
									return this.add(zu[e](t, uu(n) ? n : (i = n) && {}, this), i);
								});
					},
					registerEase: function (t, e) {
						Qh[t] = rd(e);
					},
					parseEase: function (t, e) {
						return arguments.length ? rd(t, e) : Qh;
					},
					getById: function (t) {
						return Hc.getById(t);
					},
					exportRoot: function (t, e) {
						void 0 === t && (t = {});
						var n,
							i,
							r = new hd(t);
						for (r.smoothChildTiming = hu(t.smoothChildTiming), Hc.remove(r), r._dp = 0, r._time = r._tTime = Hc._time, n = Hc._first; n; ) (i = n._next), (!e && !n._dur && n instanceof yd && n.vars.onComplete === n._targets[0]) || dh(r, n, n._start - n._delay), (n = i);
						return dh(Hc, r, 0), r;
					},
					utils: {
						wrap: function t(e, n, i) {
							var r = n - e;
							return mu(e)
								? zh(e, t(0, e.length), n)
								: wh(i, function (t) {
										return ((r + ((t - e) % r)) % r) + e;
								  });
						},
						wrapYoyo: function t(e, n, i) {
							var r = n - e,
								a = 2 * r;
							return mu(e)
								? zh(e, t(0, e.length - 1), n)
								: wh(i, function (t) {
										return e + ((t = (a + ((t - e) % a)) % a || 0) > r ? a - t : t);
								  });
						},
						distribute: Lh,
						random: Oh,
						snap: Dh,
						normalize: function (t, e, n) {
							return kh(t, e, 0, 1, n);
						},
						getUnit: Sh,
						clamp: function (t, e, n) {
							return wh(n, function (n) {
								return Mh(t, e, n);
							});
						},
						splitColor: Wh,
						toArray: Ph,
						selector: function (t) {
							return (
								(t = Ph(t)[0] || Cu("Invalid scope") || {}),
								function (e) {
									var n = t.current || t.nativeElement || t;
									return Ph(e, n.querySelectorAll ? n : n === t ? Cu("Invalid scope") || jc.createElement("div") : t);
								}
							);
						},
						mapRange: kh,
						pipe: function () {
							for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
							return function (t) {
								return e.reduce(function (t, e) {
									return e(t);
								}, t);
							};
						},
						unitize: function (t, e) {
							return function (n) {
								return t(parseFloat(n)) + (e || Sh(n));
							};
						},
						interpolate: function t(e, n, i, r) {
							var a = isNaN(e + n)
								? 0
								: function (t) {
										return (1 - t) * e + t * n;
								  };
							if (!a) {
								var s,
									o,
									l,
									c,
									u,
									h = su(e),
									d = {};
								if ((!0 === i && (r = 1) && (i = null), h)) (e = { p: e }), (n = { p: n });
								else if (mu(e) && !mu(n)) {
									for (l = [], c = e.length, u = c - 2, o = 1; o < c; o++) l.push(t(e[o - 1], e[o]));
									c--,
										(a = function (t) {
											t *= c;
											var e = Math.min(u, ~~t);
											return l[e](t - e);
										}),
										(i = n);
								} else r || (e = Ju(mu(e) ? [] : {}, e));
								if (!l) {
									for (s in n) fd.call(d, e, s, "get", n[s]);
									a = function (t) {
										return Ad(t, d) || (h ? e.p : e);
									};
								}
							}
							return wh(i, a);
						},
						shuffle: Ah,
					},
					install: Tu,
					effects: zu,
					ticker: Kh,
					updateRoot: hd.updateRoot,
					plugins: Ou,
					globalTimeline: Hc,
					core: {
						PropTween: zd,
						globals: Pu,
						Tween: yd,
						Timeline: hd,
						Animation: ud,
						getCache: Bu,
						_removeLinkedListItem: eh,
						suppressOverwrites: function (t) {
							return (Uc = t);
						},
					},
				};
				Uu("to,from,fromTo,delayedCall,set,killTweensOf", function (t) {
					return (Id[t] = yd[t]);
				}),
					Kh.add(hd.updateRoot),
					(Yc = Id.to({}, { duration: 0 }));
				var kd = function (t, e) {
						for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e; ) n = n._next;
						return n;
					},
					Nd = function (t, e) {
						return {
							name: t,
							rawVars: 1,
							init: function (t, n, i) {
								i._onInit = function (t) {
									var i, r;
									if (
										(su(n) &&
											((i = {}),
											Uu(n, function (t) {
												return (i[t] = 1);
											}),
											(n = i)),
										e)
									) {
										for (r in ((i = {}), n)) i[r] = e(n[r]);
										n = i;
									}
									!(function (t, e) {
										var n,
											i,
											r,
											a = t._targets;
										for (n in e) for (i = a.length; i--; ) (r = t._ptLookup[i][n]) && (r = r.d) && (r._pt && (r = kd(r, n)), r && r.modifier && r.modifier(e[n], t, a[i], n));
									})(t, n);
								};
							},
						};
					},
					Vd =
						Id.registerPlugin(
							{
								name: "attr",
								init: function (t, e, n, i, r) {
									var a, s;
									for (a in e) (s = this.add(t, "setAttribute", (t.getAttribute(a) || 0) + "", e[a], i, r, 0, 0, a)) && (s.op = a), this._props.push(a);
								},
							},
							{
								name: "endArray",
								init: function (t, e) {
									for (var n = e.length; n--; ) this.add(t, n, t[n] || 0, e[n]);
								},
							},
							Nd("roundProps", Rh),
							Nd("modifiers"),
							Nd("snap", Dh)
						) || Id;
				(yd.version = hd.version = Vd.version = "3.8.0"), (Xc = 1), du() && Jh();
				Qh.Power0, Qh.Power1, Qh.Power2, Qh.Power3, Qh.Power4, Qh.Linear, Qh.Quad, Qh.Cubic, Qh.Quart, Qh.Quint, Qh.Strong, Qh.Elastic, Qh.Back, Qh.SteppedEase, Qh.Bounce, Qh.Sine, Qh.Expo, Qh.Circ;
				var Bd,
					Fd,
					Ud,
					Hd,
					Gd,
					Wd,
					jd,
					Xd = {},
					qd = 180 / Math.PI,
					Yd = Math.PI / 180,
					Zd = Math.atan2,
					Kd = /([A-Z])/g,
					Jd = /(?:left|right|width|margin|padding|x)/i,
					Qd = /[\s,\(]\S/,
					$d = { autoAlpha: "opacity,visibility", scale: "scaleX,scaleY", alpha: "opacity" },
					tp = function (t, e) {
						return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e);
					},
					ep = function (t, e) {
						return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e);
					},
					np = function (t, e) {
						return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e);
					},
					ip = function (t, e) {
						var n = e.s + e.c * t;
						e.set(e.t, e.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + e.u, e);
					},
					rp = function (t, e) {
						return e.set(e.t, e.p, t ? e.e : e.b, e);
					},
					ap = function (t, e) {
						return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e);
					},
					sp = function (t, e, n) {
						return (t.style[e] = n);
					},
					op = function (t, e, n) {
						return t.style.setProperty(e, n);
					},
					lp = function (t, e, n) {
						return (t._gsap[e] = n);
					},
					cp = function (t, e, n) {
						return (t._gsap.scaleX = t._gsap.scaleY = n);
					},
					up = function (t, e, n, i, r) {
						var a = t._gsap;
						(a.scaleX = a.scaleY = n), a.renderTransform(r, a);
					},
					hp = function (t, e, n, i, r) {
						var a = t._gsap;
						(a[e] = n), a.renderTransform(r, a);
					},
					dp = "transform",
					pp = dp + "Origin",
					fp = function (t, e) {
						var n = Fd.createElementNS ? Fd.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : Fd.createElement(t);
						return n.style ? n : Fd.createElement(t);
					},
					mp = function t(e, n, i) {
						var r = getComputedStyle(e);
						return r[n] || r.getPropertyValue(n.replace(Kd, "-$1").toLowerCase()) || r.getPropertyValue(n) || (!i && t(e, gp(n) || n, 1)) || "";
					},
					vp = "O,Moz,ms,Ms,Webkit".split(","),
					gp = function (t, e, n) {
						var i = (e || Gd).style,
							r = 5;
						if (t in i && !n) return t;
						for (t = t.charAt(0).toUpperCase() + t.substr(1); r-- && !(vp[r] + t in i); );
						return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? vp[r] : "") + t;
					},
					bp = function () {
						"undefined" != typeof window && window.document && ((Bd = window), (Fd = Bd.document), (Ud = Fd.documentElement), (Gd = fp("div") || { style: {} }), fp("div"), (dp = gp(dp)), (pp = dp + "Origin"), (Gd.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0"), (jd = !!gp("perspective")), (Hd = 1));
					},
					xp = function t(e) {
						var n,
							i = fp("svg", (this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns")) || "http://www.w3.org/2000/svg"),
							r = this.parentNode,
							a = this.nextSibling,
							s = this.style.cssText;
						if ((Ud.appendChild(i), i.appendChild(this), (this.style.display = "block"), e))
							try {
								(n = this.getBBox()), (this._gsapBBox = this.getBBox), (this.getBBox = t);
							} catch (t) {}
						else this._gsapBBox && (n = this._gsapBBox());
						return r && (a ? r.insertBefore(this, a) : r.appendChild(this)), Ud.removeChild(i), (this.style.cssText = s), n;
					},
					yp = function (t, e) {
						for (var n = e.length; n--; ) if (t.hasAttribute(e[n])) return t.getAttribute(e[n]);
					},
					_p = function (t) {
						var e;
						try {
							e = t.getBBox();
						} catch (n) {
							e = xp.call(t, !0);
						}
						return (e && (e.width || e.height)) || t.getBBox === xp || (e = xp.call(t, !0)), !e || e.width || e.x || e.y ? e : { x: +yp(t, ["x", "cx", "x1"]) || 0, y: +yp(t, ["y", "cy", "y1"]) || 0, width: 0, height: 0 };
					},
					wp = function (t) {
						return !(!t.getCTM || (t.parentNode && !t.ownerSVGElement) || !_p(t));
					},
					Mp = function (t, e) {
						if (e) {
							var n = t.style;
							e in Xd && e !== pp && (e = dp), n.removeProperty ? (("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6)) || (e = "-" + e), n.removeProperty(e.replace(Kd, "-$1").toLowerCase())) : n.removeAttribute(e);
						}
					},
					Sp = function (t, e, n, i, r, a) {
						var s = new zd(t._pt, e, n, 0, 1, a ? ap : rp);
						return (t._pt = s), (s.b = i), (s.e = r), t._props.push(n), s;
					},
					Tp = { deg: 1, rad: 1, turn: 1 },
					Ep = function t(e, n, i, r) {
						var a,
							s,
							o,
							l,
							c = parseFloat(i) || 0,
							u = (i + "").trim().substr((c + "").length) || "px",
							h = Gd.style,
							d = Jd.test(n),
							p = "svg" === e.tagName.toLowerCase(),
							f = (p ? "client" : "offset") + (d ? "Width" : "Height"),
							m = 100,
							v = "px" === r,
							g = "%" === r;
						return r === u || !c || Tp[r] || Tp[u]
							? c
							: ("px" !== u && !v && (c = t(e, n, i, "px")),
							  (l = e.getCTM && wp(e)),
							  (!g && "%" !== u) || (!Xd[n] && !~n.indexOf("adius"))
									? ((h[d ? "width" : "height"] = m + (v ? u : r)),
									  (s = ~n.indexOf("adius") || ("em" === r && e.appendChild && !p) ? e : e.parentNode),
									  l && (s = (e.ownerSVGElement || {}).parentNode),
									  (s && s !== Fd && s.appendChild) || (s = Fd.body),
									  (o = s._gsap) && g && o.width && d && o.time === Kh.time ? Hu((c / o.width) * m) : ((g || "%" === u) && (h.position = mp(e, "position")), s === e && (h.position = "static"), s.appendChild(Gd), (a = Gd[f]), s.removeChild(Gd), (h.position = "absolute"), d && g && (((o = Bu(s)).time = Kh.time), (o.width = s[f])), Hu(v ? (a * c) / m : a && c ? (m / a) * c : 0)))
									: ((a = l ? e.getBBox()[d ? "width" : "height"] : e[f]), Hu(g ? (c / a) * m : (c / 100) * a)));
					},
					Cp = function (t, e, n, i) {
						var r;
						return Hd || bp(), e in $d && "transform" !== e && ~(e = $d[e]).indexOf(",") && (e = e.split(",")[0]), Xd[e] && "transform" !== e ? ((r = Vp(t, i)), (r = "transformOrigin" !== e ? r[e] : r.svg ? r.origin : Bp(mp(t, pp)) + " " + r.zOrigin + "px")) : (!(r = t.style[e]) || "auto" === r || i || ~(r + "").indexOf("calc(")) && (r = (Rp[e] && Rp[e](t, e, n)) || mp(t, e) || Fu(t, e) || ("opacity" === e ? 1 : 0)), n && !~(r + "").trim().indexOf(" ") ? Ep(t, e, r, n) + n : r;
					},
					Pp = function (t, e, n, i) {
						if (!n || "none" === n) {
							var r = gp(e, t, 1),
								a = r && mp(t, r, 1);
							a && a !== n ? ((e = r), (n = a)) : "borderColor" === e && (n = mp(t, "borderTopColor"));
						}
						var s,
							o,
							l,
							c,
							u,
							h,
							d,
							p,
							f,
							m,
							v,
							g,
							b = new zd(this._pt, t.style, e, 0, 1, Pd),
							x = 0,
							y = 0;
						if (((b.b = n), (b.e = i), (n += ""), "auto" === (i += "") && ((t.style[e] = i), (i = mp(t, e) || i), (t.style[e] = n)), Zh((s = [n, i])), (i = s[1]), (l = (n = s[0]).match(bu) || []), (i.match(bu) || []).length)) {
							for (; (o = bu.exec(i)); )
								(d = o[0]),
									(f = i.substring(x, o.index)),
									u ? (u = (u + 1) % 5) : ("rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5)) || (u = 1),
									d !== (h = l[y++] || "") &&
										((c = parseFloat(h) || 0),
										(v = h.substr((c + "").length)),
										(g = "=" === d.charAt(1) ? +(d.charAt(0) + "1") : 0) && (d = d.substr(2)),
										(p = parseFloat(d)),
										(m = d.substr((p + "").length)),
										(x = bu.lastIndex - m.length),
										m || ((m = m || Kc.units[e] || v), x === i.length && ((i += m), (b.e += m))),
										v !== m && (c = Ep(t, e, h, m) || 0),
										(b._pt = { _next: b._pt, p: f || 1 === y ? f : ",", s: c, c: g ? g * p : p - c, m: (u && u < 4) || "zIndex" === e ? Math.round : 0 }));
							b.c = x < i.length ? i.substring(x, i.length) : "";
						} else b.r = "display" === e && "none" === i ? ap : rp;
						return yu.test(i) && (b.e = 0), (this._pt = b), b;
					},
					Ap = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" },
					Lp = function (t, e) {
						if (e.tween && e.tween._time === e.tween._dur) {
							var n,
								i,
								r,
								a = e.t,
								s = a.style,
								o = e.u,
								l = a._gsap;
							if ("all" === o || !0 === o) (s.cssText = ""), (i = 1);
							else for (r = (o = o.split(",")).length; --r > -1; ) (n = o[r]), Xd[n] && ((i = 1), (n = "transformOrigin" === n ? pp : dp)), Mp(a, n);
							i && (Mp(a, dp), l && (l.svg && a.removeAttribute("transform"), Vp(a, 1), (l.uncache = 1)));
						}
					},
					Rp = {
						clearProps: function (t, e, n, i, r) {
							if ("isFromStart" !== r.data) {
								var a = (t._pt = new zd(t._pt, e, n, 0, 0, Lp));
								return (a.u = i), (a.pr = -10), (a.tween = r), t._props.push(n), 1;
							}
						},
					},
					Dp = [1, 0, 0, 1, 0, 0],
					Op = {},
					zp = function (t) {
						return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t;
					},
					Ip = function (t) {
						var e = mp(t, dp);
						return zp(e) ? Dp : e.substr(7).match(gu).map(Hu);
					},
					kp = function (t, e) {
						var n,
							i,
							r,
							a,
							s = t._gsap || Bu(t),
							o = t.style,
							l = Ip(t);
						return s.svg && t.getAttribute("transform")
							? "1,0,0,1,0,0" === (l = [(r = t.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",")
								? Dp
								: l
							: (l !== Dp || t.offsetParent || t === Ud || s.svg || ((r = o.display), (o.display = "block"), ((n = t.parentNode) && t.offsetParent) || ((a = 1), (i = t.nextSibling), Ud.appendChild(t)), (l = Ip(t)), r ? (o.display = r) : Mp(t, "display"), a && (i ? n.insertBefore(t, i) : n ? n.appendChild(t) : Ud.removeChild(t))), e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l);
					},
					Np = function (t, e, n, i, r, a) {
						var s,
							o,
							l,
							c = t._gsap,
							u = r || kp(t, !0),
							h = c.xOrigin || 0,
							d = c.yOrigin || 0,
							p = c.xOffset || 0,
							f = c.yOffset || 0,
							m = u[0],
							v = u[1],
							g = u[2],
							b = u[3],
							x = u[4],
							y = u[5],
							_ = e.split(" "),
							w = parseFloat(_[0]) || 0,
							M = parseFloat(_[1]) || 0;
						n ? u !== Dp && (o = m * b - v * g) && ((l = w * (-v / o) + M * (m / o) - (m * y - v * x) / o), (w = w * (b / o) + M * (-g / o) + (g * y - b * x) / o), (M = l)) : ((w = (s = _p(t)).x + (~_[0].indexOf("%") ? (w / 100) * s.width : w)), (M = s.y + (~(_[1] || _[0]).indexOf("%") ? (M / 100) * s.height : M))),
							i || (!1 !== i && c.smooth) ? ((x = w - h), (y = M - d), (c.xOffset = p + (x * m + y * g) - x), (c.yOffset = f + (x * v + y * b) - y)) : (c.xOffset = c.yOffset = 0),
							(c.xOrigin = w),
							(c.yOrigin = M),
							(c.smooth = !!i),
							(c.origin = e),
							(c.originIsAbsolute = !!n),
							(t.style[pp] = "0px 0px"),
							a && (Sp(a, c, "xOrigin", h, w), Sp(a, c, "yOrigin", d, M), Sp(a, c, "xOffset", p, c.xOffset), Sp(a, c, "yOffset", f, c.yOffset)),
							t.setAttribute("data-svg-origin", w + " " + M);
					},
					Vp = function (t, e) {
						var n = t._gsap || new cd(t);
						if ("x" in n && !e && !n.uncache) return n;
						var i,
							r,
							a,
							s,
							o,
							l,
							c,
							u,
							h,
							d,
							p,
							f,
							m,
							v,
							g,
							b,
							x,
							y,
							_,
							w,
							M,
							S,
							T,
							E,
							C,
							P,
							A,
							L,
							R,
							D,
							O,
							z,
							I = t.style,
							k = n.scaleX < 0,
							N = "px",
							V = "deg",
							B = mp(t, pp) || "0";
						return (
							(i = r = a = l = c = u = h = d = p = 0),
							(s = o = 1),
							(n.svg = !(!t.getCTM || !wp(t))),
							(v = kp(t, n.svg)),
							n.svg && ((E = (!n.uncache || "0px 0px" === B) && !e && t.getAttribute("data-svg-origin")), Np(t, E || B, !!E || n.originIsAbsolute, !1 !== n.smooth, v)),
							(f = n.xOrigin || 0),
							(m = n.yOrigin || 0),
							v !== Dp &&
								((y = v[0]),
								(_ = v[1]),
								(w = v[2]),
								(M = v[3]),
								(i = S = v[4]),
								(r = T = v[5]),
								6 === v.length
									? ((s = Math.sqrt(y * y + _ * _)), (o = Math.sqrt(M * M + w * w)), (l = y || _ ? Zd(_, y) * qd : 0), (h = w || M ? Zd(w, M) * qd + l : 0) && (o *= Math.abs(Math.cos(h * Yd))), n.svg && ((i -= f - (f * y + m * w)), (r -= m - (f * _ + m * M))))
									: ((z = v[6]),
									  (D = v[7]),
									  (A = v[8]),
									  (L = v[9]),
									  (R = v[10]),
									  (O = v[11]),
									  (i = v[12]),
									  (r = v[13]),
									  (a = v[14]),
									  (c = (g = Zd(z, R)) * qd),
									  g && ((E = S * (b = Math.cos(-g)) + A * (x = Math.sin(-g))), (C = T * b + L * x), (P = z * b + R * x), (A = S * -x + A * b), (L = T * -x + L * b), (R = z * -x + R * b), (O = D * -x + O * b), (S = E), (T = C), (z = P)),
									  (u = (g = Zd(-w, R)) * qd),
									  g && ((b = Math.cos(-g)), (O = M * (x = Math.sin(-g)) + O * b), (y = E = y * b - A * x), (_ = C = _ * b - L * x), (w = P = w * b - R * x)),
									  (l = (g = Zd(_, y)) * qd),
									  g && ((E = y * (b = Math.cos(g)) + _ * (x = Math.sin(g))), (C = S * b + T * x), (_ = _ * b - y * x), (T = T * b - S * x), (y = E), (S = C)),
									  c && Math.abs(c) + Math.abs(l) > 359.9 && ((c = l = 0), (u = 180 - u)),
									  (s = Hu(Math.sqrt(y * y + _ * _ + w * w))),
									  (o = Hu(Math.sqrt(T * T + z * z))),
									  (g = Zd(S, T)),
									  (h = Math.abs(g) > 2e-4 ? g * qd : 0),
									  (p = O ? 1 / (O < 0 ? -O : O) : 0)),
								n.svg && ((E = t.getAttribute("transform")), (n.forceCSS = t.setAttribute("transform", "") || !zp(mp(t, dp))), E && t.setAttribute("transform", E))),
							Math.abs(h) > 90 && Math.abs(h) < 270 && (k ? ((s *= -1), (h += l <= 0 ? 180 : -180), (l += l <= 0 ? 180 : -180)) : ((o *= -1), (h += h <= 0 ? 180 : -180))),
							(n.x = i - ((n.xPercent = i && (n.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-i) ? -50 : 0))) ? (t.offsetWidth * n.xPercent) / 100 : 0) + N),
							(n.y = r - ((n.yPercent = r && (n.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? (t.offsetHeight * n.yPercent) / 100 : 0) + N),
							(n.z = a + N),
							(n.scaleX = Hu(s)),
							(n.scaleY = Hu(o)),
							(n.rotation = Hu(l) + V),
							(n.rotationX = Hu(c) + V),
							(n.rotationY = Hu(u) + V),
							(n.skewX = h + V),
							(n.skewY = d + V),
							(n.transformPerspective = p + N),
							(n.zOrigin = parseFloat(B.split(" ")[2]) || 0) && (I[pp] = Bp(B)),
							(n.xOffset = n.yOffset = 0),
							(n.force3D = Kc.force3D),
							(n.renderTransform = n.svg ? Xp : jd ? jp : Up),
							(n.uncache = 0),
							n
						);
					},
					Bp = function (t) {
						return (t = t.split(" "))[0] + " " + t[1];
					},
					Fp = function (t, e, n) {
						var i = Sh(e);
						return Hu(parseFloat(e) + parseFloat(Ep(t, "x", n + "px", i))) + i;
					},
					Up = function (t, e) {
						(e.z = "0px"), (e.rotationY = e.rotationX = "0deg"), (e.force3D = 0), jp(t, e);
					},
					Hp = "0deg",
					Gp = "0px",
					Wp = ") ",
					jp = function (t, e) {
						var n = e || this,
							i = n.xPercent,
							r = n.yPercent,
							a = n.x,
							s = n.y,
							o = n.z,
							l = n.rotation,
							c = n.rotationY,
							u = n.rotationX,
							h = n.skewX,
							d = n.skewY,
							p = n.scaleX,
							f = n.scaleY,
							m = n.transformPerspective,
							v = n.force3D,
							g = n.target,
							b = n.zOrigin,
							x = "",
							y = ("auto" === v && t && 1 !== t) || !0 === v;
						if (b && (u !== Hp || c !== Hp)) {
							var _,
								w = parseFloat(c) * Yd,
								M = Math.sin(w),
								S = Math.cos(w);
							(w = parseFloat(u) * Yd), (_ = Math.cos(w)), (a = Fp(g, a, M * _ * -b)), (s = Fp(g, s, -Math.sin(w) * -b)), (o = Fp(g, o, S * _ * -b + b));
						}
						m !== Gp && (x += "perspective(" + m + Wp),
							(i || r) && (x += "translate(" + i + "%, " + r + "%) "),
							(y || a !== Gp || s !== Gp || o !== Gp) && (x += o !== Gp || y ? "translate3d(" + a + ", " + s + ", " + o + ") " : "translate(" + a + ", " + s + Wp),
							l !== Hp && (x += "rotate(" + l + Wp),
							c !== Hp && (x += "rotateY(" + c + Wp),
							u !== Hp && (x += "rotateX(" + u + Wp),
							(h === Hp && d === Hp) || (x += "skew(" + h + ", " + d + Wp),
							(1 === p && 1 === f) || (x += "scale(" + p + ", " + f + Wp),
							(g.style[dp] = x || "translate(0, 0)");
					},
					Xp = function (t, e) {
						var n,
							i,
							r,
							a,
							s,
							o = e || this,
							l = o.xPercent,
							c = o.yPercent,
							u = o.x,
							h = o.y,
							d = o.rotation,
							p = o.skewX,
							f = o.skewY,
							m = o.scaleX,
							v = o.scaleY,
							g = o.target,
							b = o.xOrigin,
							x = o.yOrigin,
							y = o.xOffset,
							_ = o.yOffset,
							w = o.forceCSS,
							M = parseFloat(u),
							S = parseFloat(h);
						(d = parseFloat(d)),
							(p = parseFloat(p)),
							(f = parseFloat(f)) && ((p += f = parseFloat(f)), (d += f)),
							d || p ? ((d *= Yd), (p *= Yd), (n = Math.cos(d) * m), (i = Math.sin(d) * m), (r = Math.sin(d - p) * -v), (a = Math.cos(d - p) * v), p && ((f *= Yd), (s = Math.tan(p - f)), (r *= s = Math.sqrt(1 + s * s)), (a *= s), f && ((s = Math.tan(f)), (n *= s = Math.sqrt(1 + s * s)), (i *= s))), (n = Hu(n)), (i = Hu(i)), (r = Hu(r)), (a = Hu(a))) : ((n = m), (a = v), (i = r = 0)),
							((M && !~(u + "").indexOf("px")) || (S && !~(h + "").indexOf("px"))) && ((M = Ep(g, "x", u, "px")), (S = Ep(g, "y", h, "px"))),
							(b || x || y || _) && ((M = Hu(M + b - (b * n + x * r) + y)), (S = Hu(S + x - (b * i + x * a) + _))),
							(l || c) && ((s = g.getBBox()), (M = Hu(M + (l / 100) * s.width)), (S = Hu(S + (c / 100) * s.height))),
							(s = "matrix(" + n + "," + i + "," + r + "," + a + "," + M + "," + S + ")"),
							g.setAttribute("transform", s),
							w && (g.style[dp] = s);
					},
					qp = function (t, e, n, i, r, a) {
						var s,
							o,
							l = 360,
							c = su(r),
							u = parseFloat(r) * (c && ~r.indexOf("rad") ? qd : 1),
							h = a ? u * a : u - i,
							d = i + h + "deg";
						return c && ("short" === (s = r.split("_")[1]) && (h %= l) !== h % 180 && (h += h < 0 ? l : -360), "cw" === s && h < 0 ? (h = ((h + 36e9) % l) - ~~(h / l) * l) : "ccw" === s && h > 0 && (h = ((h - 36e9) % l) - ~~(h / l) * l)), (t._pt = o = new zd(t._pt, e, n, i, h, ep)), (o.e = d), (o.u = "deg"), t._props.push(n), o;
					},
					Yp = function (t, e) {
						for (var n in e) t[n] = e[n];
						return t;
					},
					Zp = function (t, e, n) {
						var i,
							r,
							a,
							s,
							o,
							l,
							c,
							u = Yp({}, n._gsap),
							h = n.style;
						for (r in (u.svg ? ((a = n.getAttribute("transform")), n.setAttribute("transform", ""), (h[dp] = e), (i = Vp(n, 1)), Mp(n, dp), n.setAttribute("transform", a)) : ((a = getComputedStyle(n)[dp]), (h[dp] = e), (i = Vp(n, 1)), (h[dp] = a)), Xd))
							(a = u[r]) !== (s = i[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && ((o = Sh(a) !== (c = Sh(s)) ? Ep(n, r, a, c) : parseFloat(a)), (l = parseFloat(s)), (t._pt = new zd(t._pt, i, r, o, l - o, tp)), (t._pt.u = c || 0), t._props.push(r));
						Yp(i, u);
					};
				Uu("padding,margin,Width,Radius", function (t, e) {
					var n = "Top",
						i = "Right",
						r = "Bottom",
						a = "Left",
						s = (e < 3 ? [n, i, r, a] : [n + a, n + i, r + i, r + a]).map(function (n) {
							return e < 2 ? t + n : "border" + n + t;
						});
					Rp[e > 1 ? "border" + t : t] = function (t, e, n, i, r) {
						var a, o;
						if (arguments.length < 4)
							return (
								(a = s.map(function (e) {
									return Cp(t, e, n);
								})),
								5 === (o = a.join(" ")).split(a[0]).length ? a[0] : o
							);
						(a = (i + "").split(" ")),
							(o = {}),
							s.forEach(function (t, e) {
								return (o[t] = a[e] = a[e] || a[((e - 1) / 2) | 0]);
							}),
							t.init(e, o, r);
					};
				});
				var Kp,
					Jp,
					Qp,
					$p = {
						name: "css",
						register: bp,
						targetTest: function (t) {
							return t.style && t.nodeType;
						},
						init: function (t, e, n, i, r) {
							var a,
								s,
								o,
								l,
								c,
								u,
								h,
								d,
								p,
								f,
								m,
								v,
								g,
								b,
								x,
								y,
								_,
								w,
								M,
								S = this._props,
								T = t.style,
								E = n.vars.startAt;
							for (h in (Hd || bp(), e))
								if ("autoRound" !== h && ((s = e[h]), !Ou[h] || !md(h, e, n, i, t, r)))
									if (((c = typeof s), (u = Rp[h]), "function" === c && (c = typeof (s = s.call(n, i, t, r))), "string" === c && ~s.indexOf("random(") && (s = Ih(s)), u)) u(this, t, h, s, n) && (x = 1);
									else if ("--" === h.substr(0, 2)) (a = (getComputedStyle(t).getPropertyValue(h) + "").trim()), (s += ""), (qh.lastIndex = 0), qh.test(a) || ((d = Sh(a)), (p = Sh(s))), p ? d !== p && (a = Ep(t, h, a, p) + p) : d && (s += d), this.add(T, "setProperty", a, s, i, r, 0, 0, h), S.push(h);
									else if ("undefined" !== c) {
										if (
											(E && h in E ? ((a = "function" == typeof E[h] ? E[h].call(n, i, t, r) : E[h]), h in Kc.units && !Sh(a) && (a += Kc.units[h]), su(a) && ~a.indexOf("random(") && (a = Ih(a)), "=" === (a + "").charAt(1) && (a = Cp(t, h))) : (a = Cp(t, h)),
											(l = parseFloat(a)),
											(f = "string" === c && "=" === s.charAt(1) ? +(s.charAt(0) + "1") : 0) && (s = s.substr(2)),
											(o = parseFloat(s)),
											h in $d && ("autoAlpha" === h && (1 === l && "hidden" === Cp(t, "visibility") && o && (l = 0), Sp(this, T, "visibility", l ? "inherit" : "hidden", o ? "inherit" : "hidden", !o)), "scale" !== h && "transform" !== h && ~(h = $d[h]).indexOf(",") && (h = h.split(",")[0])),
											(m = h in Xd))
										)
											if ((v || (((g = t._gsap).renderTransform && !e.parseTransform) || Vp(t, e.parseTransform), (b = !1 !== e.smoothOrigin && g.smooth), ((v = this._pt = new zd(this._pt, T, dp, 0, 1, g.renderTransform, g, 0, -1)).dep = 1)), "scale" === h)) (this._pt = new zd(this._pt, g, "scaleY", g.scaleY, (f ? f * o : o - g.scaleY) || 0)), S.push("scaleY", h), (h += "X");
											else {
												if ("transformOrigin" === h) {
													(_ = void 0), (w = void 0), (M = void 0), (_ = (y = s).split(" ")), (w = _[0]), (M = _[1] || "50%"), ("top" !== w && "bottom" !== w && "left" !== M && "right" !== M) || ((y = w), (w = M), (M = y)), (_[0] = Ap[w] || w), (_[1] = Ap[M] || M), (s = _.join(" ")), g.svg ? Np(t, s, 0, b, 0, this) : ((p = parseFloat(s.split(" ")[2]) || 0) !== g.zOrigin && Sp(this, g, "zOrigin", g.zOrigin, p), Sp(this, T, h, Bp(a), Bp(s)));
													continue;
												}
												if ("svgOrigin" === h) {
													Np(t, s, 1, b, 0, this);
													continue;
												}
												if (h in Op) {
													qp(this, g, h, l, s, f);
													continue;
												}
												if ("smoothOrigin" === h) {
													Sp(this, g, "smooth", g.smooth, s);
													continue;
												}
												if ("force3D" === h) {
													g[h] = s;
													continue;
												}
												if ("transform" === h) {
													Zp(this, s, t);
													continue;
												}
											}
										else h in T || (h = gp(h) || h);
										if (m || ((o || 0 === o) && (l || 0 === l) && !Qd.test(s) && h in T)) o || (o = 0), (d = (a + "").substr((l + "").length)) !== (p = Sh(s) || (h in Kc.units ? Kc.units[h] : d)) && (l = Ep(t, h, a, p)), (this._pt = new zd(this._pt, m ? g : T, h, l, f ? f * o : o - l, m || ("px" !== p && "zIndex" !== h) || !1 === e.autoRound ? tp : ip)), (this._pt.u = p || 0), d !== p && "%" !== p && ((this._pt.b = a), (this._pt.r = np));
										else if (h in T) Pp.call(this, t, h, a, s);
										else {
											if (!(h in t)) {
												Eu(h, s);
												continue;
											}
											this.add(t, h, a || t[h], s, i, r);
										}
										S.push(h);
									}
							x && Od(this);
						},
						get: Cp,
						aliases: $d,
						getSetter: function (t, e, n) {
							var i = $d[e];
							return i && i.indexOf(",") < 0 && (e = i), e in Xd && e !== pp && (t._gsap.x || Cp(t, "x")) ? (n && Wd === n ? ("scale" === e ? cp : lp) : (Wd = n || {}) && ("scale" === e ? up : hp)) : t.style && !cu(t.style[e]) ? sp : ~e.indexOf("-") ? op : Td(t, e);
						},
						core: { _removeProperty: Mp, _getMatrix: kp },
					};
				(Vd.utils.checkPrefix = gp),
					(Qp = Uu((Kp = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") + "," + (Jp = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", function (t) {
						Xd[t] = 1;
					})),
					Uu(Jp, function (t) {
						(Kc.units[t] = "deg"), (Op[t] = 1);
					}),
					($d[Qp[13]] = Kp + "," + Jp),
					Uu("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", function (t) {
						var e = t.split(":");
						$d[e[1]] = Qp[e[0]];
					}),
					Uu("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (t) {
						Kc.units[t] = "px";
					}),
					Vd.registerPlugin($p);
				var tf = Vd.registerPlugin($p) || Vd,
					ef = (tf.core.Tween, n(1511)),
					nf = n.n(ef),
					rf = {
						BG: 1250073,
						BGALT: 1029,
						mainColor: 16777215,
						time: { value: 0 },
						delta: { value: 0 },
						goWild: { value: 0 },
						fishEye: { value: 0 },
						changeStars: { value: 0 },
						isBloomPass: { value: !1 },
						performance: { value: 3, isMobile: null },
						amountParticles: { label: "Amount of Particles", options: { low: 32, medium: 80, high: 128, ultra: 256 }, uniform: { value: [80, 32] } },
						distortionFishEye: { label: "Distortion Fisheye", min: 0, max: 2, uniform: { value: 0.7 } },
						enableDof: { label: "Enable Dof", uniform: { value: [!0, !1] } },
						enableBloom: { label: "Enable Bloom", uniform: { value: [!0, !1] } },
						strength: { label: "Strength", min: 0, max: 3, uniform: { value: 0.6 } },
						radius: { label: "Radius", min: 0, max: 1, uniform: { value: 0.24 } },
						threshold: { label: "Threshold", min: 0, max: 2, uniform: { value: 0.5 } },
						repulsion: { label: "Repulsion Radius", min: 0, max: 100, uniform: { value: 20 } },
						repulsionForce: { label: "Repulsion Force", min: 0, max: 1, uniform: { value: 0.5 } },
						attractionForce: { label: "Attraction Force", min: 0, max: 10, uniform: { value: 2 } },
						minSpeed: { label: "Acceleration", min: 0, max: 0.5, uniform: { value: 0.1 } },
						maxSpeed: { label: "Max acceleration", min: 0, max: 0.5, uniform: { value: 0.2 } },
						normalScale: { label: "Water distortion Factor", min: 0.1, max: 50, uniform: { value: 30 } },
						timeScale: { label: "Time Scale", min: 0, max: 1, uniform: { value: 1 } },
						noiseIntensity: { label: "Noise intensity", min: 0, max: 0.5, uniform: { value: 0.2 } },
						minLifeSpan: { label: "minLifeSpan", min: 0, max: 2, uniform: { value: 0.5 } },
						maxLifeSpan: { label: "maxLifeSpan", min: 1, max: 3, uniform: { value: 1 } },
						minVelocity: { label: "Min Velocity", min: 0, max: 4, uniform: { value: 2.7 } },
						maxVelocity: { label: "Max Velocity", min: 1, max: 10, uniform: { value: 3.8 } },
						lifespan: { label: "Lifespan", min: 0.1, max: 3, uniform: { value: 1.2 } },
						lambda: { label: "Damping Factor", min: 0.9, max: 1, step: 0.001, uniform: { value: 0.95 } },
						mulValue: { label: "Shininess", min: 0, max: 20, uniform: { value: 10 } },
						powerValue: { label: "powerValue", min: 0, max: 2, uniform: { value: 1 } },
						darkness: { label: "darkness", min: 0, max: 1, uniform: { value: 1 } },
						focus: { label: "Focus", min: 0, max: 1e3, uniform: { value: 326.087 } },
						maxblur: { label: "Maxblur", min: 0, max: 0.1, uniform: { value: 0.096 } },
						aperture: { label: "Aperture", min: 0, max: 1e-4, step: 1e-6, uniform: { value: 42e-6 } },
						gravity: { label: "Gravity", uniform: { value: new Xt(0, 0.015, 0) } },
						get: function (t) {
							var e = this[t],
								n = rf.performance.value < 2 && !rf.performance.isMobile;
							if (nf()(e.uniform.value)) {
								var i = n ? 1 : 0;
								e.uniform.value = e.uniform.value[i];
							}
							return e;
						},
					};
				const af = rf;
				var sf = n(1942),
					of = n.n(sf),
					lf = n(3466),
					cf = n.n(lf),
					uf = n(6498);
				const hf = { type: "change" },
					df = { type: "start" },
					pf = { type: "end" };
				class ff extends xt {
					constructor(t, e) {
						super(),
							void 0 === e && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),
							e === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),
							(this.object = t),
							(this.domElement = e),
							(this.domElement.style.touchAction = "none"),
							(this.enabled = !0),
							(this.target = new Xt()),
							(this.minDistance = 0),
							(this.maxDistance = 1 / 0),
							(this.minZoom = 0),
							(this.maxZoom = 1 / 0),
							(this.minPolarAngle = 0),
							(this.maxPolarAngle = Math.PI),
							(this.minAzimuthAngle = -1 / 0),
							(this.maxAzimuthAngle = 1 / 0),
							(this.enableDamping = !1),
							(this.dampingFactor = 0.05),
							(this.enableZoom = !0),
							(this.zoomSpeed = 1),
							(this.enableRotate = !0),
							(this.rotateSpeed = 1),
							(this.enablePan = !0),
							(this.panSpeed = 1),
							(this.screenSpacePanning = !0),
							(this.keyPanSpeed = 7),
							(this.autoRotate = !1),
							(this.autoRotateSpeed = 2),
							(this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }),
							(this.mouseButtons = { LEFT: E, MIDDLE: C, RIGHT: P }),
							(this.touches = { ONE: A, TWO: R }),
							(this.target0 = this.target.clone()),
							(this.position0 = this.object.position.clone()),
							(this.zoom0 = this.object.zoom),
							(this._domElementKeyEvents = null),
							(this.getPolarAngle = function () {
								return s.phi;
							}),
							(this.getAzimuthalAngle = function () {
								return s.theta;
							}),
							(this.getDistance = function () {
								return this.object.position.distanceTo(this.target);
							}),
							(this.listenToKeyEvents = function (t) {
								t.addEventListener("keydown", K), (this._domElementKeyEvents = t);
							}),
							(this.saveState = function () {
								n.target0.copy(n.target), n.position0.copy(n.object.position), (n.zoom0 = n.object.zoom);
							}),
							(this.reset = function () {
								n.target.copy(n.target0), n.object.position.copy(n.position0), (n.object.zoom = n.zoom0), n.object.updateProjectionMatrix(), n.dispatchEvent(hf), n.update(), (r = i.NONE);
							}),
							(this.update = (function () {
								const e = new Xt(),
									h = new jt().setFromUnitVectors(t.up, new Xt(0, 1, 0)),
									d = h.clone().invert(),
									p = new Xt(),
									f = new jt(),
									m = 2 * Math.PI;
								return function () {
									const t = n.object.position;
									e.copy(t).sub(n.target), e.applyQuaternion(h), s.setFromVector3(e), n.autoRotate && r === i.NONE && M(((2 * Math.PI) / 60 / 60) * n.autoRotateSpeed), n.enableDamping ? ((s.theta += o.theta * n.dampingFactor), (s.phi += o.phi * n.dampingFactor)) : ((s.theta += o.theta), (s.phi += o.phi));
									let v = n.minAzimuthAngle,
										g = n.maxAzimuthAngle;
									return (
										isFinite(v) && isFinite(g) && (v < -Math.PI ? (v += m) : v > Math.PI && (v -= m), g < -Math.PI ? (g += m) : g > Math.PI && (g -= m), (s.theta = v <= g ? Math.max(v, Math.min(g, s.theta)) : s.theta > (v + g) / 2 ? Math.max(v, s.theta) : Math.min(g, s.theta))),
										(s.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, s.phi))),
										s.makeSafe(),
										(s.radius *= l),
										(s.radius = Math.max(n.minDistance, Math.min(n.maxDistance, s.radius))),
										!0 === n.enableDamping ? n.target.addScaledVector(c, n.dampingFactor) : n.target.add(c),
										e.setFromSpherical(s),
										e.applyQuaternion(d),
										t.copy(n.target).add(e),
										n.object.lookAt(n.target),
										!0 === n.enableDamping ? ((o.theta *= 1 - n.dampingFactor), (o.phi *= 1 - n.dampingFactor), c.multiplyScalar(1 - n.dampingFactor)) : (o.set(0, 0, 0), c.set(0, 0, 0)),
										(l = 1),
										!!(u || p.distanceToSquared(n.object.position) > a || 8 * (1 - f.dot(n.object.quaternion)) > a) && (n.dispatchEvent(hf), p.copy(n.object.position), f.copy(n.object.quaternion), (u = !1), !0)
									);
								};
							})()),
							(this.dispose = function () {
								n.domElement.removeEventListener("contextmenu", J), n.domElement.removeEventListener("pointerdown", j), n.domElement.removeEventListener("pointercancel", Y), n.domElement.removeEventListener("wheel", Z), n.domElement.removeEventListener("pointermove", X), n.domElement.removeEventListener("pointerup", q), null !== n._domElementKeyEvents && n._domElementKeyEvents.removeEventListener("keydown", K);
							});
						const n = this,
							i = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 };
						let r = i.NONE;
						const a = 1e-6,
							s = new Ac(),
							o = new Ac();
						let l = 1;
						const c = new Xt();
						let u = !1;
						const h = new Ot(),
							d = new Ot(),
							p = new Ot(),
							f = new Ot(),
							m = new Ot(),
							v = new Ot(),
							g = new Ot(),
							b = new Ot(),
							x = new Ot(),
							y = [],
							_ = {};
						function w() {
							return Math.pow(0.95, n.zoomSpeed);
						}
						function M(t) {
							o.theta -= t;
						}
						function S(t) {
							o.phi -= t;
						}
						const T = (function () {
								const t = new Xt();
								return function (e, n) {
									t.setFromMatrixColumn(n, 0), t.multiplyScalar(-e), c.add(t);
								};
							})(),
							O = (function () {
								const t = new Xt();
								return function (e, i) {
									!0 === n.screenSpacePanning ? t.setFromMatrixColumn(i, 1) : (t.setFromMatrixColumn(i, 0), t.crossVectors(n.object.up, t)), t.multiplyScalar(e), c.add(t);
								};
							})(),
							z = (function () {
								const t = new Xt();
								return function (e, i) {
									const r = n.domElement;
									if (n.object.isPerspectiveCamera) {
										const a = n.object.position;
										t.copy(a).sub(n.target);
										let s = t.length();
										(s *= Math.tan(((n.object.fov / 2) * Math.PI) / 180)), T((2 * e * s) / r.clientHeight, n.object.matrix), O((2 * i * s) / r.clientHeight, n.object.matrix);
									} else n.object.isOrthographicCamera ? (T((e * (n.object.right - n.object.left)) / n.object.zoom / r.clientWidth, n.object.matrix), O((i * (n.object.top - n.object.bottom)) / n.object.zoom / r.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), (n.enablePan = !1));
								};
							})();
						function I(t) {
							n.object.isPerspectiveCamera ? (l /= t) : n.object.isOrthographicCamera ? ((n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom * t))), n.object.updateProjectionMatrix(), (u = !0)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), (n.enableZoom = !1));
						}
						function k(t) {
							n.object.isPerspectiveCamera ? (l *= t) : n.object.isOrthographicCamera ? ((n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / t))), n.object.updateProjectionMatrix(), (u = !0)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), (n.enableZoom = !1));
						}
						function N(t) {
							h.set(t.clientX, t.clientY);
						}
						function V(t) {
							f.set(t.clientX, t.clientY);
						}
						function B() {
							if (1 === y.length) h.set(y[0].pageX, y[0].pageY);
							else {
								const t = 0.5 * (y[0].pageX + y[1].pageX),
									e = 0.5 * (y[0].pageY + y[1].pageY);
								h.set(t, e);
							}
						}
						function F() {
							if (1 === y.length) f.set(y[0].pageX, y[0].pageY);
							else {
								const t = 0.5 * (y[0].pageX + y[1].pageX),
									e = 0.5 * (y[0].pageY + y[1].pageY);
								f.set(t, e);
							}
						}
						function U() {
							const t = y[0].pageX - y[1].pageX,
								e = y[0].pageY - y[1].pageY,
								n = Math.sqrt(t * t + e * e);
							g.set(0, n);
						}
						function H(t) {
							if (1 == y.length) d.set(t.pageX, t.pageY);
							else {
								const e = tt(t),
									n = 0.5 * (t.pageX + e.x),
									i = 0.5 * (t.pageY + e.y);
								d.set(n, i);
							}
							p.subVectors(d, h).multiplyScalar(n.rotateSpeed);
							const e = n.domElement;
							M((2 * Math.PI * p.x) / e.clientHeight), S((2 * Math.PI * p.y) / e.clientHeight), h.copy(d);
						}
						function G(t) {
							if (1 === y.length) m.set(t.pageX, t.pageY);
							else {
								const e = tt(t),
									n = 0.5 * (t.pageX + e.x),
									i = 0.5 * (t.pageY + e.y);
								m.set(n, i);
							}
							v.subVectors(m, f).multiplyScalar(n.panSpeed), z(v.x, v.y), f.copy(m);
						}
						function W(t) {
							const e = tt(t),
								i = t.pageX - e.x,
								r = t.pageY - e.y,
								a = Math.sqrt(i * i + r * r);
							b.set(0, a), x.set(0, Math.pow(b.y / g.y, n.zoomSpeed)), I(x.y), g.copy(b);
						}
						function j(t) {
							!1 !== n.enabled &&
								(0 === y.length && (n.domElement.setPointerCapture(t.pointerId), n.domElement.addEventListener("pointermove", X), n.domElement.addEventListener("pointerup", q)),
								(function (t) {
									y.push(t);
								})(t),
								"touch" === t.pointerType
									? (function (t) {
											switch (($(t), y.length)) {
												case 1:
													switch (n.touches.ONE) {
														case A:
															if (!1 === n.enableRotate) return;
															B(), (r = i.TOUCH_ROTATE);
															break;
														case L:
															if (!1 === n.enablePan) return;
															F(), (r = i.TOUCH_PAN);
															break;
														default:
															r = i.NONE;
													}
													break;
												case 2:
													switch (n.touches.TWO) {
														case R:
															if (!1 === n.enableZoom && !1 === n.enablePan) return;
															n.enableZoom && U(), n.enablePan && F(), (r = i.TOUCH_DOLLY_PAN);
															break;
														case D:
															if (!1 === n.enableZoom && !1 === n.enableRotate) return;
															n.enableZoom && U(), n.enableRotate && B(), (r = i.TOUCH_DOLLY_ROTATE);
															break;
														default:
															r = i.NONE;
													}
													break;
												default:
													r = i.NONE;
											}
											r !== i.NONE && n.dispatchEvent(df);
									  })(t)
									: (function (t) {
											let e;
											switch (t.button) {
												case 0:
													e = n.mouseButtons.LEFT;
													break;
												case 1:
													e = n.mouseButtons.MIDDLE;
													break;
												case 2:
													e = n.mouseButtons.RIGHT;
													break;
												default:
													e = -1;
											}
											switch (e) {
												case C:
													if (!1 === n.enableZoom) return;
													!(function (t) {
														g.set(t.clientX, t.clientY);
													})(t),
														(r = i.DOLLY);
													break;
												case E:
													if (t.ctrlKey || t.metaKey || t.shiftKey) {
														if (!1 === n.enablePan) return;
														V(t), (r = i.PAN);
													} else {
														if (!1 === n.enableRotate) return;
														N(t), (r = i.ROTATE);
													}
													break;
												case P:
													if (t.ctrlKey || t.metaKey || t.shiftKey) {
														if (!1 === n.enableRotate) return;
														N(t), (r = i.ROTATE);
													} else {
														if (!1 === n.enablePan) return;
														V(t), (r = i.PAN);
													}
													break;
												default:
													r = i.NONE;
											}
											r !== i.NONE && n.dispatchEvent(df);
									  })(t));
						}
						function X(t) {
							!1 !== n.enabled &&
								("touch" === t.pointerType
									? (function (t) {
											switch (($(t), r)) {
												case i.TOUCH_ROTATE:
													if (!1 === n.enableRotate) return;
													H(t), n.update();
													break;
												case i.TOUCH_PAN:
													if (!1 === n.enablePan) return;
													G(t), n.update();
													break;
												case i.TOUCH_DOLLY_PAN:
													if (!1 === n.enableZoom && !1 === n.enablePan) return;
													!(function (t) {
														n.enableZoom && W(t), n.enablePan && G(t);
													})(t),
														n.update();
													break;
												case i.TOUCH_DOLLY_ROTATE:
													if (!1 === n.enableZoom && !1 === n.enableRotate) return;
													!(function (t) {
														n.enableZoom && W(t), n.enableRotate && H(t);
													})(t),
														n.update();
													break;
												default:
													r = i.NONE;
											}
									  })(t)
									: (function (t) {
											if (!1 === n.enabled) return;
											switch (r) {
												case i.ROTATE:
													if (!1 === n.enableRotate) return;
													!(function (t) {
														d.set(t.clientX, t.clientY), p.subVectors(d, h).multiplyScalar(n.rotateSpeed);
														const e = n.domElement;
														M((2 * Math.PI * p.x) / e.clientHeight), S((2 * Math.PI * p.y) / e.clientHeight), h.copy(d), n.update();
													})(t);
													break;
												case i.DOLLY:
													if (!1 === n.enableZoom) return;
													!(function (t) {
														b.set(t.clientX, t.clientY), x.subVectors(b, g), x.y > 0 ? I(w()) : x.y < 0 && k(w()), g.copy(b), n.update();
													})(t);
													break;
												case i.PAN:
													if (!1 === n.enablePan) return;
													!(function (t) {
														m.set(t.clientX, t.clientY), v.subVectors(m, f).multiplyScalar(n.panSpeed), z(v.x, v.y), f.copy(m), n.update();
													})(t);
											}
									  })(t));
						}
						function q(t) {
							!1 !== n.enabled && (t.pointerType, n.dispatchEvent(pf), (r = i.NONE), Q(t), 0 === y.length && (n.domElement.releasePointerCapture(t.pointerId), n.domElement.removeEventListener("pointermove", X), n.domElement.removeEventListener("pointerup", q)));
						}
						function Y(t) {
							Q(t);
						}
						function Z(t) {
							!1 === n.enabled ||
								!1 === n.enableZoom ||
								(r !== i.NONE && r !== i.ROTATE) ||
								(t.preventDefault(),
								n.dispatchEvent(df),
								(function (t) {
									t.deltaY < 0 ? k(w()) : t.deltaY > 0 && I(w()), n.update();
								})(t),
								n.dispatchEvent(pf));
						}
						function K(t) {
							!1 !== n.enabled &&
								!1 !== n.enablePan &&
								(function (t) {
									let e = !1;
									switch (t.code) {
										case n.keys.UP:
											z(0, n.keyPanSpeed), (e = !0);
											break;
										case n.keys.BOTTOM:
											z(0, -n.keyPanSpeed), (e = !0);
											break;
										case n.keys.LEFT:
											z(n.keyPanSpeed, 0), (e = !0);
											break;
										case n.keys.RIGHT:
											z(-n.keyPanSpeed, 0), (e = !0);
									}
									e && (t.preventDefault(), n.update());
								})(t);
						}
						function J(t) {
							!1 !== n.enabled && t.preventDefault();
						}
						function Q(t) {
							delete _[t.pointerId];
							for (let e = 0; e < y.length; e++) if (y[e].pointerId == t.pointerId) return void y.splice(e, 1);
						}
						function $(t) {
							let e = _[t.pointerId];
							void 0 === e && ((e = new Ot()), (_[t.pointerId] = e)), e.set(t.pageX, t.pageY);
						}
						function tt(t) {
							const e = t.pointerId === y[0].pointerId ? y[1] : y[0];
							return _[e.pointerId];
						}
						n.domElement.addEventListener("contextmenu", J), n.domElement.addEventListener("pointerdown", j), n.domElement.addEventListener("pointercancel", Y), n.domElement.addEventListener("wheel", Z, { passive: !1 }), this.update();
					}
				}
				var mf = { previewSize: 256 },
					vf = { stats: !1, gui: !1, control: !1, preview: !1, renderOnControl: !1, previewParams: mf },
					gf = new ((function () {
						function t(e) {
							var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : vf;
							s(this, t), (this.params = n), e && this.init(e, n);
						}
						return (
							c(t, [
								{
									key: "init",
									value: function (t) {
										var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : vf,
											n = e.stats,
											i = e.gui,
											r = e.control,
											a = e.preview,
											s = e.renderOnControl,
											o = e.previewParams,
											l = void 0 === o ? {} : o;
										return (this.Stage = t), (this.params = { stats: n, gui: i, control: r, preview: a, renderOnControl: s }), (this.previewParams = of()(mf, l)), n && this.initStats(), i && this.initGUI(), r && this.initOrbitControl(), a && this.initPreview(this.previewParams), this;
									},
								},
								{
									key: "initStats",
									value: function () {
										(this.stats = new (cf())()), this.stats.showPanel(0), document.body.appendChild(this.stats.dom);
									},
								},
								{
									key: "initGUI",
									value: function () {
										var t = this;
										(this.gui = new uf.Pane()),
											this.gui.containerElem_.addEventListener("mouseenter", function () {
												Vc("gui:in");
											}),
											this.gui.containerElem_.addEventListener("mouseleave", function () {
												Vc("gui:out");
											}),
											document.addEventListener("keydown", function (e) {
												"KeyH" === e.code && (t.gui.hidden = !t.gui.hidden);
											});
									},
								},
								{
									key: "initOrbitControl",
									value: function () {
										var t = this,
											e = Browser.isMobile;
										(this.controls = new ff(this.Stage.camera, this.Stage.renderer.domElement)),
											(this.controls.minPolarAngle = Math.PI / 6),
											(this.controls.maxPolarAngle = Math.PI / 2.5),
											(this.controls.enableKeys = !1),
											(this.controls.enableDamping = !0),
											(this.controls.minDistance = 100),
											(this.controls.maxDistance = 400),
											(this.controls.dampingFactor = 0.03),
											(this.controls.zoomSpeed = 0.3),
											(this.controls.enableRotate = !e),
											this.controls.update(),
											this.controls.addEventListener("change", function (e) {
												Vc("orbit:change"), t.params.renderOnControl && Vc("stage:render");
											});
									},
								},
								{
									key: "initPreview",
									value: function (t) {
										var e = t.previewSize,
											n = Layout.PR;
										(this.preview = document.createElement("canvas")), (this.ctx = this.preview.getContext("2d")), (this.preview.width = e), (this.preview.height = e), (this.preview.style.position = "absolute"), (this.preview.style.left = "0px"), (this.preview.style.top = "0px"), (this.preview.style.pointerEvents = "none"), (this.preview.style.zIndex = "100"), (this.preview.style.width = e * n), (this.preview.style.height = e * n), document.body.appendChild(this.preview);
									},
								},
								{
									key: "beginStats",
									value: function () {
										this.params.stats && this.stats.begin();
									},
								},
								{
									key: "update",
									value: function () {
										this.params.control && this.controls.update();
									},
								},
								{
									key: "endStats",
									value: function () {
										this.params.stats && this.stats.end();
									},
								},
								{
									key: "previewBuffer",
									value: function (t, e) {
										var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.Stage.renderer;
										if (this.params.preview) {
											this.params.preview && !this.hasPreview && ((this.hasPreview = !0), (this.stats.dom.style.left = "".concat(this.previewParams.previewSize, "px")));
											var i = Layout,
												r = i.W,
												a = i.H,
												s = this.Stage.renderer,
												o = this.previewParams.previewSize;
											n.render(t, e);
											var l = r / a,
												c = (s.domElement.width / r) * l,
												u = s.domElement.height / a;
											this.ctx.clearRect(0, 0, o, o), this.ctx.drawImage(s.domElement, -o * c * 0.5 + 0.5 * o, -o * u + o, o * c, o * u);
										}
									},
								},
							]),
							t
						);
					})())();
				function bf(t) {
					var e = (function () {
						if ("undefined" == typeof Reflect || !m()) return !1;
						if (m().sham) return !1;
						if ("function" == typeof Proxy) return !0;
						try {
							return Boolean.prototype.valueOf.call(m()(Boolean, [], function () {})), !0;
						} catch (t) {
							return !1;
						}
					})();
					return function () {
						var n,
							i = T(t);
						if (e) {
							var r = T(this).constructor;
							n = m()(i, arguments, r);
						} else n = i.apply(this, arguments);
						return M(this, n);
					};
				}
				var xf = (function (t) {
						x(n, t);
						var e = bf(n);
						function n(t) {
							var i,
								r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : function () {};
							s(this, n);
							var a = Layout,
								o = a.W,
								l = a.H,
								c = a.PR;
							return ((i = e.call(this, { canvas: t, antialias: !1, powerPreference: "high-performance" })).isPaused = !1), (i.isTimeBending = !1), (i.$canvas = t), i.setClearColor(af.BGALT), i.setSize(o, l), i.setPixelRatio(c), (i.loopHandler = r), i.bindEvents(), i;
						}
						return (
							c(n, [
								{
									key: "bindEvents",
									value: function () {
										var t = this;
										document.addEventListener("layout:change", function () {
											return t.onResize();
										}),
											document.addEventListener("keydown", function (e) {
												return t.onKeydown(e);
											}),
											document.addEventListener("visibilitychange", function () {
												return t.onPageVisibilityChange();
											});
									},
								},
								{
									key: "onPageVisibilityChange",
									value: function () {
										var t = "hidden" === document.visibilityState;
										this.togglePause(t);
									},
								},
								{
									key: "onResize",
									value: function () {
										var t = Layout,
											e = t.W,
											n = t.H;
										this.setSize(e, n);
									},
								},
								{
									key: "onKeydown",
									value: function (t) {
										var e = t.code;
										("KeyP" !== e && "Space" !== e) || ("Space" === e ? this.bendTime() : this.togglePause());
									},
								},
								{
									key: "toggleRender",
									value: function (t) {
										var e = t ? this.loopHandler : null;
										this.setAnimationLoop(e);
									},
								},
								{
									key: "togglePause",
									value: function () {
										var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : !this.isPaused;
										t !== this.isPaused && ((this.isPaused = !this.isPaused), Vc("renderer:paused", { isPaused: this.isPaused }));
									},
								},
								{
									key: "bendTime",
									value: function () {
										var t = this,
											e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : !this.isTimeBending;
										e !== this.isTimeBending &&
											((this.isTimeBending = e),
											tf.to(af.timeScale.uniform, {
												value: e && af.timeScale.uniform.value > 0 ? 0 : 1,
												ease: e && af.timeScale.uniform.value > 0 ? "power2.out" : "power2.in",
												duration: 1.2,
												overwrite: !0,
												onUpdate: function () {
													gf.gui.refresh();
												},
												onStart: function () {
													e || t.togglePause(e);
												},
												onComplete: function () {
													e && t.togglePause(e);
												},
											}));
									},
								},
							]),
							n
						);
					})(es),
					yf = n(2991),
					_f = n.n(yf),
					wf = n(3798),
					Mf = n.n(wf);
				const Sf = JSON.parse(
					'[["#69d2e7","#a7dbd8","#e0e4cc","#f38630","#fa6900"],["#fe4365","#fc9d9a","#f9cdad","#c8c8a9","#83af9b"],["#ecd078","#d95b43","#c02942","#542437","#53777a"],["#556270","#4ecdc4","#c7f464","#ff6b6b","#c44d58"],["#774f38","#e08e79","#f1d4af","#ece5ce","#c5e0dc"],["#e8ddcb","#cdb380","#036564","#033649","#031634"],["#490a3d","#bd1550","#e97f02","#f8ca00","#8a9b0f"],["#594f4f","#547980","#45ada8","#9de0ad","#e5fcc2"],["#00a0b0","#6a4a3c","#cc333f","#eb6841","#edc951"],["#e94e77","#d68189","#c6a49a","#c6e5d9","#f4ead5"],["#3fb8af","#7fc7af","#dad8a7","#ff9e9d","#ff3d7f"],["#d9ceb2","#948c75","#d5ded9","#7a6a53","#99b2b7"],["#ffffff","#cbe86b","#f2e9e1","#1c140d","#cbe86b"],["#efffcd","#dce9be","#555152","#2e2633","#99173c"],["#343838","#005f6b","#008c9e","#00b4cc","#00dffc"],["#413e4a","#73626e","#b38184","#f0b49e","#f7e4be"],["#ff4e50","#fc913a","#f9d423","#ede574","#e1f5c4"],["#99b898","#fecea8","#ff847c","#e84a5f","#2a363b"],["#655643","#80bca3","#f6f7bd","#e6ac27","#bf4d28"],["#00a8c6","#40c0cb","#f9f2e7","#aee239","#8fbe00"],["#351330","#424254","#64908a","#e8caa4","#cc2a41"],["#554236","#f77825","#d3ce3d","#f1efa5","#60b99a"],["#5d4157","#838689","#a8caba","#cad7b2","#ebe3aa"],["#8c2318","#5e8c6a","#88a65e","#bfb35a","#f2c45a"],["#fad089","#ff9c5b","#f5634a","#ed303c","#3b8183"],["#ff4242","#f4fad2","#d4ee5e","#e1edb9","#f0f2eb"],["#f8b195","#f67280","#c06c84","#6c5b7b","#355c7d"],["#d1e751","#ffffff","#000000","#4dbce9","#26ade4"],["#1b676b","#519548","#88c425","#bef202","#eafde6"],["#5e412f","#fcebb6","#78c0a8","#f07818","#f0a830"],["#bcbdac","#cfbe27","#f27435","#f02475","#3b2d38"],["#452632","#91204d","#e4844a","#e8bf56","#e2f7ce"],["#eee6ab","#c5bc8e","#696758","#45484b","#36393b"],["#f0d8a8","#3d1c00","#86b8b1","#f2d694","#fa2a00"],["#2a044a","#0b2e59","#0d6759","#7ab317","#a0c55f"],["#f04155","#ff823a","#f2f26f","#fff7bd","#95cfb7"],["#b9d7d9","#668284","#2a2829","#493736","#7b3b3b"],["#bbbb88","#ccc68d","#eedd99","#eec290","#eeaa88"],["#b3cc57","#ecf081","#ffbe40","#ef746f","#ab3e5b"],["#a3a948","#edb92e","#f85931","#ce1836","#009989"],["#300030","#480048","#601848","#c04848","#f07241"],["#67917a","#170409","#b8af03","#ccbf82","#e33258"],["#aab3ab","#c4cbb7","#ebefc9","#eee0b7","#e8caaf"],["#e8d5b7","#0e2430","#fc3a51","#f5b349","#e8d5b9"],["#ab526b","#bca297","#c5ceae","#f0e2a4","#f4ebc3"],["#607848","#789048","#c0d860","#f0f0d8","#604848"],["#b6d8c0","#c8d9bf","#dadabd","#ecdbbc","#fedcba"],["#a8e6ce","#dcedc2","#ffd3b5","#ffaaa6","#ff8c94"],["#3e4147","#fffedf","#dfba69","#5a2e2e","#2a2c31"],["#fc354c","#29221f","#13747d","#0abfbc","#fcf7c5"],["#cc0c39","#e6781e","#c8cf02","#f8fcc1","#1693a7"],["#1c2130","#028f76","#b3e099","#ffeaad","#d14334"],["#a7c5bd","#e5ddcb","#eb7b59","#cf4647","#524656"],["#dad6ca","#1bb0ce","#4f8699","#6a5e72","#563444"],["#5c323e","#a82743","#e15e32","#c0d23e","#e5f04c"],["#edebe6","#d6e1c7","#94c7b6","#403b33","#d3643b"],["#fdf1cc","#c6d6b8","#987f69","#e3ad40","#fcd036"],["#230f2b","#f21d41","#ebebbc","#bce3c5","#82b3ae"],["#b9d3b0","#81bda4","#b28774","#f88f79","#f6aa93"],["#3a111c","#574951","#83988e","#bcdea5","#e6f9bc"],["#5e3929","#cd8c52","#b7d1a3","#dee8be","#fcf7d3"],["#1c0113","#6b0103","#a30006","#c21a01","#f03c02"],["#000000","#9f111b","#b11623","#292c37","#cccccc"],["#382f32","#ffeaf2","#fcd9e5","#fbc5d8","#f1396d"],["#e3dfba","#c8d6bf","#93ccc6","#6cbdb5","#1a1f1e"],["#f6f6f6","#e8e8e8","#333333","#990100","#b90504"],["#1b325f","#9cc4e4","#e9f2f9","#3a89c9","#f26c4f"],["#a1dbb2","#fee5ad","#faca66","#f7a541","#f45d4c"],["#c1b398","#605951","#fbeec2","#61a6ab","#accec0"],["#5e9fa3","#dcd1b4","#fab87f","#f87e7b","#b05574"],["#951f2b","#f5f4d7","#e0dfb1","#a5a36c","#535233"],["#8dccad","#988864","#fea6a2","#f9d6ac","#ffe9af"],["#2d2d29","#215a6d","#3ca2a2","#92c7a3","#dfece6"],["#413d3d","#040004","#c8ff00","#fa023c","#4b000f"],["#eff3cd","#b2d5ba","#61ada0","#248f8d","#605063"],["#ffefd3","#fffee4","#d0ecea","#9fd6d2","#8b7a5e"],["#cfffdd","#b4dec1","#5c5863","#a85163","#ff1f4c"],["#9dc9ac","#fffec7","#f56218","#ff9d2e","#919167"],["#4e395d","#827085","#8ebe94","#ccfc8e","#dc5b3e"],["#a8a7a7","#cc527a","#e8175d","#474747","#363636"],["#f8edd1","#d88a8a","#474843","#9d9d93","#c5cfc6"],["#046d8b","#309292","#2fb8ac","#93a42a","#ecbe13"],["#f38a8a","#55443d","#a0cab5","#cde9ca","#f1edd0"],["#a70267","#f10c49","#fb6b41","#f6d86b","#339194"],["#ff003c","#ff8a00","#fabe28","#88c100","#00c176"],["#ffedbf","#f7803c","#f54828","#2e0d23","#f8e4c1"],["#4e4d4a","#353432","#94ba65","#2790b0","#2b4e72"],["#0ca5b0","#4e3f30","#fefeeb","#f8f4e4","#a5b3aa"],["#4d3b3b","#de6262","#ffb88c","#ffd0b3","#f5e0d3"],["#fffbb7","#a6f6af","#66b6ab","#5b7c8d","#4f2958"],["#edf6ee","#d1c089","#b3204d","#412e28","#151101"],["#9d7e79","#ccac95","#9a947c","#748b83","#5b756c"],["#fcfef5","#e9ffe1","#cdcfb7","#d6e6c3","#fafbe3"],["#9cddc8","#bfd8ad","#ddd9ab","#f7af63","#633d2e"],["#30261c","#403831","#36544f","#1f5f61","#0b8185"],["#aaff00","#ffaa00","#ff00aa","#aa00ff","#00aaff"],["#d1313d","#e5625c","#f9bf76","#8eb2c5","#615375"],["#ffe181","#eee9e5","#fad3b2","#ffba7f","#ff9c97"],["#73c8a9","#dee1b6","#e1b866","#bd5532","#373b44"],["#805841","#dcf7f3","#fffcdd","#ffd8d8","#f5a2a2"],["#379f7a","#78ae62","#bbb749","#e0fbac","#1f1c0d"],["#caff42","#ebf7f8","#d0e0eb","#88abc2","#49708a"],["#c2412d","#d1aa34","#a7a844","#a46583","#5a1e4a"],["#75616b","#bfcff7","#dce4f7","#f8f3bf","#d34017"],["#111625","#341931","#571b3c","#7a1e48","#9d2053"],["#82837e","#94b053","#bdeb07","#bffa37","#e0e0e0"],["#7e5686","#a5aad9","#e8f9a2","#f8a13f","#ba3c3d"],["#312736","#d4838f","#d6abb1","#d9d9d9","#c4ffeb"],["#395a4f","#432330","#853c43","#f25c5e","#ffa566"],["#fde6bd","#a1c5ab","#f4dd51","#d11e48","#632f53"],["#84b295","#eccf8d","#bb8138","#ac2005","#2c1507"],["#058789","#503d2e","#d54b1a","#e3a72f","#f0ecc9"],["#6da67a","#77b885","#86c28b","#859987","#4a4857"],["#bed6c7","#adc0b4","#8a7e66","#a79b83","#bbb2a1"],["#261c21","#6e1e62","#b0254f","#de4126","#eb9605"],["#efd9b4","#d6a692","#a39081","#4d6160","#292522"],["#e21b5a","#9e0c39","#333333","#fbffe3","#83a300"],["#f2e3c6","#ffc6a5","#e6324b","#2b2b2b","#353634"],["#c75233","#c78933","#d6ceaa","#79b5ac","#5e2f46"],["#793a57","#4d3339","#8c873e","#d1c5a5","#a38a5f"],["#512b52","#635274","#7bb0a8","#a7dbab","#e4f5b1"],["#11644d","#a0b046","#f2c94e","#f78145","#f24e4e"],["#59b390","#f0ddaa","#e47c5d","#e32d40","#152b3c"],["#fdffd9","#fff0b8","#ffd6a3","#faad8e","#142f30"],["#b5ac01","#ecba09","#e86e1c","#d41e45","#1b1521"],["#c7fcd7","#d9d5a7","#d9ab91","#e6867a","#ed4a6a"],["#11766d","#410936","#a40b54","#e46f0a","#f0b300"],["#595643","#4e6b66","#ed834e","#ebcc6e","#ebe1c5"],["#f1396d","#fd6081","#f3ffeb","#acc95f","#8f9924"],["#331327","#991766","#d90f5a","#f34739","#ff6e27"],["#efeecc","#fe8b05","#fe0557","#400403","#0aabba"],["#bf496a","#b39c82","#b8c99d","#f0d399","#595151"],["#b7cbbf","#8c886f","#f9a799","#f4bfad","#f5dabd"],["#ffb884","#f5df98","#fff8d4","#c0d1c2","#2e4347"],["#e5eaa4","#a8c4a2","#69a5a4","#616382","#66245b"],["#e0eff1","#7db4b5","#ffffff","#680148","#000000"],["#b1e6d1","#77b1a9","#3d7b80","#270a33","#451a3e"],["#e4ded0","#abccbd","#7dbeb8","#181619","#e32f21"],["#e9e0d1","#91a398","#33605a","#070001","#68462b"],["#fc284f","#ff824a","#fea887","#f6e7f7","#d1d0d7"],["#ffab07","#e9d558","#72ad75","#0e8d94","#434d53"],["#6da67a","#99a66d","#a9bd68","#b5cc6a","#c0de5d"],["#311d39","#67434f","#9b8e7e","#c3ccaf","#a51a41"],["#cfb590","#9e9a41","#758918","#564334","#49281f"],["#5cacc4","#8cd19d","#cee879","#fcb653","#ff5254"],["#44749d","#c6d4e1","#ffffff","#ebe7e0","#bdb8ad"],["#807462","#a69785","#b8faff","#e8fdff","#665c49"],["#e7edea","#ffc52c","#fb0c06","#030d4f","#ceecef"],["#ccf390","#e0e05a","#f7c41f","#fc930a","#ff003d"],["#2b222c","#5e4352","#965d62","#c7956d","#f2d974"],["#cc5d4c","#fffec6","#c7d1af","#96b49c","#5b5847"],["#e4e4c5","#b9d48b","#8d2036","#ce0a31","#d3e4c5"],["#e3e8cd","#bcd8bf","#d3b9a3","#ee9c92","#fe857e"],["#360745","#d61c59","#e7d84b","#efeac5","#1b8798"],["#ec4401","#cc9b25","#13cd4a","#7b6ed6","#5e525c"],["#eb9c4d","#f2d680","#f3ffcf","#bac9a9","#697060"],["#f2e8c4","#98d9b6","#3ec9a7","#2b879e","#616668"],["#f5dd9d","#bcc499","#92a68a","#7b8f8a","#506266"],["#fff3db","#e7e4d5","#d3c8b4","#c84648","#703e3b"],["#041122","#259073","#7fda89","#c8e98e","#e6f99d"],["#8d7966","#a8a39d","#d8c8b8","#e2ddd9","#f8f1e9"],["#c6cca5","#8ab8a8","#6b9997","#54787d","#615145"],["#1d1313","#24b694","#d22042","#a3b808","#30c4c9"],["#4b1139","#3b4058","#2a6e78","#7a907c","#c9b180"],["#2d1b33","#f36a71","#ee887a","#e4e391","#9abc8a"],["#f0ffc9","#a9da88","#62997a","#72243d","#3b0819"],["#429398","#6b5d4d","#b0a18f","#dfcdb4","#fbeed3"],["#9d9e94","#c99e93","#f59d92","#e5b8ad","#d5d2c8"],["#95a131","#c8cd3b","#f6f1de","#f5b9ae","#ee0b5b"],["#322938","#89a194","#cfc89a","#cc883a","#a14016"],["#540045","#c60052","#ff714b","#eaff87","#acffe9"],["#79254a","#795c64","#79927d","#aeb18e","#e3cf9e"],["#452e3c","#ff3d5a","#ffb969","#eaf27e","#3b8c88"],["#2b2726","#0a516d","#018790","#7dad93","#bacca4"],["#027b7f","#ffa588","#d62957","#bf1e62","#572e4f"],["#fa6a64","#7a4e48","#4a4031","#f6e2bb","#9ec6b8"],["#fb6900","#f63700","#004853","#007e80","#00b9bd"],["#f06d61","#da825f","#c4975c","#a8ab7b","#8cbf99"],["#23192d","#fd0a54","#f57576","#febf97","#f5ecb7"],["#f6d76b","#ff9036","#d6254d","#ff5475","#fdeba9"],["#a3c68c","#879676","#6e6662","#4f364a","#340735"],["#a32c28","#1c090b","#384030","#7b8055","#bca875"],["#80a8a8","#909d9e","#a88c8c","#ff0d51","#7a8c89"],["#6d9788","#1e2528","#7e1c13","#bf0a0d","#e6e1c2"],["#373737","#8db986","#acce91","#badb73","#efeae4"],["#e6b39a","#e6cba5","#ede3b4","#8b9e9b","#6d7578"],["#280904","#680e34","#9a151a","#c21b12","#fc4b2a"],["#4b3e4d","#1e8c93","#dbd8a2","#c4ac30","#d74f33"],["#161616","#c94d65","#e7c049","#92b35a","#1f6764"],["#234d20","#36802d","#77ab59","#c9df8a","#f0f7da"],["#a69e80","#e0ba9b","#e7a97e","#d28574","#3b1922"],["#641f5e","#676077","#65ac92","#c2c092","#edd48e"],["#e6eba9","#abbb9f","#6f8b94","#706482","#703d6f"],["#26251c","#eb0a44","#f2643d","#f2a73d","#a0e8b7"],["#fdcfbf","#feb89f","#e23d75","#5f0d3b","#742365"],["#ff7474","#f59b71","#c7c77f","#e0e0a8","#f1f1c1"],["#4f364c","#5e405f","#6b6b6b","#8f9e6f","#b1cf72"],["#230b00","#a29d7f","#d4cfa5","#f8ecd4","#aabe9b"],["#d4f7dc","#dbe7b4","#dbc092","#e0846d","#f51441"],["#62a07b","#4f8b89","#536c8d","#5c4f79","#613860"],["#6f5846","#a95a52","#e35b5d","#f18052","#ffa446"],["#85847e","#ab6a6e","#f7345b","#353130","#cbcfb4"],["#ff3366","#c74066","#8f4d65","#575a65","#1f6764"],["#d3d5b0","#b5cea4","#9dc19d","#8c7c62","#71443f"],["#ffff99","#d9cc8c","#b39980","#8c6673","#663366"],["#ed6464","#bf6370","#87586c","#574759","#1a1b1c"],["#d24858","#ea8676","#eab05e","#fdeecd","#493831"],["#f0f0d8","#b4debe","#77cca4","#666666","#b4df37"],["#f3e7d7","#f7d7cd","#f8c7c9","#e0c0c7","#c7b9c5"],["#ccb24c","#f7d683","#fffdc0","#fffffd","#457d97"],["#1a081f","#4d1d4d","#05676e","#489c79","#ebc288"],["#c46564","#f0e999","#b8c99d","#9b726f","#eeb15b"],["#7a5b3e","#fafafa","#fa4b00","#cdbdae","#1f1f1f"],["#eeda95","#b7c27e","#9a927b","#8a6a6b","#805566"],["#d31900","#ff6600","#fff2af","#7cb490","#000000"],["#e8c382","#b39d69","#a86b4c","#7d1a0c","#340a0b"],["#ebeaa9","#ebc588","#7d2948","#3b0032","#0e0b29"],["#566965","#948a71","#cc9476","#f2a176","#ff7373"],["#595b5a","#14c3a2","#0de5a8","#7cf49a","#b8fd99"],["#063940","#195e63","#3e838c","#8ebdb6","#ece1c3"],["#411f2d","#ac4147","#f88863","#ffc27f","#ffe29a"],["#9dbcbc","#f0f0af","#ff370f","#332717","#6bacbf"],["#e7e79d","#c0d890","#78a890","#606078","#d8a878"],["#94654c","#f89fa1","#fabdbd","#fad6d6","#fefcd0"],["#cddbc2","#f7e4c6","#fb9274","#f5565b","#875346"],["#f0ddbd","#ba3622","#851e25","#520c30","#1c997f"],["#312c20","#494d4b","#7c7052","#b3a176","#e2cb92"],["#029daf","#e5d599","#ffc219","#f07c19","#e32551"],["#3f2c26","#dd423e","#a2a384","#eac388","#c5ad4b"],["#0a0310","#49007e","#ff005b","#ff7d10","#ffb238"],["#ecbe13","#738c79","#6a6b5f","#2c2b26","#a43955"],["#fff5de","#b8d9c8","#917081","#750e49","#4d002b"],["#1f1f20","#2b4c7e","#567ebb","#606d80","#dce0e6"],["#e7dd96","#e16639","#ad860a","#b7023f","#55024a"],["#cdeccc","#edd269","#e88460","#f23460","#321d2e"],["#574c41","#e36b6b","#e3a56b","#e3c77b","#96875a"],["#dde0cf","#c6be9a","#ad8b32","#937460","#8c5b7b"],["#213435","#46685b","#648a64","#a6b985","#e1e3ac"],["#181419","#4a073c","#9e0b41","#cc3e18","#f0971c"],["#413040","#6c6368","#b9a173","#eaa353","#ffefa9"],["#4d3b36","#eb613b","#f98f6f","#c1d9cd","#f7eadc"],["#ffcdb8","#fdeecf","#c8c696","#97bea9","#37260c"],["#e8d3a9","#e39b7d","#6e6460","#89b399","#bcbfa3"],["#ffffff","#fffaeb","#f0f0d8","#cfcfcf","#967c52"],["#001449","#012677","#005bc5","#00b4fc","#17f9ff"],["#ed5672","#160e32","#9eae8a","#cdbb93","#fbc599"],["#130912","#3e1c33","#602749","#b14623","#f6921d"],["#ffff00","#ccd91a","#99b333","#668c4d","#336666"],["#4dab8c","#542638","#8f244d","#c9306b","#e86f9e"],["#2b1719","#02483e","#057c46","#9bb61b","#f8be00"],["#ffabab","#ffdaab","#ddffab","#abe4ff","#d9abff"],["#e6a06f","#9e9c71","#5e8271","#33454e","#242739"],["#67be9b","#95d0b8","#fcfcd7","#f1db42","#f04158"],["#1693a5","#45b5c4","#7ececa","#a0ded6","#c7ede8"],["#cc2649","#992c4b","#66324c","#33384e","#003e4f"],["#e7eed0","#cad1c3","#948e99","#51425f","#2e1437"],["#785d56","#be4c54","#c6b299","#e6d5c1","#fff4e3"],["#f7f3d5","#ffdabf","#fa9b9b","#e88087","#635063"],["#e25858","#e9d6af","#ffffdd","#c0efd2","#384252"],["#acdeb2","#e1eab5","#edad9e","#fe4b74","#390d2d"],["#42282c","#6ca19e","#84abaa","#ded1b6","#6d997a"],["#a7cd2c","#bada5f","#cee891","#e1f5c4","#50c8c6"],["#b2cba3","#e0df9f","#e7a83e","#9a736e","#ea525f"],["#fc580c","#fc6b0a","#f8872e","#ffa927","#fdca49"],["#fdffd9","#73185e","#36bba6","#0c0d02","#8b911a"],["#9f0a28","#d55c2b","#f6e7d3","#89a46f","#55203c"],["#8a8780","#e6e5c4","#d6d1af","#e47267","#d7d8c5"],["#418e8e","#5a4e3c","#c4d428","#d8e472","#e9ebbf"],["#a69a90","#4a403d","#fff1c1","#facf7d","#ea804c"],["#faf6d0","#c7d8ab","#909a92","#744f78","#30091e"],["#aadead","#bbdead","#ccdead","#dddead","#eedead"],["#f0371a","#000000","#f7e6a6","#3e6b48","#b5b479"],["#a7321c","#ffdc68","#cc982a","#928941","#352504"],["#fa2e59","#ff703f","#f7bc05","#ecf6bb","#76bcad"],["#f1e8b4","#b2bb91","#d7bf5e","#d16344","#83555e"],["#afc7b9","#ffe1c9","#fac7b4","#fca89d","#998b82"],["#f6c7b7","#f7a398","#fa7f77","#b42529","#000000"],["#c9d1d3","#f7f7f7","#9dd3df","#3b3737","#991818"],["#000000","#001f36","#1c5560","#79ae92","#fbffcd"],["#e0dc8b","#f6aa3d","#ed4c57","#574435","#6cc4b9"],["#42393b","#75c9a3","#bac99a","#ffc897","#f7efa2"],["#f4f4f4","#9ba657","#f0e5c9","#a68c69","#594433"],["#f2cc67","#f38264","#f40034","#5f051f","#75baa8"],["#fbfee5","#c91842","#98173d","#25232d","#a8e7ca"],["#dbd9b7","#c1c9c8","#a5b5ab","#949a8e","#615566"],["#f3e6bc","#f1c972","#f5886b","#72ae95","#5a3226"],["#674f23","#e48b69","#e1b365","#e5db84","#ffeeac"],["#ff0092","#ffca1b","#b6ff00","#228dff","#ba01ff"],["#d9d4a8","#d15c57","#cc3747","#5c374b","#4a5f67"],["#998496","#f7e0ae","#fa748f","#2d2c26","#c3b457"],["#fa8cb1","#fdc5c9","#fffee1","#cfb699","#9e6d4e"],["#84c1b1","#ad849a","#d64783","#fd135a","#40202a"],["#00ccbe","#09a6a3","#9dbfaf","#edebc9","#fcf9d8"],["#020304","#541f14","#938172","#cc9e61","#626266"],["#71dbd2","#eeffdb","#ade4b5","#d0eaa3","#fff18c"],["#b88000","#d56f00","#f15500","#ff2654","#ff0c71"],["#bf2a23","#a6ad3c","#f0ce4e","#cf872e","#8a211d"],["#ffc870","#f7f7c6","#c8e3c5","#9cad9a","#755858"],["#002c2b","#ff3d00","#ffbc11","#0a837f","#076461"],["#244242","#51bd9c","#a3e3b1","#ffe8b3","#ff2121"],["#4eb3de","#8de0a6","#fcf09f","#f27c7c","#de528c"],["#001848","#301860","#483078","#604878","#906090"],["#1f0310","#442433","#a3d95b","#aae3ab","#f6f0bc"],["#b31237","#f03813","#ff8826","#ffb914","#2c9fa3"],["#fffdc0","#b9d7a1","#fead26","#ca221f","#590f0c"],["#4c3d31","#f18273","#f2bd76","#f4f5de","#c4ceb0"],["#84bfc3","#fff5d6","#ffb870","#d96153","#000511"],["#e2df9a","#ebe54d","#757449","#4b490b","#ff0051"],["#b2b39f","#c8c9b5","#dedfc5","#f5f7bd","#3d423c"],["#2f2bad","#ad2bad","#e42692","#f71568","#f7db15"],["#651366","#a71a5b","#e7204e","#f76e2a","#f0c505"],["#241811","#d4a979","#e3c88f","#c2c995","#a8bd95"],["#2197a3","#f71e6c","#f07868","#ebb970","#e7d3b0"],["#85a29e","#ffebbf","#f0d442","#f59330","#b22148"],["#15212a","#99c9bd","#d7b89c","#feab8d","#f4c9a3"],["#fe6c2b","#d43b2d","#9f102c","#340016","#020001"],["#f88f89","#eec276","#fbf6d0","#79c3aa","#1f0e1a"],["#ffffff","#a1c1be","#59554e","#f3f4e5","#e2e3d9"],["#ccded2","#fffbd4","#f5ddbb","#e3b8b2","#a18093"],["#79a687","#718063","#67594d","#4f2b38","#1d1016"],["#45aab8","#e1d772","#faf4b1","#394240","#f06b50"],["#e6e1cd","#c6d8c0","#d6b3b1","#f97992","#231b42"],["#69d0b3","#9bdab3","#b4dfb3","#cde4b3","#d9cf85"],["#332c26","#db1414","#e8591c","#7fb8b0","#c5e65c"],["#75372d","#928854","#96a782","#d4ce9e","#d8523d"],["#d1b68d","#87555c","#492d49","#51445f","#5a5c75"],["#8e407a","#fe6962","#f9ba84","#eee097","#ffffe5"],["#ffe4aa","#fca699","#e2869b","#c9729f","#583b7e"],["#9e1e4c","#ff1168","#25020f","#8f8f8f","#ececec"],["#272d4d","#b83564","#ff6a5a","#ffb350","#83b8aa"],["#b5f4bc","#fff19e","#ffdc8a","#ffba6b","#ff6543"],["#539fa2","#72b1a4","#abccb1","#c4dbb4","#d4e2b6"],["#80d3bb","#bafdc2","#e5f3ba","#5c493d","#3a352f"],["#5adb94","#0ba18c","#368986","#8a034d","#2e0331"],["#101942","#80043a","#f60c49","#f09580","#fdf2b4"],["#c9b849","#c96823","#be3100","#6f0b00","#241714"],["#ff4746","#e8da5e","#92b55f","#487d76","#4b4452"],["#a8bcbd","#fcdcb3","#f88d87","#d65981","#823772"],["#002e34","#004443","#00755c","#00c16c","#90ff17"],["#1f0a1d","#334f53","#45936c","#9acc77","#e5ead4"],["#444444","#fcf7d1","#a9a17a","#b52c00","#8c0005"],["#0fc3e8","#0194be","#e2d397","#f07e13","#481800"],["#d8d8d8","#e2d9d8","#ecdad8","#f5dbd8","#ffdcd8"],["#4b538b","#15191d","#f7a21b","#e45635","#d60257"],["#c4ddd6","#d4ddd6","#e4ddd6","#e4e3cd","#ececdd"],["#4d4a4b","#f60069","#ff41a1","#ff90ab","#ffccd1"],["#899aa1","#bda2a2","#fbbe9a","#fad889","#faf5c8"],["#000000","#ff8830","#d1b8a0","#aeced2","#cbdcdf"],["#36173d","#ff4845","#ff745f","#ffc55f","#ffec5e"],["#f8f8ec","#aedd2b","#066699","#0a5483","#02416d"],["#184848","#006060","#007878","#a8c030","#f0f0d8"],["#706767","#e87474","#e6a37a","#d9c777","#c0dbab"],["#dacdbd","#f2b8a0","#ef97a3","#df5c7e","#d4486f"],["#170132","#361542","#573e54","#85ae72","#bce1ab"],["#e9dfcc","#f3a36b","#cd5b51","#554865","#352630"],["#db5643","#1c0f0e","#70aa87","#9fb38f","#c5bd99"],["#c8d197","#d89845","#c54b2c","#473430","#11baac"],["#aab69b","#9e906e","#9684a3","#8870ff","#000000"],["#000706","#00272d","#134647","#0c7e7e","#bfac8b"],["#f1ecdf","#d4c9ad","#c7ba99","#000000","#f58723"],["#565175","#538a95","#67b79e","#ffb727","#e4491c"],["#fcfdeb","#e3cebd","#c1a2a0","#725b75","#322030"],["#d7e8d5","#e6f0af","#e8ed76","#ffcd57","#4a3a47"],["#288d85","#b9d9b4","#d18e8f","#b05574","#f0a991"],["#260729","#2a2344","#495168","#ccbd9e","#d8ccb2"],["#aef055","#e0ffc3","#25e4bc","#3f8978","#514442"],["#affbff","#d2fdfe","#fefac2","#febf97","#fe6960"],["#f7f799","#e0d124","#f0823f","#bd374c","#443a37"],["#dbda97","#efae54","#ef6771","#4b1d37","#977e77"],["#c8ce13","#f8f5c1","#349e97","#2c0d1a","#de1a72"],["#b9113f","#a8636e","#97b59d","#cfcca8","#ffe3b3"],["#ed7b83","#ec8a90","#eba2a4","#e6d1ca","#eee9c7"],["#002930","#ffffff","#f8f0af","#ac4a00","#000000"],["#913f33","#ff705f","#ffaa67","#ffdfab","#9fb9c2"],["#edeccf","#f1c694","#dc6378","#207178","#101652"],["#fee9a6","#fec0ab","#fa5894","#660860","#9380b7"],["#d3c8b4","#d4f1db","#eecab1","#fe6c63","#240910"],["#edd58f","#c2bf92","#66ac92","#686077","#641f5e"],["#e04891","#e1b7ed","#f5e1e2","#d1e389","#b9de51"],["#43777a","#442432","#c02948","#d95b45","#ecd079"],["#4180ab","#ffffff","#8ab3cf","#bdd1de","#e4ebf0"],["#f9d423","#ede574","#e1f5c4","#add6bc","#79b7b4"],["#f4f8e6","#f2e9e6","#4a3d3d","#ff6161","#d8dec3"],["#f9f6ec","#88a1a8","#502940","#790614","#0d0c0c"],["#ffab03","#fc7f03","#fc3903","#d1024e","#a6026c"],["#50232e","#f77c3e","#faba66","#fce185","#a2cca5"],["#f9ebf2","#f3e2e8","#fcd7da","#f58f9a","#3c363b"],["#ffffff","#a1ac88","#757575","#464d70","#000000"],["#736558","#fd65a0","#fef5c6","#aaf2e4","#31d5de"],["#f7f6e4","#e2d5c1","#5f3711","#f6f6e2","#d4c098"],["#95de90","#cef781","#f7c081","#ff7857","#6b6b6b"],["#f2502c","#cad17a","#fcf59b","#91c494","#c42311"],["#b2d9f7","#487aa1","#3d3c3b","#7c8071","#dde3ca"],["#f7dece","#eed7c5","#ccccbb","#9ec4bb","#2d2e2c"],["#e3ba6a","#bfa374","#6d756a","#4d686f","#364461"],["#686466","#839cb5","#96d7eb","#b1e1e9","#f2e4f9"],["#f7f1e1","#ffdbd7","#ffb2c1","#ce7095","#855e6e"],["#2e1e45","#612a52","#ba3259","#ff695c","#ccbca1"],["#8dc9b5","#f6f4c2","#ffc391","#ff695c","#8c315d"],["#0db2ac","#f5dd7e","#fc8d4d","#fc694d","#faba32"],["#fffab3","#a2e5d2","#63b397","#9dab34","#2c2321"],["#ebf2f2","#d0f2e7","#bcebdf","#ade0db","#d9dbdb"],["#e4e6c3","#88baa3","#ba1e4a","#63203d","#361f2d"],["#204b5e","#426b65","#baab6a","#fbea80","#fdfac7"],["#dadad8","#fe6196","#ff2c69","#1ea49d","#cbe65b"],["#910142","#6c043c","#210123","#fef7d5","#0ec0c1"],["#ab505e","#d9a071","#cfc88f","#a5b090","#607873"],["#43204a","#7f1e47","#422343","#c22047","#ea284b"],["#482c21","#a73e2b","#d07e0e","#e9deb0","#2f615e"],["#042608","#2a5c0b","#808f12","#faedd9","#ea2a15"],["#ff275e","#e6bc56","#7f440a","#6a9277","#f8d9bd"],["#3f324d","#93c2b1","#ffeacc","#ff995e","#de1d6a"],["#ffc2ce","#80b3ff","#fd6e8a","#a2122f","#693726"],["#f3d915","#e9e4bb","#bfd4b7","#a89907","#1a1c27"],["#9c8680","#eb5e7f","#f98f6f","#dbbf6b","#c8eb6a"],["#917f6e","#efbc98","#efd2be","#efe1d1","#d9ddcd"],["#c72546","#66424c","#768a4f","#b3c262","#d5ca98"],["#e6e8e3","#d7dacf","#bec3bc","#8f9a9c","#65727a"],["#2f3559","#9a5071","#e394a7","#f1bbbb","#e6d8cb"],["#63594d","#b18272","#c2b291","#d6e4c3","#eae3d1"],["#e8de92","#810e0b","#febea3","#fce5b1","#f6f5da"],["#f8f69f","#bab986","#7c7b6c","#3e3e53","#000039"],["#c3dfd7","#c8dfd2","#cddfcd","#d2dfc8","#d7dfc3"],["#172c3c","#274862","#995052","#d96831","#e6b33d"],["#678d6c","#fc7d23","#fa3c08","#bd0a41","#772a53"],["#dae2cb","#96c3a6","#6cb6a5","#221d34","#90425c"],["#8c0e48","#80ab99","#e8dbad","#b39e58","#99822d"],["#dbf73b","#c0cc39","#eb0258","#a6033f","#2b2628"],["#f1ebeb","#eee8e8","#cacaca","#24c0eb","#5cceee"],["#454545","#743455","#a22365","#d11174","#ff0084"],["#796c86","#74aa9b","#91c68d","#ece488","#f6f5cd"],["#7375a5","#21a3a3","#13c8b5","#6cf3d5","#2b364a"],["#efac41","#de8531","#b32900","#6c1305","#330a04"],["#fffbf0","#968f4b","#7a6248","#ab9597","#030506"],["#31827c","#95c68f","#f7e9aa","#fc8a80","#fd4e6d"],["#615050","#776a6a","#ad9a6f","#f5f1e8","#fcfcfc"],["#f26b7a","#f0f2dc","#d9eb52","#8ac7de","#87796f"],["#b877a8","#b8008a","#ff3366","#ffcc33","#ccff33"],["#b9340b","#cea45c","#c5be8b","#498379","#3f261c"],["#f4e196","#a6bf91","#5f9982","#78576b","#400428"],["#72bca5","#f4ddb4","#f1ae2b","#bc0b27","#4a2512"],["#ddcaa2","#aebea3","#b97479","#d83957","#4e5c69"],["#141827","#62455b","#736681","#c1d9d0","#fffae3"],["#2b9eb3","#85cc9c","#bcd9a0","#edf79e","#fafad7"],["#cfb698","#ff5d57","#dd0b64","#6f0550","#401c2a"],["#a8c078","#a89048","#a84818","#61290e","#330c0c"],["#171133","#581e44","#c5485a","#d4be99","#e0ffcc"],["#ebe5b2","#f6f3c2","#f7c69f","#f89b7e","#b5a28b"],["#ff0f35","#f86254","#fea189","#f3d5a5","#bab997"],["#20130a","#142026","#123142","#3b657a","#e9f0c9"],["#bdbf90","#35352b","#e7e9c4","#ec6c2b","#feae4b"],["#eeccbb","#f1731f","#e03e36","#bd0d59","#730662"],["#ffcfad","#ffe4b8","#e6d1b1","#b8aa95","#5e5a54"],["#ff9934","#ffc018","#f8fef4","#cde54e","#b3c631"],["#d1dbc8","#b8c2a0","#c97c7a","#da3754","#1f1106"],["#bda0a2","#ffe6db","#d1eaee","#cbc8b5","#efb0a9"],["#4d433d","#525c5a","#56877d","#8ccc81","#bade57"],["#262525","#525252","#e6ddbc","#822626","#690202"],["#9d9f89","#84af97","#8bc59b","#b2de93","#ccee8d"],["#52423c","#ad5c70","#d3ad98","#edd4be","#b9c3c4"],["#353437","#53576b","#7a7b7c","#a39b7e","#e2c99f"],["#a22c27","#4f2621","#9f8241","#ebd592","#929867"],["#839074","#939e78","#a8a878","#061013","#cdcd76"],["#eb9d8d","#93865a","#a8bb9a","#c5cba6","#efd8a9"],["#6a3d5a","#66666e","#6d8d76","#b0c65a","#ebf74f"],["#ff9966","#d99973","#b39980","#8c998c","#669999"],["#d1dab9","#92bea5","#6f646c","#671045","#31233e"],["#f9ded3","#fdd1b6","#fab4b6","#c7b6be","#89abb4"],["#4b4b55","#f4324a","#ff516c","#fb9c5a","#fcc755"],["#820081","#fe59c2","#fe40b9","#fe1cac","#390039"],["#000000","#ed0b65","#b2a700","#fcae11","#770493"],["#941f1f","#ce6b5d","#ffefb9","#7b9971","#34502b"],["#482344","#2b5166","#429867","#fab243","#e02130"],["#031c30","#5a3546","#b5485f","#fc6747","#fa8d3b"],["#a9b79e","#e8ddbd","#dba887","#c25848","#9d1d36"],["#666666","#abdb25","#999999","#ffffff","#cccccc"],["#27081d","#47232c","#66997b","#a4ca8b","#d2e7aa"],["#8fc9b9","#d8d9c0","#d18e8f","#ab5c72","#91334f"],["#8ba6ac","#d7d7b8","#e5e6c9","#f8f8ec","#bdcdd0"],["#ffe7bf","#ffc978","#c9c987","#d1a664","#c27b57"],["#0c0636","#095169","#059b9a","#53ba83","#9fd86b"],["#f3dcb2","#facb97","#f59982","#ed616f","#f2116c"],["#ff3366","#e64066","#cc4d66","#b35966","#996666"],["#fdf4b0","#a4dcb9","#5bcebf","#32b9be","#2e97b7"],["#302727","#ba2d2d","#f2511b","#f2861b","#c7c730"],["#fdbf5c","#f69a0b","#d43a00","#9b0800","#1d2440"],["#dfd0af","#e8acac","#a45785","#85586c","#a1c0a1"],["#f3214e","#cf023b","#000000","#f4a854","#fff8bc"],["#ec4b59","#9a2848","#130716","#fc8c77","#f8dfbd"],["#1f0b0c","#e7fccf","#d6c396","#b3544f","#300511"],["#6e9167","#ffdd8c","#ff8030","#cc4e00","#700808"],["#332e1d","#5ac7aa","#9adcb9","#fafcd3","#efeba9"],["#adeada","#bdeadb","#cdeadc","#ddeadd","#edeade"],["#ffad08","#edd75a","#73b06f","#0c8f8f","#405059"],["#295264","#fad9a6","#bd2f28","#89373d","#142433"],["#331436","#7a1745","#cb4f57","#eb9961","#fcf4b6"],["#fef0a5","#f8d28b","#e3b18b","#a78d9e","#74819d"],["#f7ead9","#e1d2a9","#88b499","#619885","#67594e"],["#210518","#3d1c33","#5e4b55","#7c917f","#93bd9a"],["#ecf8d4","#e0deab","#cb8e5f","#85685a","#0d0502"]]'
				);
				var Tf = n(263),
					Ef = n(7570);
				function Cf(t) {
					var e = (function () {
						if ("undefined" == typeof Reflect || !m()) return !1;
						if (m().sham) return !1;
						if ("function" == typeof Proxy) return !0;
						try {
							return Boolean.prototype.valueOf.call(m()(Boolean, [], function () {})), !0;
						} catch (t) {
							return !1;
						}
					})();
					return function () {
						var n,
							i = T(t);
						if (e) {
							var r = T(this).constructor;
							n = m()(i, arguments, r);
						} else n = i.apply(this, arguments);
						return M(this, n);
					};
				}
				var Pf = (function (t) {
						x(n, t);
						var e = Cf(n);
						function n(t) {
							var i,
								r = t.uniforms,
								a = void 0 === r ? {} : r;
							return s(this, n), ((i = e.call(this, { vertexShader: Tf, fragmentShader: Ef, transparent: !0 })).userData = { uniforms: a }), i;
						}
						return (
							c(n, [
								{
									key: "onBeforeCompile",
									value: function (t) {
										t.uniforms = this.userData.uniforms;
									},
								},
							]),
							n
						);
					})(Ci),
					Af = n(7462),
					Lf = n(5837),
					Rf = n(8914),
					Df = n.n(Rf);
				class Of {
					constructor(t, e, n) {
						(this.variables = []), (this.currentTextureIndex = 0);
						let i = J;
						const r = new rs(),
							a = new ei();
						a.position.z = 1;
						const s = { passThruTexture: { value: null } },
							o = u("uniform sampler2D passThruTexture;\n\nvoid main() {\n\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\n\n\tgl_FragColor = texture2D( passThruTexture, uv );\n\n}\n", s),
							l = new Yn(new vi(2, 2), o);
						function c(n) {
							n.defines.resolution = "vec2( " + t.toFixed(1) + ", " + e.toFixed(1) + " )";
						}
						function u(t, e) {
							const n = new ti({ uniforms: (e = e || {}), vertexShader: "void main()\t{\n\n\tgl_Position = vec4( position, 1.0 );\n\n}\n", fragmentShader: t });
							return c(n), n;
						}
						r.add(l),
							(this.setDataType = function (t) {
								return (i = t), this;
							}),
							(this.addVariable = function (t, e, n) {
								const i = { name: t, initialValueTexture: n, material: this.createShaderMaterial(e), dependencies: null, renderTargets: [], wrapS: null, wrapT: null, minFilter: G, magFilter: G };
								return this.variables.push(i), i;
							}),
							(this.setVariableDependencies = function (t, e) {
								t.dependencies = e;
							}),
							(this.init = function () {
								if (!1 === n.capabilities.isWebGL2 && !1 === n.extensions.has("OES_texture_float")) return "No OES_texture_float support for float textures.";
								if (0 === n.capabilities.maxVertexTextures) return "No support for vertex shader textures.";
								for (let n = 0; n < this.variables.length; n++) {
									const i = this.variables[n];
									(i.renderTargets[0] = this.createRenderTarget(t, e, i.wrapS, i.wrapT, i.minFilter, i.magFilter)), (i.renderTargets[1] = this.createRenderTarget(t, e, i.wrapS, i.wrapT, i.minFilter, i.magFilter)), this.renderTexture(i.initialValueTexture, i.renderTargets[0]), this.renderTexture(i.initialValueTexture, i.renderTargets[1]);
									const r = i.material,
										a = r.uniforms;
									if (null !== i.dependencies)
										for (let t = 0; t < i.dependencies.length; t++) {
											const e = i.dependencies[t];
											if (e.name !== i.name) {
												let t = !1;
												for (let n = 0; n < this.variables.length; n++)
													if (e.name === this.variables[n].name) {
														t = !0;
														break;
													}
												if (!t) return "Variable dependency not found. Variable=" + i.name + ", dependency=" + e.name;
											}
											(a[e.name] = { value: null }), (r.fragmentShader = "\nuniform sampler2D " + e.name + ";\n" + r.fragmentShader);
										}
								}
								return (this.currentTextureIndex = 0), null;
							}),
							(this.compute = function () {
								const t = this.currentTextureIndex,
									e = 0 === this.currentTextureIndex ? 1 : 0;
								for (let n = 0, i = this.variables.length; n < i; n++) {
									const i = this.variables[n];
									if (null !== i.dependencies) {
										const e = i.material.uniforms;
										for (let n = 0, r = i.dependencies.length; n < r; n++) {
											const r = i.dependencies[n];
											e[r.name].value = r.renderTargets[t].texture;
										}
									}
									this.doRenderTarget(i.material, i.renderTargets[e]);
								}
								this.currentTextureIndex = e;
							}),
							(this.getCurrentRenderTarget = function (t) {
								return t.renderTargets[this.currentTextureIndex];
							}),
							(this.getAlternateRenderTarget = function (t) {
								return t.renderTargets[0 === this.currentTextureIndex ? 1 : 0];
							}),
							(this.addResolutionDefine = c),
							(this.createShaderMaterial = u),
							(this.createRenderTarget = function (n, r, a, s, o, l) {
								return new Gt((n = n || t), (r = r || e), { wrapS: (a = a || U), wrapT: (s = s || U), minFilter: (o = o || G), magFilter: (l = l || G), format: et, type: i, depthBuffer: !1 });
							}),
							(this.createTexture = function () {
								const n = new Float32Array(t * e * 4);
								return new Rs(n, t, e, et, J);
							}),
							(this.renderTexture = function (t, e) {
								(s.passThruTexture.value = t), this.doRenderTarget(o, e), (s.passThruTexture.value = null);
							}),
							(this.doRenderTarget = function (t, e) {
								const i = n.getRenderTarget();
								(l.material = t), n.setRenderTarget(e), n.render(r, a), (l.material = o), n.setRenderTarget(i);
							});
					}
				}
				var zf = new ((function () {
						function t(e, n, i) {
							s(this, t), e && this.init(e, n, i);
						}
						return (
							c(t, [
								{
									key: "getSize",
									value: function () {
										return { width: this.width, height: this.height, bits: 4 };
									},
								},
								{
									key: "init",
									value: function (t) {
										var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 64,
											n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
										t && ((this.width = e || 64), (this.height = n || 1), (this.instance = new Of(this.width, this.height, t)), Browser.isSafari && this.instance.setDataType(Q), (this.textures = {}));
									},
								},
								{
									key: "firstInit",
									value: function () {
										var t = this.instance.init();
										null !== t && console.error(t);
									},
								},
								{
									key: "compute",
									value: function () {
										this.instance && this.instance.compute();
									},
								},
								{
									key: "createTexture",
									value: function (t) {
										return (this.textures[t] = this.instance.createTexture()), this.textures[t];
									},
								},
								{
									key: "getCurrentRenderTarget",
									value: function (t) {
										return this.instance.getCurrentRenderTarget(t).texture;
									},
								},
								{
									key: "getAlternateRenderTarget",
									value: function (t) {
										return this.instance.getAlternateRenderTarget(t).texture;
									},
								},
								{
									key: "addVariable",
									value: function () {
										var t;
										return (t = this.instance).addVariable.apply(t, arguments);
									},
								},
								{
									key: "updateTextures",
									value: function () {
										var t = this,
											e = this.instance.variables;
										Df()(e).call(e, function (e) {
											t.instance.renderTexture(e.initialValueTexture, e.renderTargets[0]), t.instance.renderTexture(e.initialValueTexture, e.renderTargets[1]);
										});
									},
								},
							]),
							t
						);
					})())(),
					If = new ((function () {
						function t(e) {
							s(this, t), (this.mouse = new Xt()), (this.pmouse = new Xt()), (this.camera = e || null), (this.ray = new Ec()), (this.lookupObjects = []), (this.enabled = !0), this.bindHandlers(), this.bindEvents();
						}
						return (
							c(t, [
								{
									key: "bindHandlers",
									value: function () {
										var t = this;
										(this.pointerMoveHandler = function (e) {
											return t.onPointerMove(e.detail);
										}),
											(this.updateHandler = function () {
												return t.onUpdate();
											}),
											(this.clickHandler = function () {
												return t.onClick();
											});
									},
								},
								{
									key: "bindEvents",
									value: function () {
										document.addEventListener("layout:pointerMove", this.pointerMoveHandler), document.addEventListener("scene:updateFixed", this.updateHandler), document.addEventListener("click", this.clickHandler);
									},
								},
								{
									key: "init",
									value: function (t) {
										return (this.camera = t), this;
									},
								},
								{
									key: "onPointerMove",
									value: function (t) {
										var e = t.nx,
											n = t.ny;
										this.camera && this.enabled && ((this.mouse.x = e), (this.mouse.y = n), this.raytrace("pointermove"));
									},
								},
								{
									key: "onClick",
									value: function () {
										this.raytrace("click");
									},
								},
								{
									key: "onUpdate",
									value: function () {
										this.update();
									},
								},
								{
									key: "raytrace",
									value: function (t) {
										this.ray.setFromCamera(this.mouse, this.camera);
										var e = this.ray.intersectObjects(this.lookupObjects);
										Vc("pointer:found:".concat(t), { objects: e });
									},
								},
								{
									key: "update",
									value: function () {
										this.enabled && this.pmouse.copy(this.mouse);
									},
								},
								{
									key: "lookup",
									value: function () {
										var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
										this.lookupObjects = t;
									},
								},
								{
									key: "toggleEnabled",
									value: function (t) {
										t !== this.enabled && (this.enabled = t);
									},
								},
							]),
							t
						);
					})())();
				function kf(t) {
					var e = (function () {
						if ("undefined" == typeof Reflect || !m()) return !1;
						if (m().sham) return !1;
						if ("function" == typeof Proxy) return !0;
						try {
							return Boolean.prototype.valueOf.call(m()(Boolean, [], function () {})), !0;
						} catch (t) {
							return !1;
						}
					})();
					return function () {
						var n,
							i = T(t);
						if (e) {
							var r = T(this).constructor;
							n = m()(i, arguments, r);
						} else n = i.apply(this, arguments);
						return M(this, n);
					};
				}
				var Nf = (function (t) {
					x(i, t);
					var e,
						n = kf(i);
					function i() {
						var t;
						return (
							s(this, i),
							((t = n.call(this)).entity = new Ye()),
							(t.isReady = !1),
							t.init(),
							t.preload().then(function () {
								t.setMaterials(), t.setGeometries(), t.start();
							}),
							document.addEventListener("scene:update", function () {
								return t.update();
							}),
							document.addEventListener("scene:updateFixed", function () {
								return t.updateFixed();
							}),
							document.addEventListener("layout:change", function () {
								return t.onResize();
							}),
							document.addEventListener("orbit:change", function () {
								return t.onOrbitChange();
							}),
							t
						);
					}
					return (
						c(i, [
							{
								key: "preload",
								value:
									((e = a(
										p().mark(function t() {
											return p().wrap(function (t) {
												for (;;)
													switch ((t.prev = t.next)) {
														case 0:
														case "end":
															return t.stop();
													}
											}, t);
										})
									)),
									function () {
										return e.apply(this, arguments);
									}),
							},
							{ key: "init", value: function () {} },
							{ key: "setGeometries", value: function () {} },
							{ key: "setMaterials", value: function () {} },
							{ key: "start", value: function () {} },
							{ key: "update", value: function () {} },
							{ key: "updateFixed", value: function () {} },
							{ key: "onResize", value: function () {} },
							{ key: "onOrbitChange", value: function () {} },
						]),
						i
					);
				})(xt);
				function Vf(t) {
					var e = (function () {
						if ("undefined" == typeof Reflect || !m()) return !1;
						if (m().sham) return !1;
						if ("function" == typeof Proxy) return !0;
						try {
							return Boolean.prototype.valueOf.call(m()(Boolean, [], function () {})), !0;
						} catch (t) {
							return !1;
						}
					})();
					return function () {
						var n,
							i = T(t);
						if (e) {
							var r = T(this).constructor;
							n = m()(i, arguments, r);
						} else n = i.apply(this, arguments);
						return M(this, n);
					};
				}
				var Bf = Sf[Nc([244])],
					Ff = [8594932],
					Uf = (function (t) {
						x(n, t);
						var e = Vf(n);
						function n() {
							return s(this, n), e.apply(this, arguments);
						}
						return (
							c(n, [
								{
									key: "init",
									value: function () {
										var t = this,
											e = af.amountParticles.options.ultra;
										zf.init(Stage.renderer, e, e),
											(this.cursor = new Yn(new al(4), new vn())),
											(this.pointerTimer = null),
											(this.pointer = new Xt()),
											(this.pointerPos = new Xt()),
											(this.dampedPointer = new Xt()),
											(this.velocity = new Xt()),
											(this.hasControl = !0),
											(this.longTouch = !1),
											(this.isDown = { value: !1 }),
											(window.Cursor = new Xt()),
											document.addEventListener("layout:pointerMove", function (e) {
												return t.onPointerMove(e.detail);
											}),
											document.addEventListener("pointer:found:pointermove", function (e) {
												return t.onMove(e.detail);
											}),
											Stage.$canvas.addEventListener("pointerdown", function () {
												return t.onDown();
											}),
											Stage.$canvas.addEventListener("pointerup", function () {
												return t.onUp();
											}),
											document.addEventListener("gui:in", function () {
												return t.toggleControl(!1);
											}),
											document.addEventListener("gui:out", function () {
												return t.toggleControl(!0);
											}),
											document.addEventListener("pointerenter", function () {
												return t.toggleControl(!0);
											}),
											document.addEventListener("pointerleave", function () {
												return t.toggleControl(!1);
											}),
											document.addEventListener("gui:change:amountParticles", function () {
												return t.updateParticles();
											}),
											document.addEventListener("keydown", function (e) {
												return t.onKeydown(e);
											});
									},
								},
								{
									key: "setGeometries",
									value: function () {
										var t = af.amountParticles.options.ultra,
											e = Math.pow(t, 2),
											n = (af.time, af.delta, new ac().copy(Wf));
										(this.instancedMeshes = new Ns(n, this.mat, e)), (this.instancedMeshes.count = Math.pow(af.amountParticles.uniform.value, 2));
										var i = [],
											r = [],
											a = [],
											s = Wf.attributes.position;
										Wf.computeBoundingBox(), Wf.boundingBox.getSize(Hf);
										for (var o = 0; o < s.count; o++) {
											var l = s.getY(o) / Hf.y + 0.5;
											r.push(l);
										}
										for (var c = 0; c < e; c++) {
											var u = Dt.randFloat(0.1, 1.5);
											i.push((c % t) / t, Math.floor(c / t) / t);
											var h = new mn(Nc(Bf)),
												d = new mn(Nc(Ff));
											a.push(d.r, d.g, d.b), Gf.position.set(0, 0, 0), Gf.scale.set(u, u, u), Gf.updateMatrix(), this.instancedMeshes.setMatrixAt(c, Gf.matrix), this.instancedMeshes.setColorAt(c, h);
										}
										n.setAttribute("aRef", new Ds(new Float32Array(i), 2)), n.setAttribute("aAltColor", new Ds(new Float32Array(a), 3)), n.setAttribute("aProgress", new wn(r, 1)), (this.geom = n), (this.instancedMeshes.instanceMatrix.needsUpdate = !0);
									},
								},
								{
									key: "setMaterials",
									value: function () {
										var t = window.Ground,
											e = af.time,
											n = (af.lifespan, af.delta),
											i = (af.isBloomPass, af.lambda),
											r = af.gravity,
											a = af.minSpeed,
											s = af.maxSpeed,
											o = af.repulsion,
											l = af.attractionForce,
											c = af.repulsionForce,
											u = af.minVelocity,
											h = af.maxVelocity,
											d = af.noiseIntensity,
											p = af.timeScale,
											f = af.mulValue,
											m = af.goWild,
											v = (af.darkness, af.powerValue),
											g = zf.createTexture("position"),
											b = zf.createTexture("velocity");
										(this.particledata = zf.instance.createTexture()), jf(g, this.cursor.position), Xf(b, this.velocity), qf(this.particledata), (this.positionVariable = zf.addVariable("texturePosition", Af, g)), (this.velocityVariable = zf.addVariable("textureVelocity", Lf, b));
										var x = [this.positionVariable, this.velocityVariable];
										zf.instance.setVariableDependencies(this.positionVariable, x),
											zf.instance.setVariableDependencies(this.velocityVariable, x),
											of()(this.positionVariable.material.uniforms, { time: e, delta: n, timeScale: p.uniform }),
											of()(this.velocityVariable.material.uniforms, {
												time: e,
												delta: n,
												goWild: m,
												noiseIntensity: d.uniform,
												lambda: i.uniform,
												gravity: r.uniform,
												minSpeed: a.uniform,
												maxSpeed: s.uniform,
												attractionForce: l.uniform,
												damppointer: { value: this.dampedPointer },
												pointer: { value: this.pointer },
												pointerPosition: { value: this.pointerPos },
												repulsion: o.uniform,
												repulsionForce: c.uniform,
												minVelocity: u.uniform,
												maxVelocity: h.uniform,
												textureParticle: { value: this.particledata },
												groundOffset: { value: 15 },
												ground: { value: t.groundPlane.position },
												timeScale: p.uniform,
												isDown: this.isDown,
											}),
											zf.firstInit(),
											(this.mat = new Pf({ uniforms: { time: e, delta: n, pointer: { value: this.dampedPointer }, texturePrevPosition: { value: null }, texturePosition: { value: null }, textureParticle: { value: this.particledata }, textureVelocity: { value: null }, minVelocity: u.uniform, maxVelocity: h.uniform, mulValue: f.uniform, powerValue: v.uniform, timeScale: p.uniform } }));
									},
								},
								{
									key: "start",
									value: function () {
										If.lookup([Stage.scene.ground.trigger]), this.onResize(), this.entity.add(this.instancedMeshes), this.entity.add(this.cursor), zf.compute();
										var t = zf.getCurrentRenderTarget(this.velocityVariable);
										(this.mat.userData.uniforms.textureVelocity.value = t), (this.isReady = !0);
									},
								},
								{
									key: "debug",
									value: function () {
										(this.debugMesh = new Yn(new vi(10, 10), new vn({ map: _f()(Stage.scene.lights.children[1].shadow).texture, side: 2 }))), this.entity.add(this.debugMesh);
									},
								},
								{
									key: "toggleControl",
									value: function () {
										var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : !this.hasControl;
										t !== this.hasControl && ((this.hasControl = t), this.hasControl || this.pointerPos.set(0, 0, 0));
									},
								},
								{
									key: "updateParticles",
									value: function () {
										this.instancedMeshes.count = Math.pow(af.amountParticles.uniform.value, 2);
									},
								},
								{
									key: "onKeydown",
									value: function (t) {
										if ("KeyR" === t.code) {
											var e = this.positionVariable.initialValueTexture,
												n = this.velocityVariable.initialValueTexture;
											jf(e, this.cursor.position), Xf(n, this.velocity), zf.updateTextures();
										}
									},
								},
								{
									key: "onMove",
									value: function (t) {
										var e = t.objects;
										if (e.length && !Stage.scene.isPaused && this.hasControl) {
											var n = e[0].point;
											this.pointerPos.copy(n);
										}
									},
								},
								{
									key: "onPointerMove",
									value: function (t) {
										var e = t.nx,
											n = t.ny;
										clearTimeout(this.pointerTimer), this.longTouch || this.onUp(), this.hasControl && ((this.pointer.x = e), (this.pointer.y = n));
									},
								},
								{
									key: "onResize",
									value: function () {
										Stage.camera.aspect;
									},
								},
								{
									key: "onOrbitChange",
									value: function () {
										this.onResize();
									},
								},
								{
									key: "onDown",
									value: function () {
										var t = this;
										!Stage.scene.isPaused &&
											af.timeScale.uniform.value &&
											(tf.to(af.fishEye, { value: 1, ease: "expo.inOut", duration: 1, overwrite: !0 }),
											(this.pointerTimer = h()(function () {
												(t.isDown.value = !0), (t.longTouch = !0), (gf.controls.enableRotate = !1), tf.to(af.goWild, { value: 1, ease: "power4.in", duration: 0.1, overwrite: !0 });
											}, 400)));
									},
								},
								{
									key: "onUp",
									value: function () {
										clearTimeout(this.pointerTimer);
										var t = Browser.isMobile;
										(gf.controls.enableRotate = !t), (this.isDown.value = !1), (this.longTouch = !1), tf.to(af.goWild, { value: 0, ease: "back.out(3)", duration: 0.3, overwrite: !0 }), tf.to(af.fishEye, { value: 0, ease: "back.out(4)", duration: 0.8, delay: 0.02, overwrite: !0 });
									},
								},
								{
									key: "update",
									value: function () {
										af.focus.uniform.value = this.cursor.position.distanceTo(Stage.camera.position);
									},
								},
								{
									key: "updateFixed",
									value: function () {
										if (this.isReady) {
											var t = af.delta.value;
											zf.compute(), this.velocity.subVectors(this.pointerPos, this.dampedPointer);
											var e = zf.getCurrentRenderTarget(this.positionVariable),
												n = zf.getCurrentRenderTarget(this.velocityVariable),
												i = zf.getAlternateRenderTarget(this.positionVariable);
											(this.mat.userData.uniforms.texturePosition.value = e), (this.mat.userData.uniforms.textureVelocity.value = n), (this.mat.userData.uniforms.texturePrevPosition.value = i), this.dampedPointer.damp(this.pointerPos, 0.2, t), (this.cursor.position.x = this.dampedPointer.x), (this.cursor.position.y = this.dampedPointer.y), (this.cursor.position.z = this.dampedPointer.z + 2 * Math.sin(0.01 * af.time.value));
										}
									},
								},
							]),
							n
						);
					})(Nf),
					Hf = new Xt(),
					Gf = new Ye(),
					Wf = new ro(0.3, 0.3, 8, 6, 8),
					jf = function (t, e) {
						for (var n = t.image.data, i = 0, r = n.length; i < r; i += 4) (Hf.x = Dt.randFloatSpread(4)), (Hf.y = Dt.randFloatSpread(4)), (Hf.z = Dt.randFloatSpread(4)), (n[i + 0] = e.x + Hf.x), (n[i + 1] = e.y + Hf.y), (n[i + 2] = e.z + Hf.z), (n[i + 3] = 1);
						t.needsUpdate = !0;
					},
					Xf = function (t, e) {
						for (var n = t.image.data, i = 0, r = n.length; i < r; i += 4) {
							var a = Math.random(),
								s = Math.random(),
								o = a * Math.PI * 2,
								l = Math.acos(2 * s - 0.2),
								c = Mf()(500 * Math.random());
							Hf.setFromSphericalCoords(c, l, o), (n[i + 0] = 0.1 * e.x + Hf.x), (n[i + 1] = 0.1 * e.y + Hf.y), (n[i + 2] = 0.1 * e.z + Hf.z), (n[i + 3] = Math.random());
						}
						t.needsUpdate = !0;
					},
					qf = function (t) {
						for (var e = t.image.data, n = af.minLifeSpan, i = af.maxLifeSpan, r = af.minSpeed, a = af.maxSpeed, s = 0, o = e.length; s < o; s += 4) {
							var l = Dt.randFloat(n.uniform.value, i.uniform.value);
							(e[s + 0] = l), (e[s + 1] = 0), (e[s + 2] = r.uniform.value), (e[s + 3] = a.uniform.value);
						}
						t.needsUpdate = !0;
					},
					Yf = n(8363);
				var Zf = n(9996);
				var Kf = n(5238),
					Jf = n(3592);
				function Qf(t, e) {
					(null == e || e > t.length) && (e = t.length);
					for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
					return i;
				}
				function $f(t, e) {
					return (
						(function (t) {
							if (Yf(t)) return t;
						})(t) ||
						(function (t, e) {
							var n = null == t ? null : (void 0 !== y && Zf(t)) || t["@@iterator"];
							if (null != n) {
								var i,
									r,
									a = [],
									s = !0,
									o = !1;
								try {
									for (n = n.call(t); !(s = (i = n.next()).done) && (a.push(i.value), !e || a.length !== e); s = !0);
								} catch (t) {
									(o = !0), (r = t);
								} finally {
									try {
										s || null == n.return || n.return();
									} finally {
										if (o) throw r;
									}
								}
								return a;
							}
						})(t, e) ||
						(function (t, e) {
							var n;
							if (t) {
								if ("string" == typeof t) return Qf(t, e);
								var i = Kf((n = Object.prototype.toString.call(t))).call(n, 8, -1);
								return "Object" === i && t.constructor && (i = t.constructor.name), "Map" === i || "Set" === i ? Jf(t) : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Qf(t, e) : void 0;
							}
						})(t, e) ||
						(function () {
							throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
						})()
					);
				}
				var tm = n(875),
					em = n.n(tm),
					nm = new Vl();
				function im(t) {
					return new (em())(function (e) {
						nm.load(t, function (n) {
							(Dt.isPowerOfTwo(n.image.width) && Dt.isPowerOfTwo(n.image.height)) || console.warn('"'.concat(t, '" image size is not power of 2.')), e(n);
						});
					});
				}
				var rm = n(6902),
					am = n.n(rm),
					sm = n(4310),
					om = n.n(sm),
					lm = n(116),
					cm = n.n(lm),
					um = n(4074),
					hm = n.n(um),
					dm = n(9649),
					pm = n.n(dm),
					fm = n(368),
					mm = n.n(fm),
					vm = n(3978),
					gm = n.n(vm);
				function bm(t, e, n) {
					return e in t ? o(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : (t[e] = n), t;
				}
				var xm = n(881),
					ym = n(8157);
				function _m(t, e) {
					var n = am()(t);
					if (om()) {
						var i = om()(t);
						e &&
							(i = cm()(i).call(i, function (e) {
								return hm()(t, e).enumerable;
							})),
							n.push.apply(n, i);
					}
					return n;
				}
				function wm(t) {
					for (var e = 1; e < arguments.length; e++) {
						var n,
							i = null != arguments[e] ? arguments[e] : {};
						if (e % 2)
							Df()((n = _m(Object(i), !0))).call(n, function (e) {
								bm(t, e, i[e]);
							});
						else if (pm()) mm()(t, pm()(i));
						else {
							var r;
							Df()((r = _m(Object(i)))).call(r, function (e) {
								gm()(t, e, hm()(i, e));
							});
						}
					}
					return t;
				}
				const Mm = function () {
					var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
					return { uniforms: wm({ color: { value: null }, tDiffuse: { value: null }, textureMatrix: { value: null }, resolution: Layout.R }, t), vertexShader: ym, fragmentShader: xm };
				};
				class Sm extends Yn {
					constructor(t, e = {}) {
						super(t), (this.type = "Reflector");
						const n = this,
							i = void 0 !== e.color ? new mn(e.color) : new mn(8355711),
							r = e.textureWidth || 512,
							a = e.textureHeight || 512,
							s = e.clipBias || 0,
							o = e.shader || Sm.ReflectorShader,
							l = new ui(),
							c = new Xt(),
							u = new Xt(),
							h = new Xt(),
							d = new Me(),
							p = new Xt(0, 0, -1),
							f = new Ht(),
							m = new Xt(),
							v = new Xt(),
							g = new Ht(),
							b = new Me(),
							x = new ni(),
							y = new Gt(r, a, { minFilter: X, magFilter: X, format: tt });
						(Dt.isPowerOfTwo(r) && Dt.isPowerOfTwo(a)) || (y.texture.generateMipmaps = !1);
						const _ = new ti({ uniforms: $n.clone(o.uniforms), fragmentShader: o.fragmentShader, vertexShader: o.vertexShader });
						(_.uniforms.tDiffuse.value = y.texture),
							(_.uniforms.color.value = i),
							(_.uniforms.textureMatrix.value = b),
							(this.material = _),
							(this.onBeforeRender = function (t, e, i) {
								if ((u.setFromMatrixPosition(n.matrixWorld), h.setFromMatrixPosition(i.matrixWorld), d.extractRotation(n.matrixWorld), c.set(0, 0, 1), c.applyMatrix4(d), m.subVectors(u, h), m.dot(c) > 0)) return;
								m.reflect(c).negate(),
									m.add(u),
									d.extractRotation(i.matrixWorld),
									p.set(0, 0, -1),
									p.applyMatrix4(d),
									p.add(h),
									v.subVectors(u, p),
									v.reflect(c).negate(),
									v.add(u),
									x.position.copy(m),
									x.up.set(0, 1, 0),
									x.up.applyMatrix4(d),
									x.up.reflect(c),
									x.lookAt(v),
									(x.far = i.far),
									x.updateMatrixWorld(),
									x.projectionMatrix.copy(i.projectionMatrix),
									b.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
									b.multiply(x.projectionMatrix),
									b.multiply(x.matrixWorldInverse),
									b.multiply(n.matrixWorld),
									l.setFromNormalAndCoplanarPoint(c, u),
									l.applyMatrix4(x.matrixWorldInverse),
									f.set(l.normal.x, l.normal.y, l.normal.z, l.constant);
								const r = x.projectionMatrix;
								(g.x = (Math.sign(f.x) + r.elements[8]) / r.elements[0]), (g.y = (Math.sign(f.y) + r.elements[9]) / r.elements[5]), (g.z = -1), (g.w = (1 + r.elements[10]) / r.elements[14]), f.multiplyScalar(2 / f.dot(g)), (r.elements[2] = f.x), (r.elements[6] = f.y), (r.elements[10] = f.z + 1 - s), (r.elements[14] = f.w), (y.texture.encoding = t.outputEncoding), (n.visible = !1);
								const a = t.getRenderTarget(),
									o = t.xr.enabled,
									_ = t.shadowMap.autoUpdate;
								(t.xr.enabled = !1), (t.shadowMap.autoUpdate = !1), t.setRenderTarget(y), t.state.buffers.depth.setMask(!0), !1 === t.autoClear && t.clear(), t.render(e, x), (t.xr.enabled = o), (t.shadowMap.autoUpdate = _), t.setRenderTarget(a);
								const w = i.viewport;
								void 0 !== w && t.state.viewport(w), (n.visible = !0);
							}),
							(this.getRenderTarget = function () {
								return y;
							});
					}
				}
				function Tm(t) {
					var e = (function () {
						if ("undefined" == typeof Reflect || !m()) return !1;
						if (m().sham) return !1;
						if ("function" == typeof Proxy) return !0;
						try {
							return Boolean.prototype.valueOf.call(m()(Boolean, [], function () {})), !0;
						} catch (t) {
							return !1;
						}
					})();
					return function () {
						var n,
							i = T(t);
						if (e) {
							var r = T(this).constructor;
							n = m()(i, arguments, r);
						} else n = i.apply(this, arguments);
						return M(this, n);
					};
				}
				(Sm.prototype.isReflector = !0),
					(Sm.ReflectorShader = {
						uniforms: { color: { value: null }, tDiffuse: { value: null }, textureMatrix: { value: null } },
						vertexShader: "\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}",
						fragmentShader:
							"\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t}",
					});
				var Em = (function (t) {
						x(i, t);
						var e,
							n = Tm(i);
						function i() {
							return s(this, i), n.apply(this, arguments);
						}
						return (
							c(i, [
								{
									key: "preload",
									value:
										((e = a(
											p().mark(function t() {
												return p().wrap(
													function (t) {
														for (;;)
															switch ((t.prev = t.next)) {
																case 0:
																	return (
																		(t.next = 2),
																		em()
																			.all([im("img/water_normalmap_seamless.png"), im("img/Water0175normal.jpg")])
																			.then(function (t) {
																				return (
																					Df()(t).call(t, function (t) {
																						(t.wrapS = H), (t.wrapT = H);
																					}),
																					t
																				);
																			})
																	);
																case 2:
																	this.store = t.sent;
																case 3:
																case "end":
																	return t.stop();
															}
													},
													t,
													this
												);
											})
										)),
										function () {
											return e.apply(this, arguments);
										}),
								},
								{
									key: "init",
									value: function () {
										window.Ground = this;
										var t = new Sm(new vi(1, 1, 300, 300), {
											shader: Mm({ tWaterNormal0: { value: null }, tWaterNormal1: { value: null }, normalScale: { value: null }, time: { value: null }, delta: { value: null }, pointer: { value: null }, pointerModelViewMatrix: { value: null }, mulValue: { value: null }, powerValue: { value: null }, timeScale: { value: null }, isBloomPass: { value: null } }),
											clipBias: 0.01,
											textureWidth: Layout.W,
											textureHeight: Layout.H,
											color: 0.6 * af.BG,
										});
										t.scale.set(1e3, 1e3, 1e3), t.rotateX(Math.PI / -2), (t.position.y = -30), (this.groundPlane = t);
										var e = new Yn(new io(), new vn());
										(e.visible = !1), e.scale.set(200, 200, 1), e.rotateX(Math.PI / -2), (this.trigger = e), this.entity.add(this.trigger), this.entity.add(t);
									},
								},
								{
									key: "start",
									value: function () {
										var t = $f(this.store, 2),
											e = t[0],
											n = t[1];
										(this.groundPlane.material.uniforms.tWaterNormal0.value = e),
											(this.groundPlane.material.uniforms.tWaterNormal1.value = n),
											(this.groundPlane.material.uniforms.time = af.time),
											(this.groundPlane.material.uniforms.delta = af.delta),
											(this.groundPlane.material.uniforms.isBloomPass = af.isBloomPass),
											(this.groundPlane.material.uniforms.normalScale = af.normalScale.uniform),
											(this.groundPlane.material.uniforms.mulValue = af.mulValue.uniform),
											(this.groundPlane.material.uniforms.powerValue = af.powerValue.uniform),
											(this.groundPlane.material.uniforms.timeScale = af.timeScale.uniform);
									},
								},
								{
									key: "onResize",
									value: function () {
										var t = Layout,
											e = t.W,
											n = t.H;
										this.groundPlane.getRenderTarget().setSize(e, n);
									},
								},
							]),
							i
						);
					})(Nf),
					Cm = n(2934),
					Pm = n(1089);
				function Am(t) {
					var e = (function () {
						if ("undefined" == typeof Reflect || !m()) return !1;
						if (m().sham) return !1;
						if ("function" == typeof Proxy) return !0;
						try {
							return Boolean.prototype.valueOf.call(m()(Boolean, [], function () {})), !0;
						} catch (t) {
							return !1;
						}
					})();
					return function () {
						var n,
							i = T(t);
						if (e) {
							var r = T(this).constructor;
							n = m()(i, arguments, r);
						} else n = i.apply(this, arguments);
						return M(this, n);
					};
				}
				var Lm = (function (t) {
					x(n, t);
					var e = Am(n);
					function n() {
						var t,
							i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
						return s(this, n), ((t = e.call(this, { vertexShader: Cm, fragmentShader: Pm, transparent: !0, blending: 2, depthWrite: !1 })).uniforms = i), t;
					}
					return n;
				})(Ci);
				function Rm(t) {
					var e = (function () {
						if ("undefined" == typeof Reflect || !m()) return !1;
						if (m().sham) return !1;
						if ("function" == typeof Proxy) return !0;
						try {
							return Boolean.prototype.valueOf.call(m()(Boolean, [], function () {})), !0;
						} catch (t) {
							return !1;
						}
					})();
					return function () {
						var n,
							i = T(t);
						if (e) {
							var r = T(this).constructor;
							n = m()(i, arguments, r);
						} else n = i.apply(this, arguments);
						return M(this, n);
					};
				}
				var Dm = Sf[Nc([244])],
					Om = (function (t) {
						x(n, t);
						var e = Rm(n);
						function n() {
							return s(this, n), e.apply(this, arguments);
						}
						return (
							c(n, [
								{
									key: "init",
									value: function () {
										this.initMaterial(), this.initSystem();
									},
								},
								{
									key: "initMaterial",
									value: function () {
										this.mat = new Lm({ time: af.time, goWild: af.goWild, changeStars: af.changeStars, pointer: { value: null } });
									},
								},
								{
									key: "initSystem",
									value: function () {
										for (var t = new Ln(), e = [], n = [], i = [], r = [], a = [], s = 0; s < 4e3; s++) {
											var o = Math.random(),
												l = Math.random(),
												c = o * Math.PI * 2,
												u = Math.acos(2 * l - 1),
												h = 300 * Mf()(Math.random()),
												d = Math.sin(c),
												p = Math.cos(c),
												f = Math.sin(u),
												m = h * f * p,
												v = h * f * d,
												g = h * Math.cos(u),
												b = new mn(Nc(Dm));
											e.push(m, v, g), n.push(10), i.push(b.r, b.g, b.b), r.push(Math.random()), a.push(s / 4e3);
										}
										t.setAttribute("position", new wn(e, 3)), t.setAttribute("size", new wn(n, 1)), t.setAttribute("rand", new wn(r, 1)), t.setAttribute("stagger", new wn(a, 1)), t.setAttribute("aColor", new wn(i, 3));
										var x = new to(t, this.mat);
										this.entity.add(x);
									},
								},
							]),
							n
						);
					})(Nf);
				const zm = new cc();
				function Im(t) {
					var e = (function () {
						if ("undefined" == typeof Reflect || !m()) return !1;
						if (m().sham) return !1;
						if ("function" == typeof Proxy) return !0;
						try {
							return Boolean.prototype.valueOf.call(m()(Boolean, [], function () {})), !0;
						} catch (t) {
							return !1;
						}
					})();
					return function () {
						var n,
							i = T(t);
						if (e) {
							var r = T(this).constructor;
							n = m()(i, arguments, r);
						} else n = i.apply(this, arguments);
						return M(this, n);
					};
				}
				var km = (function (t) {
						x(n, t);
						var e = Im(n);
						function n() {
							var t;
							return (
								s(this, n),
								((t = e.call(this)).isPaused = !1),
								t.initLights(),
								t.initScene(),
								document.addEventListener("renderer:paused", function (e) {
									return t.toggleRender(e.detail);
								}),
								t
							);
						}
						return (
							c(n, [
								{
									key: "initScene",
									value: function () {
										(this.ground = new Em()), (this.mesh = new Uf()), (this.particles = new Om()), (this.ground.groundPlane.material.uniforms.pointer.value = this.mesh.dampedPointer), (this.particles.mat.uniforms.pointer.value = this.mesh.dampedPointer), this.add(this.mesh.entity, this.ground.entity, this.particles.entity);
									},
								},
								{ key: "initLights", value: function () {} },
								{
									key: "toggleRender",
									value: function (t) {
										var e = t.isPaused;
										(this.isPaused = e), e ? zm.stop() : zm.start();
									},
								},
								{
									key: "update",
									value: function () {
										if (!this.isPaused) {
											if (af.timeScale.uniform.value) {
												var t = Math.min(1, zm.getDelta() / Nm) * Math.max(0.001, af.timeScale.uniform.value);
												(af.delta.value = t), (af.time.value += t), Vc("scene:updateFixed");
											}
											Vc("scene:update");
										}
									},
								},
							]),
							n
						);
					})(rs),
					Nm = 1 / 60;
				function Vm(t) {
					var e = (function () {
						if ("undefined" == typeof Reflect || !m()) return !1;
						if (m().sham) return !1;
						if ("function" == typeof Proxy) return !0;
						try {
							return Boolean.prototype.valueOf.call(m()(Boolean, [], function () {})), !0;
						} catch (t) {
							return !1;
						}
					})();
					return function () {
						var n,
							i = T(t);
						if (e) {
							var r = T(this).constructor;
							n = m()(i, arguments, r);
						} else n = i.apply(this, arguments);
						return M(this, n);
					};
				}
				var Bm = (function (t) {
						x(n, t);
						var e = Vm(n);
						function n() {
							var t;
							s(this, n);
							var i = Layout,
								r = i.W / i.H;
							return ((t = e.call(this, 50, r, 0.1, 1e3)).prevFishEye = af.fishEye.value), (t.wobbleParams = { wobbleFrequency: 1, wobbleAmplitude: 1, wobbleCameraDisplacement: 3 }), (t.prevPointerPosition = new Xt()), (t.wobbleTransform = new Xt()), (t.hasControl = !0), t.position.set(0, 150, 246), t.lookAt(new Xt()), t.bindEvents(), t;
						}
						return (
							c(n, [
								{
									key: "bindEvents",
									value: function () {
										var t = this;
										document.addEventListener("layout:change", function () {
											return t.onResize();
										}),
											document.addEventListener("scene:updateFixed", function () {
												return t.update();
											}),
											document.addEventListener("layout:pointerMove", function (e) {
												return t.onPointerMove(e.detail);
											}),
											document.addEventListener("gui:in", function () {
												return t.toggleControl(!1);
											}),
											document.addEventListener("gui:out", function () {
												return t.toggleControl(!0);
											}),
											document.addEventListener("pointerenter", function () {
												return t.toggleControl(!0);
											}),
											document.addEventListener("pointerleave", function () {
												return t.toggleControl(!1);
											});
									},
								},
								{
									key: "onResize",
									value: function () {
										var t = Layout,
											e = t.W,
											n = t.H;
										(this.aspect = e / n), this.updateProjectionMatrix();
									},
								},
								{
									key: "onPointerMove",
									value: function (t) {
										var e = t.nx,
											n = t.ny;
										if (this.hasControl && !Stage.renderer.isPaused) {
											var i = this.wobbleParams.wobbleCameraDisplacement;
											(Fm.x = e * i * af.timeScale.uniform.value), (Fm.y = n * i * af.timeScale.uniform.value);
										}
									},
								},
								{
									key: "toggleControl",
									value: function () {
										var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : !this.hasControl;
										t !== this.hasControl && ((this.hasControl = t), this.hasControl || Fm.set(0, 0, 0));
									},
								},
								{
									key: "update",
									value: function () {
										if (!Stage.renderer.isPaused) {
											var t = af.delta,
												e = af.goWild,
												n = af.fishEye,
												i = af.time.value,
												r = this.wobbleParams,
												a = r.wobbleFrequency,
												s = r.wobbleAmplitude,
												o = 1 - e.value;
											Um.copy(Fm).sub(this.prevPointerPosition), Um.multiplyScalar(af.timeScale.uniform.value), this.wobbleTransform.add(Um);
											var l = 0.03 * Math.sin(0.003 * i * a) * s,
												c = 0.06 * Math.cos(0.005 * i * a) * s,
												u = 0.04 * Math.sin(0.004 * i * a) * s;
											(this.wobbleTransform.x += l * af.timeScale.uniform.value * o),
												(this.wobbleTransform.y += c * af.timeScale.uniform.value * o),
												(this.wobbleTransform.z += u * af.timeScale.uniform.value * o),
												gf.controls && gf.controls.target.damp(this.wobbleTransform, 0.1, t.value),
												this.prevPointerPosition.damp(Fm, 0.1, t.value),
												n.value !== this.prevFishEye && (Um.copy(this.position).negate(), (this.fov = Dt.lerp(50, 70, n.value)), this.updateProjectionMatrix(), (this.prevFishEye = n.value));
										}
									},
								},
							]),
							n
						);
					})(ni),
					Fm = new Xt(),
					Um = new Xt(),
					Hm = { uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } }, vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}", fragmentShader: "\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\t\t}" };
				class Gm {
					constructor() {
						(this.enabled = !0), (this.needsSwap = !0), (this.clear = !1), (this.renderToScreen = !1);
					}
					setSize() {}
					render() {
						console.error("THREE.Pass: .render() must be implemented in derived pass.");
					}
				}
				const Wm = new Ei(-1, 1, 1, -1, 0, 1),
					jm = new Ln();
				jm.setAttribute("position", new wn([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), jm.setAttribute("uv", new wn([0, 2, 0, 0, 2, 0], 2));
				class Xm {
					constructor(t) {
						this._mesh = new Yn(jm, t);
					}
					dispose() {
						this._mesh.geometry.dispose();
					}
					render(t) {
						t.render(this._mesh, Wm);
					}
					get material() {
						return this._mesh.material;
					}
					set material(t) {
						this._mesh.material = t;
					}
				}
				class qm extends Gm {
					constructor(t, e) {
						super(), (this.textureID = void 0 !== e ? e : "tDiffuse"), t instanceof ti ? ((this.uniforms = t.uniforms), (this.material = t)) : t && ((this.uniforms = $n.clone(t.uniforms)), (this.material = new ti({ defines: Object.assign({}, t.defines), uniforms: this.uniforms, vertexShader: t.vertexShader, fragmentShader: t.fragmentShader }))), (this.fsQuad = new Xm(this.material));
					}
					render(t, e, n) {
						this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), (this.fsQuad.material = this.material), this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), this.fsQuad.render(t));
					}
				}
				class Ym extends Gm {
					constructor(t, e) {
						super(), (this.scene = t), (this.camera = e), (this.clear = !0), (this.needsSwap = !1), (this.inverse = !1);
					}
					render(t, e, n) {
						const i = t.getContext(),
							r = t.state;
						let a, s;
						r.buffers.color.setMask(!1),
							r.buffers.depth.setMask(!1),
							r.buffers.color.setLocked(!0),
							r.buffers.depth.setLocked(!0),
							this.inverse ? ((a = 0), (s = 1)) : ((a = 1), (s = 0)),
							r.buffers.stencil.setTest(!0),
							r.buffers.stencil.setOp(i.REPLACE, i.REPLACE, i.REPLACE),
							r.buffers.stencil.setFunc(i.ALWAYS, a, 4294967295),
							r.buffers.stencil.setClear(s),
							r.buffers.stencil.setLocked(!0),
							t.setRenderTarget(n),
							this.clear && t.clear(),
							t.render(this.scene, this.camera),
							t.setRenderTarget(e),
							this.clear && t.clear(),
							t.render(this.scene, this.camera),
							r.buffers.color.setLocked(!1),
							r.buffers.depth.setLocked(!1),
							r.buffers.stencil.setLocked(!1),
							r.buffers.stencil.setFunc(i.EQUAL, 1, 4294967295),
							r.buffers.stencil.setOp(i.KEEP, i.KEEP, i.KEEP),
							r.buffers.stencil.setLocked(!0);
					}
				}
				class Zm extends Gm {
					constructor() {
						super(), (this.needsSwap = !1);
					}
					render(t) {
						t.state.buffers.stencil.setLocked(!1), t.state.buffers.stencil.setTest(!1);
					}
				}
				class Km {
					constructor(t, e) {
						if (((this.renderer = t), void 0 === e)) {
							const n = { minFilter: X, magFilter: X, format: et },
								i = t.getSize(new Ot());
							(this._pixelRatio = t.getPixelRatio()), (this._width = i.width), (this._height = i.height), ((e = new Gt(this._width * this._pixelRatio, this._height * this._pixelRatio, n)).texture.name = "EffectComposer.rt1");
						} else (this._pixelRatio = 1), (this._width = e.width), (this._height = e.height);
						(this.renderTarget1 = e), (this.renderTarget2 = e.clone()), (this.renderTarget2.texture.name = "EffectComposer.rt2"), (this.writeBuffer = this.renderTarget1), (this.readBuffer = this.renderTarget2), (this.renderToScreen = !0), (this.passes = []), void 0 === Hm && console.error("THREE.EffectComposer relies on CopyShader"), void 0 === qm && console.error("THREE.EffectComposer relies on ShaderPass"), (this.copyPass = new qm(Hm)), (this.clock = new cc());
					}
					swapBuffers() {
						const t = this.readBuffer;
						(this.readBuffer = this.writeBuffer), (this.writeBuffer = t);
					}
					addPass(t) {
						this.passes.push(t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
					}
					insertPass(t, e) {
						this.passes.splice(e, 0, t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
					}
					removePass(t) {
						const e = this.passes.indexOf(t);
						-1 !== e && this.passes.splice(e, 1);
					}
					isLastEnabledPass(t) {
						for (let e = t + 1; e < this.passes.length; e++) if (this.passes[e].enabled) return !1;
						return !0;
					}
					render(t) {
						void 0 === t && (t = this.clock.getDelta());
						const e = this.renderer.getRenderTarget();
						let n = !1;
						for (let e = 0, i = this.passes.length; e < i; e++) {
							const i = this.passes[e];
							if (!1 !== i.enabled) {
								if (((i.renderToScreen = this.renderToScreen && this.isLastEnabledPass(e)), i.render(this.renderer, this.writeBuffer, this.readBuffer, t, n), i.needsSwap)) {
									if (n) {
										const e = this.renderer.getContext(),
											n = this.renderer.state.buffers.stencil;
										n.setFunc(e.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t), n.setFunc(e.EQUAL, 1, 4294967295);
									}
									this.swapBuffers();
								}
								void 0 !== Ym && (i instanceof Ym ? (n = !0) : i instanceof Zm && (n = !1));
							}
						}
						this.renderer.setRenderTarget(e);
					}
					reset(t) {
						if (void 0 === t) {
							const e = this.renderer.getSize(new Ot());
							(this._pixelRatio = this.renderer.getPixelRatio()), (this._width = e.width), (this._height = e.height), (t = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
						}
						this.renderTarget1.dispose(), this.renderTarget2.dispose(), (this.renderTarget1 = t), (this.renderTarget2 = t.clone()), (this.writeBuffer = this.renderTarget1), (this.readBuffer = this.renderTarget2);
					}
					setSize(t, e) {
						(this._width = t), (this._height = e);
						const n = this._width * this._pixelRatio,
							i = this._height * this._pixelRatio;
						this.renderTarget1.setSize(n, i), this.renderTarget2.setSize(n, i);
						for (let t = 0; t < this.passes.length; t++) this.passes[t].setSize(n, i);
					}
					setPixelRatio(t) {
						(this._pixelRatio = t), this.setSize(this._width, this._height);
					}
				}
				new Ei(-1, 1, 1, -1, 0, 1);
				const Jm = new Ln();
				Jm.setAttribute("position", new wn([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), Jm.setAttribute("uv", new wn([0, 2, 0, 0, 2, 0], 2));
				class Qm extends Gm {
					constructor(t, e, n, i, r) {
						super(), (this.scene = t), (this.camera = e), (this.overrideMaterial = n), (this.clearColor = i), (this.clearAlpha = void 0 !== r ? r : 0), (this.clear = !0), (this.clearDepth = !1), (this.needsSwap = !1), (this._oldClearColor = new mn());
					}
					render(t, e, n) {
						const i = t.autoClear;
						let r, a;
						(t.autoClear = !1),
							void 0 !== this.overrideMaterial && ((a = this.scene.overrideMaterial), (this.scene.overrideMaterial = this.overrideMaterial)),
							this.clearColor && (t.getClearColor(this._oldClearColor), (r = t.getClearAlpha()), t.setClearColor(this.clearColor, this.clearAlpha)),
							this.clearDepth && t.clearDepth(),
							t.setRenderTarget(this.renderToScreen ? null : n),
							this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
							t.render(this.scene, this.camera),
							this.clearColor && t.setClearColor(this._oldClearColor, r),
							void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = a),
							(t.autoClear = i);
					}
				}
				const $m = {
						defines: { SMAA_THRESHOLD: "0.1" },
						uniforms: { tDiffuse: { value: null }, resolution: { value: new Ot(1 / 1024, 1 / 512) } },
						vertexShader:
							"\n\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 3 ];\n\n\t\tvoid SMAAEdgeDetectionVS( vec2 texcoord ) {\n\t\t\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 ); // WebGL port note: Changed sign in W component\n\t\t\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component\n\t\t\tvOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 ); // WebGL port note: Changed sign in W component\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tSMAAEdgeDetectionVS( vUv );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
						fragmentShader:
							"\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 3 ];\n\n\t\tvec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {\n\t\t\tvec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );\n\n\t\t\t// Calculate color deltas:\n\t\t\tvec4 delta;\n\t\t\tvec3 C = texture2D( colorTex, texcoord ).rgb;\n\n\t\t\tvec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;\n\t\t\tvec3 t = abs( C - Cleft );\n\t\t\tdelta.x = max( max( t.r, t.g ), t.b );\n\n\t\t\tvec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;\n\t\t\tt = abs( C - Ctop );\n\t\t\tdelta.y = max( max( t.r, t.g ), t.b );\n\n\t\t\t// We do the usual threshold:\n\t\t\tvec2 edges = step( threshold, delta.xy );\n\n\t\t\t// Then discard if there is no edge:\n\t\t\tif ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )\n\t\t\t\tdiscard;\n\n\t\t\t// Calculate right and bottom deltas:\n\t\t\tvec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;\n\t\t\tt = abs( C - Cright );\n\t\t\tdelta.z = max( max( t.r, t.g ), t.b );\n\n\t\t\tvec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;\n\t\t\tt = abs( C - Cbottom );\n\t\t\tdelta.w = max( max( t.r, t.g ), t.b );\n\n\t\t\t// Calculate the maximum delta in the direct neighborhood:\n\t\t\tfloat maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );\n\n\t\t\t// Calculate left-left and top-top deltas:\n\t\t\tvec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;\n\t\t\tt = abs( C - Cleftleft );\n\t\t\tdelta.z = max( max( t.r, t.g ), t.b );\n\n\t\t\tvec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;\n\t\t\tt = abs( C - Ctoptop );\n\t\t\tdelta.w = max( max( t.r, t.g ), t.b );\n\n\t\t\t// Calculate the final maximum delta:\n\t\t\tmaxDelta = max( max( maxDelta, delta.z ), delta.w );\n\n\t\t\t// Local contrast adaptation in action:\n\t\t\tedges.xy *= step( 0.5 * maxDelta, delta.xy );\n\n\t\t\treturn vec4( edges, 0.0, 0.0 );\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );\n\n\t\t}",
					},
					tv = {
						defines: { SMAA_MAX_SEARCH_STEPS: "8", SMAA_AREATEX_MAX_DISTANCE: "16", SMAA_AREATEX_PIXEL_SIZE: "( 1.0 / vec2( 160.0, 560.0 ) )", SMAA_AREATEX_SUBTEX_SIZE: "( 1.0 / 7.0 )" },
						uniforms: { tDiffuse: { value: null }, tArea: { value: null }, tSearch: { value: null }, resolution: { value: new Ot(1 / 1024, 1 / 512) } },
						vertexShader:
							"\n\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 3 ];\n\t\tvarying vec2 vPixcoord;\n\n\t\tvoid SMAABlendingWeightCalculationVS( vec2 texcoord ) {\n\t\t\tvPixcoord = texcoord / resolution;\n\n\t\t\t// We will use these offsets for the searches later on (see @PSEUDO_GATHER4):\n\t\t\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 ); // WebGL port note: Changed sign in Y and W components\n\t\t\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 ); // WebGL port note: Changed sign in Y and W components\n\n\t\t\t// And these for the searches, they indicate the ends of the loops:\n\t\t\tvOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tSMAABlendingWeightCalculationVS( vUv );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
						fragmentShader:
							"\n\n\t\t#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tArea;\n\t\tuniform sampler2D tSearch;\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[3];\n\t\tvarying vec2 vPixcoord;\n\n\t\t#if __VERSION__ == 100\n\t\tvec2 round( vec2 x ) {\n\t\t\treturn sign( x ) * floor( abs( x ) + 0.5 );\n\t\t}\n\t\t#endif\n\n\t\tfloat SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {\n\t\t\t// Not required if searchTex accesses are set to point:\n\t\t\t// float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);\n\t\t\t// e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +\n\t\t\t//     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;\n\t\t\te.r = bias + e.r * scale;\n\t\t\treturn 255.0 * texture2D( searchTex, e, 0.0 ).r;\n\t\t}\n\n\t\tfloat SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\t\t\t/**\n\t\t\t\t* @PSEUDO_GATHER4\n\t\t\t\t* This texcoord has been offset by (-0.25, -0.125) in the vertex shader to\n\t\t\t\t* sample between edge, thus fetching four edges in a row.\n\t\t\t\t* Sampling with different offsets in each direction allows to disambiguate\n\t\t\t\t* which edges are active from the four fetched ones.\n\t\t\t\t*/\n\t\t\tvec2 e = vec2( 0.0, 1.0 );\n\n\t\t\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n\t\t\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\t\t\ttexcoord -= vec2( 2.0, 0.0 ) * resolution;\n\t\t\t\tif ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n\t\t\t}\n\n\t\t\t// We correct the previous (-0.25, -0.125) offset we applied:\n\t\t\ttexcoord.x += 0.25 * resolution.x;\n\n\t\t\t// The searches are bias by 1, so adjust the coords accordingly:\n\t\t\ttexcoord.x += resolution.x;\n\n\t\t\t// Disambiguate the length added by the last step:\n\t\t\ttexcoord.x += 2.0 * resolution.x; // Undo last step\n\t\t\ttexcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);\n\n\t\t\treturn texcoord.x;\n\t\t}\n\n\t\tfloat SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\t\t\tvec2 e = vec2( 0.0, 1.0 );\n\n\t\t\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n\t\t\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\t\t\ttexcoord += vec2( 2.0, 0.0 ) * resolution;\n\t\t\t\tif ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n\t\t\t}\n\n\t\t\ttexcoord.x -= 0.25 * resolution.x;\n\t\t\ttexcoord.x -= resolution.x;\n\t\t\ttexcoord.x -= 2.0 * resolution.x;\n\t\t\ttexcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );\n\n\t\t\treturn texcoord.x;\n\t\t}\n\n\t\tfloat SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\t\t\tvec2 e = vec2( 1.0, 0.0 );\n\n\t\t\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n\t\t\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\t\t\ttexcoord += vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign\n\t\t\t\tif ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n\t\t\t}\n\n\t\t\ttexcoord.y -= 0.25 * resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y -= resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y -= 2.0 * resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 ); // WebGL port note: Changed sign\n\n\t\t\treturn texcoord.y;\n\t\t}\n\n\t\tfloat SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\t\t\tvec2 e = vec2( 1.0, 0.0 );\n\n\t\t\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n\t\t\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\t\t\ttexcoord -= vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign\n\t\t\t\tif ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n\t\t\t}\n\n\t\t\ttexcoord.y += 0.25 * resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y += resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y += 2.0 * resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 ); // WebGL port note: Changed sign\n\n\t\t\treturn texcoord.y;\n\t\t}\n\n\t\tvec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {\n\t\t\t// Rounding prevents precision errors of bilinear filtering:\n\t\t\tvec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;\n\n\t\t\t// We do a scale and bias for mapping to texel space:\n\t\t\ttexcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );\n\n\t\t\t// Move to proper place, according to the subpixel offset:\n\t\t\ttexcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;\n\n\t\t\treturn texture2D( areaTex, texcoord, 0.0 ).rg;\n\t\t}\n\n\t\tvec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {\n\t\t\tvec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );\n\n\t\t\tvec2 e = texture2D( edgesTex, texcoord ).rg;\n\n\t\t\tif ( e.g > 0.0 ) { // Edge at north\n\t\t\t\tvec2 d;\n\n\t\t\t\t// Find the distance to the left:\n\t\t\t\tvec2 coords;\n\t\t\t\tcoords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );\n\t\t\t\tcoords.y = offset[ 1 ].y; // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)\n\t\t\t\td.x = coords.x;\n\n\t\t\t\t// Now fetch the left crossing edges, two at a time using bilinear\n\t\t\t\t// filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to\n\t\t\t\t// discern what value each edge has:\n\t\t\t\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).r;\n\n\t\t\t\t// Find the distance to the right:\n\t\t\t\tcoords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );\n\t\t\t\td.y = coords.x;\n\n\t\t\t\t// We want the distances to be in pixel units (doing this here allow to\n\t\t\t\t// better interleave arithmetic and memory accesses):\n\t\t\t\td = d / resolution.x - pixcoord.x;\n\n\t\t\t\t// SMAAArea below needs a sqrt, as the areas texture is compressed\n\t\t\t\t// quadratically:\n\t\t\t\tvec2 sqrt_d = sqrt( abs( d ) );\n\n\t\t\t\t// Fetch the right crossing edges:\n\t\t\t\tcoords.y -= 1.0 * resolution.y; // WebGL port note: Added\n\t\t\t\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;\n\n\t\t\t\t// Ok, we know how this pattern looks like, now it is time for getting\n\t\t\t\t// the actual area:\n\t\t\t\tweights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );\n\t\t\t}\n\n\t\t\tif ( e.r > 0.0 ) { // Edge at west\n\t\t\t\tvec2 d;\n\n\t\t\t\t// Find the distance to the top:\n\t\t\t\tvec2 coords;\n\n\t\t\t\tcoords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );\n\t\t\t\tcoords.x = offset[ 0 ].x; // offset[1].x = texcoord.x - 0.25 * resolution.x;\n\t\t\t\td.x = coords.y;\n\n\t\t\t\t// Fetch the top crossing edges:\n\t\t\t\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).g;\n\n\t\t\t\t// Find the distance to the bottom:\n\t\t\t\tcoords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );\n\t\t\t\td.y = coords.y;\n\n\t\t\t\t// We want the distances to be in pixel units:\n\t\t\t\td = d / resolution.y - pixcoord.y;\n\n\t\t\t\t// SMAAArea below needs a sqrt, as the areas texture is compressed\n\t\t\t\t// quadratically:\n\t\t\t\tvec2 sqrt_d = sqrt( abs( d ) );\n\n\t\t\t\t// Fetch the bottom crossing edges:\n\t\t\t\tcoords.y -= 1.0 * resolution.y; // WebGL port note: Added\n\t\t\t\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;\n\n\t\t\t\t// Get the area for this direction:\n\t\t\t\tweights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );\n\t\t\t}\n\n\t\t\treturn weights;\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );\n\n\t\t}",
					},
					ev = {
						uniforms: { tDiffuse: { value: null }, tColor: { value: null }, resolution: { value: new Ot(1 / 1024, 1 / 512) } },
						vertexShader:
							"\n\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 2 ];\n\n\t\tvoid SMAANeighborhoodBlendingVS( vec2 texcoord ) {\n\t\t\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 ); // WebGL port note: Changed sign in W component\n\t\t\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tSMAANeighborhoodBlendingVS( vUv );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
						fragmentShader:
							"\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tColor;\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 2 ];\n\n\t\tvec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {\n\t\t\t// Fetch the blending weights for current pixel:\n\t\t\tvec4 a;\n\t\t\ta.xz = texture2D( blendTex, texcoord ).xz;\n\t\t\ta.y = texture2D( blendTex, offset[ 1 ].zw ).g;\n\t\t\ta.w = texture2D( blendTex, offset[ 1 ].xy ).a;\n\n\t\t\t// Is there any blending weight with a value greater than 0.0?\n\t\t\tif ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {\n\t\t\t\treturn texture2D( colorTex, texcoord, 0.0 );\n\t\t\t} else {\n\t\t\t\t// Up to 4 lines can be crossing a pixel (one through each edge). We\n\t\t\t\t// favor blending by choosing the line with the maximum weight for each\n\t\t\t\t// direction:\n\t\t\t\tvec2 offset;\n\t\t\t\toffset.x = a.a > a.b ? a.a : -a.b; // left vs. right\n\t\t\t\toffset.y = a.g > a.r ? -a.g : a.r; // top vs. bottom // WebGL port note: Changed signs\n\n\t\t\t\t// Then we go in the direction that has the maximum weight:\n\t\t\t\tif ( abs( offset.x ) > abs( offset.y )) { // horizontal vs. vertical\n\t\t\t\t\toffset.y = 0.0;\n\t\t\t\t} else {\n\t\t\t\t\toffset.x = 0.0;\n\t\t\t\t}\n\n\t\t\t\t// Fetch the opposite color and lerp by hand:\n\t\t\t\tvec4 C = texture2D( colorTex, texcoord, 0.0 );\n\t\t\t\ttexcoord += sign( offset ) * resolution;\n\t\t\t\tvec4 Cop = texture2D( colorTex, texcoord, 0.0 );\n\t\t\t\tfloat s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );\n\n\t\t\t\t// WebGL port note: Added gamma correction\n\t\t\t\tC.xyz = pow(C.xyz, vec3(2.2));\n\t\t\t\tCop.xyz = pow(Cop.xyz, vec3(2.2));\n\t\t\t\tvec4 mixed = mix(C, Cop, s);\n\t\t\t\tmixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));\n\n\t\t\t\treturn mixed;\n\t\t\t}\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );\n\n\t\t}",
					};
				class nv extends Gm {
					constructor(t, e) {
						super(), (this.edgesRT = new Gt(t, e, { depthBuffer: !1, generateMipmaps: !1, minFilter: X, format: tt })), (this.edgesRT.texture.name = "SMAAPass.edges"), (this.weightsRT = new Gt(t, e, { depthBuffer: !1, generateMipmaps: !1, minFilter: X, format: et })), (this.weightsRT.texture.name = "SMAAPass.weights");
						const n = this,
							i = new Image();
						(i.src = this.getAreaTexture()),
							(i.onload = function () {
								n.areaTexture.needsUpdate = !0;
							}),
							(this.areaTexture = new Ft()),
							(this.areaTexture.name = "SMAAPass.area"),
							(this.areaTexture.image = i),
							(this.areaTexture.format = tt),
							(this.areaTexture.minFilter = X),
							(this.areaTexture.generateMipmaps = !1),
							(this.areaTexture.flipY = !1);
						const r = new Image();
						(r.src = this.getSearchTexture()),
							(r.onload = function () {
								n.searchTexture.needsUpdate = !0;
							}),
							(this.searchTexture = new Ft()),
							(this.searchTexture.name = "SMAAPass.search"),
							(this.searchTexture.image = r),
							(this.searchTexture.magFilter = G),
							(this.searchTexture.minFilter = G),
							(this.searchTexture.generateMipmaps = !1),
							(this.searchTexture.flipY = !1),
							void 0 === $m && console.error("THREE.SMAAPass relies on SMAAShader"),
							(this.uniformsEdges = $n.clone($m.uniforms)),
							this.uniformsEdges.resolution.value.set(1 / t, 1 / e),
							(this.materialEdges = new ti({ defines: Object.assign({}, $m.defines), uniforms: this.uniformsEdges, vertexShader: $m.vertexShader, fragmentShader: $m.fragmentShader })),
							(this.uniformsWeights = $n.clone(tv.uniforms)),
							this.uniformsWeights.resolution.value.set(1 / t, 1 / e),
							(this.uniformsWeights.tDiffuse.value = this.edgesRT.texture),
							(this.uniformsWeights.tArea.value = this.areaTexture),
							(this.uniformsWeights.tSearch.value = this.searchTexture),
							(this.materialWeights = new ti({ defines: Object.assign({}, tv.defines), uniforms: this.uniformsWeights, vertexShader: tv.vertexShader, fragmentShader: tv.fragmentShader })),
							(this.uniformsBlend = $n.clone(ev.uniforms)),
							this.uniformsBlend.resolution.value.set(1 / t, 1 / e),
							(this.uniformsBlend.tDiffuse.value = this.weightsRT.texture),
							(this.materialBlend = new ti({ uniforms: this.uniformsBlend, vertexShader: ev.vertexShader, fragmentShader: ev.fragmentShader })),
							(this.needsSwap = !1),
							(this.fsQuad = new Xm(null));
					}
					render(t, e, n) {
						(this.uniformsEdges.tDiffuse.value = n.texture),
							(this.fsQuad.material = this.materialEdges),
							t.setRenderTarget(this.edgesRT),
							this.clear && t.clear(),
							this.fsQuad.render(t),
							(this.fsQuad.material = this.materialWeights),
							t.setRenderTarget(this.weightsRT),
							this.clear && t.clear(),
							this.fsQuad.render(t),
							(this.uniformsBlend.tColor.value = n.texture),
							(this.fsQuad.material = this.materialBlend),
							this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(), this.fsQuad.render(t));
					}
					setSize(t, e) {
						this.edgesRT.setSize(t, e), this.weightsRT.setSize(t, e), this.materialEdges.uniforms.resolution.value.set(1 / t, 1 / e), this.materialWeights.uniforms.resolution.value.set(1 / t, 1 / e), this.materialBlend.uniforms.resolution.value.set(1 / t, 1 / e);
					}
					getAreaTexture() {
						return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAIAAACOVPcQAACBeklEQVR42u39W4xlWXrnh/3WWvuciIzMrKxrV8/0rWbY0+SQFKcb4owIkSIFCjY9AC1BT/LYBozRi+EX+cV+8IMsYAaCwRcBwjzMiw2jAWtgwC8WR5Q8mDFHZLNHTarZGrLJJllt1W2qKrsumZWZcTvn7L3W54e1vrXX3vuciLPPORFR1XE2EomorB0nVuz//r71re/y/1eMvb4Cb3N11xV/PP/2v4UBAwJG/7H8urx6/25/Gf8O5hypMQ0EEEQwAqLfoN/Z+97f/SW+/NvcgQk4sGBJK6H7N4PFVL+K+e0N11yNfkKvwUdwdlUAXPHHL38oa15f/i/46Ih6SuMSPmLAYAwyRKn7dfMGH97jaMFBYCJUgotIC2YAdu+LyW9vvubxAP8kAL8H/koAuOKP3+q6+xGnd5kdYCeECnGIJViwGJMAkQKfDvB3WZxjLKGh8VSCCzhwEWBpMc5/kBbjawT4HnwJfhr+pPBIu7uu+OOTo9vsmtQcniMBGkKFd4jDWMSCRUpLjJYNJkM+IRzQ+PQvIeAMTrBS2LEiaiR9b/5PuT6Ap/AcfAFO4Y3dA3DFH7/VS+M8k4baEAQfMI4QfbVDDGIRg7GKaIY52qAjTAgTvGBAPGIIghOCYAUrGFNgzA7Q3QhgCwfwAnwe5vDejgG44o/fbm1C5ZlYQvQDARPAIQGxCWBM+wWl37ZQESb4gImexGMDouhGLx1Cst0Saa4b4AqO4Hk4gxo+3DHAV/nx27p3JziPM2pVgoiia5MdEzCGULprIN7gEEeQ5IQxEBBBQnxhsDb5auGmAAYcHMA9eAAz8PBol8/xij9+C4Djlim4gJjWcwZBhCBgMIIYxGAVIkH3ZtcBuLdtRFMWsPGoY9rN+HoBji9VBYdwD2ZQg4cnO7OSq/z4rU5KKdwVbFAjNojCQzTlCLPFSxtamwh2jMUcEgg2Wm/6XgErIBhBckQtGN3CzbVacERgCnfgLswhnvqf7QyAq/z4rRZm1YglYE3affGITaZsdIe2FmMIpnOCap25I6jt2kCwCW0D1uAD9sZctNGXcQIHCkINDQgc78aCr+zjtw3BU/ijdpw3zhCwcaONwBvdeS2YZKkJNJsMPf2JKEvC28RXxxI0ASJyzQCjCEQrO4Q7sFArEzjZhaFc4cdv+/JFdKULM4px0DfUBI2hIsy06BqLhGTQEVdbfAIZXYMPesq6VoCHICzUyjwInO4Y411//LYLs6TDa9wvg2CC2rElgAnpTBziThxaL22MYhzfkghz6GAs2VHbbdM91VZu1MEEpupMMwKyVTb5ij9+u4VJG/5EgEMMmFF01cFai3isRbKbzb+YaU/MQbAm2XSMoUPAmvZzbuKYRIFApbtlrfFuUGd6vq2hXNnH78ZLh/iFhsQG3T4D1ib7k5CC6vY0DCbtrohgLEIClXiGtl10zc0CnEGIhhatLBva7NP58Tvw0qE8yWhARLQ8h4+AhQSP+I4F5xoU+VilGRJs6wnS7ruti/4KvAY/CfdgqjsMy4pf8fodQO8/gnuX3f/3xi3om1/h7THr+co3x93PP9+FBUfbNUjcjEmhcrkT+8K7ml7V10Jo05mpIEFy1NmCJWx9SIKKt+EjAL4Ez8EBVOB6havuT/rByPvHXK+9zUcfcbb254+9fydJknYnRr1oGfdaiAgpxu1Rx/Rek8KISftx3L+DfsLWAANn8Hvw0/AFeAGO9DFV3c6D+CcWbL8Dj9e7f+T1k8AZv/d7+PXWM/Z+VvdCrIvuAKO09RpEEQJM0Ci6+B4xhTWr4cZNOvhktabw0ta0rSJmqz3Yw5/AKXwenod7cAhTmBSPKf6JBdvH8IP17h95pXqw50/+BFnj88fev4NchyaK47OPhhtI8RFSvAfDSNh0Ck0p2gLxGkib5NJj/JWCr90EWQJvwBzO4AHcgztwAFN1evHPUVGwfXON+0debT1YeGON9Yy9/63X+OguiwmhIhQhD7l4sMqlG3D86Suc3qWZ4rWjI1X7u0Ytw6x3rIMeIOPDprfe2XzNgyj6PahhBjO4C3e6puDgXrdg+/5l948vF3bqwZetZ+z9Rx9zdIY5pInPK4Nk0t+l52xdK2B45Qd87nM8fsD5EfUhIcJcERw4RdqqH7Yde5V7m1vhNmtedkz6EDzUMF/2jJYWbC+4fzzA/Y+/8PPH3j9dcBAPIRP8JLXd5BpAu03aziOL3VVHZzz3CXWDPWd+SH2AnxIqQoTZpo9Ckc6HIrFbAbzNmlcg8Ag8NFDDAhbJvTBZXbC94P7t68EXfv6o+21gUtPETU7bbkLxvNKRFG2+KXzvtObonPP4rBvsgmaKj404DlshFole1Glfh02fE7bYR7dZ82oTewIBGn1Md6CG6YUF26X376oevOLzx95vhUmgblI6LBZwTCDY7vMq0op5WVXgsObOXJ+1x3qaBl9j1FeLxbhU9w1F+Wiba6s1X/TBz1LnUfuYDi4r2C69f1f14BWfP+p+W2GFKuC9phcELMYRRLur9DEZTUdEH+iEqWdaM7X4WOoPGI+ZYD2+wcQ+y+ioHUZ9dTDbArzxmi/bJI9BND0Ynd6lBdve/butBw8+f/T9D3ABa3AG8W3VPX4hBin+bj8dMMmSpp5pg7fJ6xrBFE2WQQEWnV8Qg3FbAWzYfM1rREEnmvkN2o1+acG2d/9u68GDzx91v3mAjb1zkpqT21OipPKO0b9TO5W0nTdOmAQm0TObts3aBKgwARtoPDiCT0gHgwnbArzxmtcLc08HgF1asN0C4Ms/fvD5I+7PhfqyXE/b7RbbrGyRQRT9ARZcwAUmgdoz0ehJ9Fn7QAhUjhDAQSw0bV3T3WbNa59jzmiP6GsWbGXDX2ytjy8+f9T97fiBPq9YeLdBmyuizZHaqXITnXiMUEEVcJ7K4j3BFPurtB4bixW8wTpweL8DC95szWMOqucFYGsWbGU7p3TxxxefP+r+oTVktxY0v5hbq3KiOKYnY8ddJVSBxuMMVffNbxwIOERShst73HZ78DZrHpmJmH3K6sGz0fe3UUj0eyRrSCGTTc+rjVNoGzNSv05srAxUBh8IhqChiQgVNIIBH3AVPnrsnXQZbLTm8ammv8eVXn/vWpaTem5IXRlt+U/LA21zhSb9cye6jcOfCnOwhIAYXAMVTUNV0QhVha9xjgA27ODJbLbmitt3tRN80lqG6N/khgot4ZVlOyO4WNg3OIMzhIZQpUEHieg2im6F91hB3I2tubql6BYNN9Hj5S7G0G2tahslBWKDnOiIvuAEDzakDQKDNFQT6gbn8E2y4BBubM230YIpBnDbMa+y3dx0n1S0BtuG62lCCXwcY0F72T1VRR3t2ONcsmDjbmzNt9RFs2LO2hQNyb022JisaI8rAWuw4HI3FuAIhZdOGIcdjLJvvObqlpqvWTJnnQbyi/1M9O8UxWhBs//H42I0q1Yb/XPGONzcmm+ri172mHKvZBpHkJaNJz6v9jxqiklDj3U4CA2ugpAaYMWqNXsdXbmJNd9egCnJEsphXNM+MnK3m0FCJ5S1kmJpa3DgPVbnQnPGWIDspW9ozbcO4K/9LkfaQO2KHuqlfFXSbdNzcEcwoqNEFE9zcIXu9/6n/ym/BC/C3aJLzEKPuYVlbFnfhZ8kcWxV3dbv4bKl28566wD+8C53aw49lTABp9PWbsB+knfc/Li3eVizf5vv/xmvnPKg5ihwKEwlrcHqucuVcVOxEv8aH37E3ZqpZypUulrHEtIWKUr+txHg+ojZDGlwnqmkGlzcVi1dLiNSJiHjfbRNOPwKpx9TVdTn3K05DBx4psIk4Ei8aCkJahRgffk4YnEXe07T4H2RR1u27E6wfQsBDofUgjFUFnwC2AiVtA+05J2zpiDK2Oa0c5fmAecN1iJzmpqFZxqYBCYhFTCsUNEmUnIcZ6aEA5rQVhEywG6w7HSW02XfOoBlQmjwulOFQAg66SvJblrTEX1YtJ3uG15T/BH1OfOQeuR8g/c0gdpT5fx2SKbs9EfHTKdM8A1GaJRHLVIwhcGyydZsbifAFVKl5EMKNU2Hryo+06BeTgqnxzYjThVySDikbtJPieco75lYfKAJOMEZBTjoITuWHXXZVhcUDIS2hpiXHV9Ku4u44bN5OYLDOkJo8w+xJSMbhBRHEdEs9JZUCkQrPMAvaHyLkxgkEHxiNkx/x2YB0mGsQ8EUWj/stW5YLhtS5SMu+/YBbNPDCkGTUybN8krRLBGPlZkVOA0j+a1+rkyQKWGaPHPLZOkJhioQYnVZ2hS3zVxMtgC46KuRwbJNd9nV2PHgb36F194ecf/Yeu2vAFe5nm/bRBFrnY4BauE8ERmZRFUn0k8hbftiVYSKMEme2dJCJSCGYAlNqh87bXOPdUkGy24P6d1ll21MBqqx48Fvv8ZHH8HZFY7j/uAq1xMJUFqCSUlJPmNbIiNsmwuMs/q9CMtsZsFO6SprzCS1Z7QL8xCQClEelpjTduDMsmWD8S1PT152BtvmIGvUeDA/yRn83u/x0/4qxoPHjx+PXY9pqX9bgMvh/Nz9kpP4pOe1/fYf3axUiMdHLlPpZCNjgtNFAhcHEDxTumNONhHrBduW+vOyY++70WWnPXj98eA4kOt/mj/5E05l9+O4o8ePx67HFqyC+qSSnyselqjZGaVK2TadbFLPWAQ4NBhHqDCCV7OTpo34AlSSylPtIdd2AJZlyzYQrDJ5lcWGNceD80CunPLGGzsfD+7wRb95NevJI5docQ3tgCyr5bGnyaPRlmwNsFELViOOx9loebGNq2moDOKpHLVP5al2cymWHbkfzGXL7kfRl44H9wZy33tvt+PB/Xnf93e+nh5ZlU18wCiRUa9m7kib9LYuOk+hudQNbxwm0AQqbfloimaB2lM5fChex+ylMwuTbfmXQtmWlenZljbdXTLuOxjI/fDDHY4Hjx8/Hrse0zXfPFxbUN1kKqSCCSk50m0Ajtx3ub9XHBKHXESb8iO6E+qGytF4nO0OG3SXzbJlhxBnKtKyl0NwybjvYCD30aMdjgePHz8eu56SVTBbgxJMliQ3Oauwg0QHxXE2Ez/EIReLdQj42Gzb4CLS0YJD9xUx7bsi0vJi5mUbW1QzL0h0PFk17rtiIPfJk52MB48fPx67npJJwyrBa2RCCQRTbGZSPCxTPOiND4G2pYyOQ4h4jINIJh5wFU1NFZt+IsZ59LSnDqBjZ2awbOku+yInunLcd8VA7rNnOxkPHj9+PGY9B0MWJJNozOJmlglvDMXDEozdhQWbgs/U6oBanGzLrdSNNnZFjOkmbi5bNt1lX7JLLhn3vXAg9/h4y/Hg8ePHI9dzQMEkWCgdRfYykYKnkP7D4rIujsujaKPBsB54vE2TS00ccvFY/Tth7JXeq1hz+qgVy04sAJawTsvOknHfCwdyT062HA8eP348Zj0vdoXF4pilKa2BROed+9fyw9rWRXeTFXESMOanvDZfJuJaSXouQdMdDJZtekZcLLvEeK04d8m474UDuaenW44Hjx8/Xns9YYqZpszGWB3AN/4VHw+k7WSFtJ3Qicuqb/NlVmgXWsxh570xg2UwxUw3WfO6B5nOuO8aA7lnZxuPB48fPx6znm1i4bsfcbaptF3zNT78eFPtwi1OaCNOqp1x3zUGcs/PN++AGD1+fMXrSVm2baTtPhPahbPhA71wIHd2bXzRa69nG+3CraTtPivahV/55tXWg8fyRY/9AdsY8VbSdp8V7cKrrgdfM//z6ILQFtJ2nxHtwmuoB4/kf74+gLeRtvvMaBdeSz34+vifx0YG20jbfTa0C6+tHrwe//NmOG0L8EbSdp8R7cLrrQe/996O+ai3ujQOskpTNULa7jOjXXj99eCd8lHvoFiwsbTdZ0a78PrrwTvlo966pLuRtB2fFe3Cm6oHP9kNH/W2FryxtN1nTLvwRurBO+Kj3pWXHidtx2dFu/Bm68Fb81HvykuPlrb7LGkX3mw9eGs+6h1Y8MbSdjegXcguQLjmevDpTQLMxtJ2N6NdyBZu9AbrwVvwUW+LbteULUpCdqm0HTelXbhNPe8G68Gb8lFvVfYfSNuxvrTdTWoXbozAzdaDZzfkorOj1oxVxlIMlpSIlpLrt8D4hrQL17z+c3h6hU/wv4Q/utps4+bm+6P/hIcf0JwQ5oQGPBL0eKPTYEXTW+eL/2DKn73J9BTXYANG57hz1cEMviVf/4tf5b/6C5pTQkMIWoAq7hTpOJjtAM4pxKu5vg5vXeUrtI09/Mo/5H+4z+Mp5xULh7cEm2QbRP2tFIKR7WM3fPf/jZ3SWCqLM2l4NxID5zB72HQXv3jj/8mLR5xXNA5v8EbFQEz7PpRfl1+MB/hlAN65qgDn3wTgH13hK7T59bmP+NIx1SHHU84nLOITt3iVz8mNO+lPrjGAnBFqmioNn1mTyk1ta47R6d4MrX7tjrnjYUpdUbv2rVr6YpVfsGG58AG8Ah9eyUN8CX4WfgV+G8LVWPDGb+Zd4cU584CtqSbMKxauxTg+dyn/LkVgA+IR8KHtejeFKRtTmLLpxN6mYVLjYxwXf5x2VofiZcp/lwKk4wGOpYDnoIZPdg/AAbwMfx0+ge9dgZvYjuqKe4HnGnykYo5TvJbG0Vj12JagRhwKa44H95ShkZa5RyLGGdfYvG7aw1TsF6iapPAS29mNS3NmsTQZCmgTzFwgL3upCTgtBTRwvGMAKrgLn4evwin8+afJRcff+8izUGUM63GOOuAs3tJkw7J4kyoNreqrpO6cYLQeFUd7TTpr5YOTLc9RUUogUOVJQ1GYJaFLAW0oTmKyYS46ZooP4S4EON3xQ5zC8/CX4CnM4c1PE8ApexpoYuzqlP3d4S3OJP8ZDK7cKWNaTlqmgDiiHwl1YsE41w1zT4iRTm3DBqxvOUsbMKKDa/EHxagtnta072ejc3DOIh5ojvh8l3tk1JF/AV6FU6jh3U8HwEazLgdCLYSQ+MYiAI2ltomkzttUb0gGHdSUUgsIYjTzLG3mObX4FBRaYtpDVNZrih9TgTeYOBxsEnN1gOCTM8Bsw/ieMc75w9kuAT6A+/AiHGvN/+Gn4KRkiuzpNNDYhDGFndWRpE6SVfm8U5bxnSgVV2jrg6JCKmneqey8VMFgq2+AM/i4L4RUbfSi27lNXZ7R7W9RTcq/q9fk4Xw3AMQd4I5ifAZz8FcVtm9SAom/dyN4lczJQW/kC42ZrHgcCoIf1oVMKkVItmMBi9cOeNHGLqOZk+QqQmrbc5YmYgxELUUN35z2iohstgfLIFmcMV7s4CFmI74L9+EFmGsi+tGnAOD4Yk9gIpo01Y4cA43BWGygMdr4YZekG3OBIUXXNukvJS8tqa06e+lSDCtnqqMFu6hWHXCF+WaYt64m9QBmNxi7Ioy7D+fa1yHw+FMAcPt7SysFLtoG4PXAk7JOA3aAxBRqUiAdU9Yp5lK3HLSRFtOim0sa8euEt08xvKjYjzeJ2GU7YawexrnKI9tmobInjFXCewpwriY9+RR4aaezFhMhGCppKwom0ChrgFlKzyPKkGlTW1YQrE9HJqu8hKGgMc6hVi5QRq0PZxNfrYNgE64utmRv6KKHRpxf6VDUaOvNP5jCEx5q185My/7RKz69UQu2im5k4/eownpxZxNLwiZ1AZTO2ZjWjkU9uaB2HFn6Q3u0JcsSx/qV9hTEApRzeBLDJQXxYmTnq7bdLa3+uqFrxLJ5w1TehnNHx5ECvCh2g2c3hHH5YsfdaSKddztfjQ6imKFGSyFwlLzxEGPp6r5IevVjk1AMx3wMqi1NxDVjLBiPs9tbsCkIY5we5/ML22zrCScFxnNtzsr9Wcc3CnD+pYO+4VXXiDE0oc/vQQ/fDK3oPESJMYXNmJa/DuloJZkcTpcYE8lIH8Dz8DJMiynNC86Mb2lNaaqP/+L7f2fcE/yP7/Lde8xfgSOdMxvOixZf/9p3+M4hT1+F+zApxg9XfUvYjc8qX2lfOOpK2gNRtB4flpFu9FTKCp2XJRgXnX6olp1zyYjTKJSkGmLE2NjUr1bxFM4AeAAHBUFIeSLqXR+NvH/M9fOnfHzOD2vCSyQJKzfgsCh+yi/Mmc35F2fUrw7miW33W9hBD1vpuUojFphIyvg7aTeoymDkIkeW3XLHmguMzbIAJejN6B5MDrhipE2y6SoFRO/AK/AcHHZHNIfiWrEe/C6cr3f/yOvrQKB+zMM55/GQdLDsR+ifr5Fiuu+/y+M78LzOE5dsNuXC3PYvYWd8NXvphLSkJIasrlD2/HOqQ+RjcRdjKTGWYhhVUm4yxlyiGPuMsZR7sMCHUBeTuNWA7if+ifXgc/hovftHXs/DV+Fvwe+f8shzMiMcweFgBly3//vwJfg5AN4450fn1Hd1Rm1aBLu22Dy3y3H2+OqMemkbGZ4jozcDjJf6596xOLpC0eMTHbKnxLxH27uZ/bMTGs2jOaMOY4m87CfQwF0dw53oa1k80JRuz/XgS+8fX3N9Af4qPIMfzKgCp4H5TDGe9GGeFPzSsZz80SlPTxXjgwJmC45njzgt2vbQ4b4OAdUK4/vWhO8d8v6EE8fMUsfakXbPpFJeLs2ubM/qdm/la3WP91uWhxXHjoWhyRUq2iJ/+5mA73zwIIo+LoZ/SgvIRjAd1IMvvn98PfgOvAJfhhm8scAKVWDuaRaK8aQ9f7vuPDH6Bj47ZXau7rqYJ66mTDwEDU6lLbCjCK0qTXyl5mnDoeNRxanj3FJbaksTk0faXxHxLrssgPkWB9LnA/MFleXcJozzjwsUvUG0X/QCve51qkMDXp9mtcyOy3rwBfdvVJK7D6/ACSzg3RoruIq5UDeESfEmVclDxnniU82vxMLtceD0hGZWzBNPMM/jSPne2OVatiTKUpY5vY7gc0LdUAWeWM5tH+O2I66AOWw9xT2BuyRVLGdoDHUsVRXOo/c+ZdRXvFfnxWyIV4upFLCl9eAL7h8Zv0QH8Ry8pA2cHzQpGesctVA37ZtklBTgHjyvdSeKY/RZw/kJMk0Y25cSNRWSigQtlULPTw+kzuJPeYEkXjQRpoGZobYsLF79pyd1dMRHInbgFTZqNLhDqiIsTNpoex2WLcy0/X6rHcdMMQvFSd5dWA++4P7xv89deACnmr36uGlL69bRCL6BSZsS6c0TU2TKK5gtWCzgAOOwQcurqk9j8whvziZSMLcq5hbuwBEsYjopUBkqw1yYBGpLA97SRElEmx5MCInBY5vgLk94iKqSWmhIGmkJ4Bi9m4L645J68LyY4wsFYBfUg5feP/6gWWm58IEmKQM89hq7KsZNaKtP5TxxrUZZVkNmMJtjbKrGxLNEbHPJxhqy7lAmbC32ZqeF6lTaknRWcYaFpfLUBh/rwaQycCCJmW15Kstv6jRHyJFry2C1ahkkIW0LO75s61+owxK1y3XqweX9m5YLM2DPFeOjn/iiqCKJ+yKXF8t5Yl/kNsqaSCryxPq5xWTFIaP8KSW0RYxqupaUf0RcTNSSdJZGcKYdYA6kdtrtmyBckfKXwqk0pHpUHlwWaffjNRBYFPUDWa8e3Lt/o0R0CdisKDM89cX0pvRHEfM8ca4t0s2Xx4kgo91MPQJ/0c9MQYq0co8MBh7bz1fio0UUHLR4aAIOvOmoYO6kwlEVODSSTliWtOtH6sPkrtctF9ZtJ9GIerBskvhdVS5cFNv9s1BU0AbdUgdK4FG+dRnjFmDTzniRMdZO1QhzMK355vigbdkpz9P6qjUGE5J2qAcXmwJ20cZUiAD0z+pGMx6xkzJkmEf40Hr4qZfVg2XzF9YOyoV5BjzVkUJngKf8lgNYwKECEHrCNDrWZzMlflS3yBhr/InyoUgBc/lKT4pxVrrC6g1YwcceK3BmNxZcAtz3j5EIpqguh9H6wc011YN75cKDLpFDxuwkrPQmUwW4KTbj9mZTwBwLq4aQMUZbHm1rylJ46dzR0dua2n3RYCWZsiHROeywyJGR7mXKlpryyCiouY56sFkBWEnkEB/raeh/Sw4162KeuAxMQpEkzy5alMY5wamMsWKKrtW2WpEWNnReZWONKWjrdsKZarpFjqCslq773PLmEhM448Pc3+FKr1+94vv/rfw4tEcu+lKTBe4kZSdijBrykwv9vbCMPcLQTygBjzVckSLPRVGslqdunwJ4oegtFOYb4SwxNgWLCmD7T9kVjTv5YDgpo0XBmN34Z/rEHp0sgyz7lngsrm4lvMm2Mr1zNOJYJ5cuxuQxwMGJq/TP5emlb8fsQBZviK4t8hFL+zbhtlpwaRSxQRWfeETjuauPsdGxsBVdO7nmP4xvzSoT29pRl7kGqz+k26B3Oy0YNV+SXbbQas1ctC/GarskRdFpKczVAF1ZXnLcpaMuzVe6lZ2g/1ndcvOVgRG3sdUAY1bKD6achijMPdMxV4muKVorSpiDHituH7rSTs7n/4y5DhRXo4FVBN4vO/zbAcxhENzGbHCzU/98Mcx5e7a31kWjw9FCe/zNeYyQjZsWb1uc7U33pN4Mji6hCLhivqfa9Ss6xLg031AgfesA/l99m9fgvnaF9JoE6bYKmkGNK3aPbHB96w3+DnxFm4hs0drLsk7U8kf/N/CvwQNtllna0rjq61sH8L80HAuvwH1tvBy2ChqWSCaYTaGN19sTvlfzFD6n+iKTbvtayfrfe9ueWh6GJFoxLdr7V72a5ZpvHcCPDzma0wTO4EgbLyedxstO81n57LYBOBzyfsOhUKsW1J1BB5vr/tz8RyqOFylQP9Tvst2JALsC5lsH8PyQ40DV4ANzYa4dedNiKNR1s+x2wwbR7q4/4cTxqEk4LWDebfisuo36JXLiWFjOtLrlNWh3K1rRS4xvHcDNlFnNmWBBAl5SWaL3oPOfnvbr5pdjVnEaeBJSYjuLEkyLLsWhKccadmOphZkOPgVdalj2QpSmfOsADhMWE2ZBu4+EEJI4wKTAuCoC4xwQbWXBltpxbjkXJtKxxabo9e7tyhlgb6gNlSbUpMh+l/FaqzVwewGu8BW1Zx7pTpQDJUjb8tsUTW6+GDXbMn3mLbXlXJiGdggxFAoUrtPS3wE4Nk02UZG2OOzlk7fRs7i95QCLo3E0jtrjnM7SR3uS1p4qtS2nJ5OwtQVHgOvArLBFijZUV9QtSl8dAY5d0E0hM0w3HS2DpIeB6m/A1+HfhJcGUq4sOxH+x3f5+VO+Ds9rYNI7zPXOYWPrtf8bYMx6fuOAX5jzNR0PdsuON+X1f7EERxMJJoU6GkTEWBvVolVlb5lh3tKCg6Wx1IbaMDdJ+9sUCc5KC46hKGCk3IVOS4TCqdBNfUs7Kd4iXf2RjnT/LLysJy3XDcHLh/vde3x8DoGvwgsa67vBk91G5Pe/HbOe7xwym0NXbtiuuDkGO2IJDh9oQvJ4cY4vdoqLDuoH9Zl2F/ofsekn8lkuhIlhQcffUtSjytFyp++p6NiE7Rqx/lodgKVoceEp/CP4FfjrquZaTtj2AvH5K/ywpn7M34K/SsoYDAdIN448I1/0/wveW289T1/lX5xBzc8N5IaHr0XMOQdHsIkDuJFifj20pBm5jzwUv9e2FhwRsvhAbalCIuIw3bhJihY3p6nTFFIZgiSYjfTf3aXuOjmeGn4bPoGvwl+CFzTRczBIuHBEeImHc37/lGfwZR0cXzVDOvaKfNHvwe+suZ771K/y/XcBlsoN996JpBhoE2toYxOznNEOS5TJc6Id5GEXLjrWo+LEWGNpPDU4WAwsIRROu+1vM+0oW37z/MBN9kqHnSArwPfgFJ7Cq/Ai3Ie7g7ncmI09v8sjzw9mzOAEXoIHxURueaAce5V80f/DOuuZwHM8vsMb5wBzOFWM7wymTXPAEvm4vcFpZ2ut0VZRjkiP2MlmLd6DIpbGSiHOjdnUHN90hRYmhTnmvhzp1iKDNj+b7t5hi79lWGwQ+HN9RsfFMy0FXbEwhfuczKgCbyxYwBmcFhhvo/7a44v+i3XWcwDP86PzpGQYdWh7csP5dBvZ1jNzdxC8pBGuxqSW5vw40nBpj5JhMwvOzN0RWqERHMr4Lv1kWX84xLR830G3j6yqZ1a8UstTlW+qJPOZ+sZ7xZPKTJLhiNOAFd6tk+jrTH31ncLOxid8+nzRb128HhUcru/y0Wn6iT254YPC6FtVSIMoW2sk727AhvTtrWKZTvgsmckfXYZWeNRXx/3YQ2OUxLDrbHtN11IwrgXT6c8dATDwLniYwxzO4RzuQqTKSC5gAofMZ1QBK3zQ4JWobFbcvJm87FK+6JXrKahLn54m3p+McXzzYtP8VF/QpJuh1OwieElEoI1pRxPS09FBrkq2tWCU59+HdhNtTIqKm8EBrw2RTOEDpG3IKo2Y7mFdLm3ZeVjYwVw11o/oznceMve4CgMfNym/utA/d/ILMR7gpXzRy9eDsgLcgbs8O2Va1L0zzIdwGGemTBuwROHeoMShkUc7P+ISY3KH5ZZeWqO8mFTxQYeXTNuzvvK5FGPdQfuu00DwYFY9dyhctEt+OJDdnucfpmyhzUJzfsJjr29l8S0bXBfwRS9ZT26tmMIdZucch5ZboMz3Nio3nIOsYHCGoDT4kUA9MiXEp9Xsui1S8th/kbWIrMBxDGLodWUQIWcvnXy+9M23xPiSMOiRPqM+YMXkUN3gXFrZJwXGzUaMpJfyRS9ZT0lPe8TpScuRlbMHeUmlaKDoNuy62iWNTWNFYjoxFzuJs8oR+RhRx7O4SVNSXpa0ZJQ0K1LAHDQ+D9IepkMXpcsq5EVCvClBUIzDhDoyKwDw1Lc59GbTeORivugw1IcuaEOaGWdNm+Ps5fQ7/tm0DjMegq3yM3vb5j12qUId5UZD2oxDSEWOZMSqFl/W+5oynWDa/aI04tJRQ2eTXusg86SQVu/nwSYwpW6wLjlqIzwLuxGIvoAvul0PS+ZNz0/akp/pniO/8JDnGyaCkzbhl6YcqmK/69prxPqtpx2+Km9al9sjL+rwMgHw4jE/C8/HQ3m1vBuL1fldbzd8mOueVJ92syqdEY4KJjSCde3mcRw2TA6szxedn+zwhZMps0XrqEsiUjnC1hw0TELC2Ek7uAAdzcheXv1BYLagspxpzSAoZZUsIzIq35MnFQ9DOrlNB30jq3L4pkhccKUAA8/ocvN1Rzx9QyOtERs4CVsJRK/DF71kPYrxYsGsm6RMh4cps5g1DOmM54Ly1ii0Hd3Y/BMk8VWFgBVmhqrkJCPBHAolwZaWzLR9Vb7bcWdX9NyUYE+uB2BKfuaeBUcjDljbYVY4DdtsVWvzRZdWnyUzDpjNl1Du3aloAjVJTNDpcIOVVhrHFF66lLfJL1zJr9PQ2nFJSBaKoDe+sAvLufZVHVzYh7W0h/c6AAZ+7Tvj6q9j68G/cTCS/3n1vLKHZwNi+P+pS0WkZNMBMUl+LDLuiE4omZy71r3UFMwNJV+VJ/GC5ixVUkBStsT4gGKh0Gm4Oy3qvq7Lbmq24nPdDuDR9deR11XzP4vFu3TYzfnIyiSVmgizUYGqkIXNdKTY9pgb9D2Ix5t0+NHkVzCdU03suWkkVZAoCONCn0T35gAeW38de43mf97sMOpSvj4aa1KYUm58USI7Wxxes03bAZdRzk6UtbzMaCQ6IxO0dy7X+XsjoD16hpsBeGz9dfzHj+R/Hp8nCxZRqkEDTaCKCSywjiaoMJ1TITE9eg7Jqnq8HL6gDwiZb0u0V0Rr/rmvqjxKuaLCX7ZWXTvAY+uvm3z8CP7nzVpngqrJpZKwWnCUjIviYVlirlGOzPLI3SMVyp/elvBUjjDkNhrtufFFErQ8pmdSlbK16toBHlt/HV8uHMX/vEGALkV3RJREiSlopxwdMXOZPLZ+ix+kAHpMKIk8UtE1ygtquttwxNhphrIZ1IBzjGF3IIGxGcBj6q8bHJBG8T9vdsoWrTFEuebEZuVxhhClH6P5Zo89OG9fwHNjtNQTpD0TG9PJLEYqvEY6Rlxy+ZZGfL0Aj62/bnQCXp//eeM4KzfQVJbgMQbUjlMFIm6TpcfWlZje7NBSV6IsEVmumWIbjiloUzQX9OzYdo8L1wjw2PrrpimONfmfNyzKklrgnEkSzT5QWYQW40YShyzqsRmMXbvVxKtGuYyMKaU1ugenLDm5Ily4iT14fP11Mx+xJv+zZ3MvnfdFqxU3a1W/FTB4m3Qfsyc1XUcdVhDeUDZXSFHHLQj/Y5jtC7ZqM0CXGwB4bP11i3LhOvzPGygYtiUBiwQV/4wFO0majijGsafHyRLu0yG6q35cL1rOpVxr2s5cM2jJYMCdc10Aj6q/blRpWJ//+dmm5psMl0KA2+AFRx9jMe2WbC4jQxnikd4DU8TwUjRVacgdlhmr3bpddzuJ9zXqr2xnxJfzP29RexdtjDVZqzkqa6PyvcojGrfkXiJ8SEtml/nYskicv0ivlxbqjemwUjMw5evdg8fUX9nOiC/lf94Q2i7MURk9nW1MSj5j8eAyV6y5CN2S6qbnw3vdA1Iwq+XOSCl663udN3IzLnrt+us25cI1+Z83SXQUldqQq0b5XOT17bGpLd6ssN1VMPf8c+jG8L3NeCnMdF+Ra3fRa9dft39/LuZ/3vwHoHrqGmQFafmiQw6eyzMxS05K4bL9uA+SKUQzCnSDkqOGokXyJvbgJ/BHI+qvY69//4rl20NsmK2ou2dTsyIALv/91/8n3P2Aao71WFGi8KKv1fRC5+J67Q/507/E/SOshqN5TsmYIjVt+kcjAx98iz/4SaojbIV1rexE7/C29HcYD/DX4a0rBOF5VTu7omsb11L/AWcVlcVZHSsqGuXLLp9ha8I//w3Mv+T4Ew7nTBsmgapoCrNFObIcN4pf/Ob/mrvHTGqqgAupL8qWjWPS9m/31jAe4DjA+4+uCoQoT/zOzlrNd3qd4SdphFxsUvYwGWbTWtISc3wNOWH+kHBMfc6kpmpwPgHWwqaSUG2ZWWheYOGQGaHB+eQ/kn6b3pOgLV+ODSn94wDvr8Bvb70/LLuiPPEr8OGVWfDmr45PZyccEmsVXZGe1pRNX9SU5+AVQkNTIVPCHF/jGmyDC9j4R9LfWcQvfiETmgMMUCMN1uNCakkweZsowdYobiMSlnKA93u7NzTXlSfe+SVbfnPQXmg9LpYAQxpwEtONyEyaueWM4FPjjyjG3uOaFmBTWDNgBXGEiQpsaWhnAqIijB07Dlsy3fUGeP989xbWkyf+FF2SNEtT1E0f4DYYVlxFlbaSMPIRMk/3iMU5pME2SIWJvjckciebkQuIRRyhUvkHg/iUljG5kzVog5hV7vIlCuBrmlhvgPfNHQM8lCf+FEGsYbMIBC0qC9a0uuy2wLXVbLBaP5kjHokCRxapkQyzI4QEcwgYHRZBp+XEFTqXFuNVzMtjXLJgX4gAid24Hjwc4N3dtVSe+NNiwTrzH4WVUOlDobUqr1FuAgYllc8pmzoVrELRHSIW8ViPxNy4xwjBpyR55I6J220qQTZYR4guvUICJiSpr9gFFle4RcF/OMB7BRiX8sSfhpNSO3lvEZCQfLUVTKT78Ek1LRLhWN+yLyTnp8qWUZ46b6vxdRGXfHVqx3eI75YaLa4iNNiK4NOW7wPW6lhbSOF9/M9qw8e/aoB3d156qTzxp8pXx5BKAsYSTOIIiPkp68GmTq7sZtvyzBQaRLNxIZ+paozHWoLFeExIhRBrWitHCAHrCF7/thhD8JhYz84wg93QRV88wLuLY8zF8sQ36qF1J455bOlgnELfshKVxYOXKVuKx0jaj22sczTQqPqtV/XDgpswmGTWWMSDw3ssyUunLLrVPGjYRsH5ggHeHSWiV8kT33ycFSfMgkoOK8apCye0J6VW6GOYvffgU9RWsukEi2kUV2nl4dOYUzRik9p7bcA4ggdJ53LxKcEe17B1R8eqAd7dOepV8sTXf5lhejoL85hUdhDdknPtKHFhljOT+bdq0hxbm35p2nc8+Ja1Iw+tJykgp0EWuAAZYwMVwac5KzYMslhvgHdHRrxKnvhTYcfKsxTxtTETkjHO7rr3zjoV25lAQHrqpV7bTiy2aXMmUhTBnKS91jhtR3GEoF0oLnWhWNnYgtcc4N0FxlcgT7yz3TgNIKkscx9jtV1ZKpWW+Ub1tc1eOv5ucdgpx+FJy9pgbLE7xDyXb/f+hLHVGeitHOi6A7ybo3sF8sS7w7cgdk0nJaOn3hLj3uyD0Zp5pazFIUXUpuTTU18d1EPkDoX8SkmWTnVIozEdbTcZjoqxhNHf1JrSS/AcvHjZ/SMHhL/7i5z+POsTUh/8BvNfYMTA8n+yU/MlTZxSJDRStqvEuLQKWwDctMTQogUDyQRoTQG5Kc6oQRE1yV1jCA7ri7jdZyK0sYTRjCR0Hnnd+y7nHxNgTULqw+8wj0mQKxpYvhjm9uSUxg+TTy7s2GtLUGcywhXSKZN275GsqlclX90J6bRI1aouxmgL7Q0Nen5ziM80SqMIo8cSOo+8XplT/5DHNWsSUr/6lLN/QQ3rDyzLruEW5enpf7KqZoShEduuSFOV7DLX7Ye+GmXb6/hnNNqKsVXuMDFpb9Y9eH3C6NGEzuOuI3gpMH/I6e+zDiH1fXi15t3vA1czsLws0TGEtmPEJdiiFPwlwKbgLHAFk4P6ZyPdymYYHGE0dutsChQBl2JcBFlrEkY/N5bQeXQ18gjunuMfMfsBlxJSx3niO485fwO4fGD5T/+3fPQqkneWVdwnw/3bMPkW9Wbqg+iC765Zk+xcT98ibKZc2EdgHcLoF8cSOo/Oc8fS+OyEULF4g4sJqXVcmfMfsc7A8v1/yfGXmL9I6Fn5pRwZhsPv0TxFNlAfZCvG+Oohi82UC5f/2IsJo0cTOm9YrDoKhFPEUr/LBYTUNht9zelHXDqwfPCIw4owp3mOcIQcLttWXFe3VZ/j5H3cIc0G6oPbCR+6Y2xF2EC5cGUm6wKC5tGEzhsWqw5hNidUiKX5gFWE1GXh4/Qplw4sVzOmx9QxU78g3EF6wnZlEN4FzJ1QPSLEZz1KfXC7vd8ssGdIbNUYpVx4UapyFUHzJoTOo1McSkeNn1M5MDQfs4qQuhhX5vQZFw8suwWTcyYTgioISk2YdmkhehG4PkE7w51inyAGGaU+uCXADabGzJR1fn3lwkty0asIo8cROm9Vy1g0yDxxtPvHDAmpu+PKnM8Ix1wwsGw91YJqhteaWgjYBmmQiebmSpwKKzE19hx7jkzSWOm66oPbzZ8Yj6kxVSpYjVAuvLzYMCRo3oTQecOOjjgi3NQ4l9K5/hOGhNTdcWVOTrlgYNkEXINbpCkBRyqhp+LdRB3g0OU6rMfW2HPCFFMV9nSp+uB2woepdbLBuJQyaw/ZFysXrlXwHxI0b0LovEkiOpXGA1Ijagf+KUNC6rKNa9bQnLFqYNkEnMc1uJrg2u64ELPBHpkgWbmwKpJoDhMwNbbGzAp7Yg31wS2T5rGtzit59PrKhesWG550CZpHEzpv2NGRaxlNjbMqpmEIzygJqQfjypycs2pg2cS2RY9r8HUqkqdEgKTWtWTKoRvOBPDYBltja2SO0RGjy9UHtxwRjA11ujbKF+ti5cIR9eCnxUg6owidtyoU5tK4NLji5Q3HCtiyF2IqLGYsHViOXTXOYxucDqG0HyttqYAKqYo3KTY1ekyDXRAm2AWh9JmsVh/ccg9WJ2E8YjG201sPq5ULxxX8n3XLXuMInbft2mk80rRGjCGctJ8/GFdmEQ9Ug4FlE1ll1Y7jtiraqm5Fe04VV8lvSVBL8hiPrfFVd8+7QH3Qbu2ipTVi8cvSGivc9cj8yvH11YMHdNSERtuOslM97feYFOPKzGcsI4zW0YGAbTAOaxCnxdfiYUmVWslxiIblCeAYr9VYR1gM7GmoPrilunSxxeT3DN/2eBQ9H11+nk1adn6VK71+5+Jfct4/el10/7KBZfNryUunWSCPxPECk1rdOv1WVSrQmpC+Tl46YD3ikQYcpunSQgzVB2VHFhxHVGKDgMEY5GLlQnP7FMDzw7IacAWnO6sBr12u+XanW2AO0wQ8pknnFhsL7KYIqhkEPmEXFkwaN5KQphbkUmG72wgw7WSm9RiL9QT925hkjiVIIhphFS9HKI6/8QAjlpXqg9W2C0apyaVDwKQwrwLY3j6ADR13ZyUNByQXHQu6RY09Hu6zMqXRaNZGS/KEJs0cJEe9VH1QdvBSJv9h09eiRmy0V2uJcqHcShcdvbSNg5fxkenkVprXM9rDVnX24/y9MVtncvbKY706anNl3ASll9a43UiacVquXGhvq4s2FP62NGKfQLIQYu9q1WmdMfmUrDGt8eDS0cXozH/fjmUH6Jruvm50hBDSaEU/2Ru2LEN/dl006TSc/g7tfJERxGMsgDUEr104pfWH9lQaN+M4KWQjwZbVc2rZVNHsyHal23wZtIs2JJqtIc/WLXXRFCpJkfE9jvWlfFbsNQ9pP5ZBS0zKh4R0aMFj1IjTcTnvi0Zz2rt7NdvQb2mgbju1plsH8MmbnEk7KbK0b+wC2iy3aX3szW8xeZvDwET6hWZYwqTXSSG+wMETKum0Dq/q+x62gt2ua2ppAo309TRk9TPazfV3qL9H8z7uhGqGqxNVg/FKx0HBl9OVUORn8Q8Jx9gFttGQUDr3tzcXX9xGgN0EpzN9mdZ3GATtPhL+CjxFDmkeEU6x56kqZRusLzALXVqkCN7zMEcqwjmywDQ6OhyUe0Xao1Qpyncrg6wKp9XfWDsaZplElvQ/b3sdweeghorwBDlHzgk1JmMc/wiERICVy2VJFdMjFuLQSp3S0W3+sngt2njwNgLssFGVQdJ0tu0KH4ky1LW4yrbkuaA6Iy9oz/qEMMXMMDWyIHhsAyFZc2peV9hc7kiKvfULxCl9iddfRK1f8kk9qvbdOoBtOg7ZkOZ5MsGrSHsokgLXUp9y88smniwWyuFSIRVmjplga3yD8Uij5QS1ZiM4U3Qw5QlSm2bXjFe6jzzBFtpg+/YBbLAWG7OPynNjlCw65fukGNdkJRf7yM1fOxVzbxOJVocFoYIaGwH22mIQkrvu1E2nGuebxIgW9U9TSiukPGU+Lt++c3DJPKhyhEEbXCQLUpae2exiKy6tMPe9mDRBFCEMTWrtwxN8qvuGnt6MoihKWS5NSyBhbH8StXoAz8PLOrRgLtOT/+4vcu+7vDLnqNvztOq7fmd8sMmY9Xzn1zj8Dq8+XVdu2Nv0IIySgEdQo3xVHps3Q5i3fLFsV4aiqzAiBhbgMDEd1uh8qZZ+lwhjkgokkOIv4xNJmyncdfUUzgB4oFMBtiu71Xumpz/P+cfUP+SlwFExwWW62r7b+LSPxqxn/gvMZ5z9C16t15UbNlq+jbGJtco7p8wbYlL4alSyfWdeuu0j7JA3JFNuVAwtst7F7FhWBbPFNKIUORndWtLraFLmMu7KFVDDOzqkeaiN33YAW/r76wR4XDN/yN1z7hejPau06EddkS/6XThfcz1fI/4K736fO48vlxt2PXJYFaeUkFS8U15XE3428xdtn2kc8GQlf1vkIaNRRnOMvLTWrZbElEHeLWi1o0dlKPAh1MVgbbVquPJ5+Cr8LU5/H/+I2QlHIU2ClXM9G8v7Rr7oc/hozfUUgsPnb3D+I+7WF8kNO92GY0SNvuxiE+2Bt8prVJTkzE64sfOstxuwfxUUoyk8VjcTlsqe2qITSFoSj6Epd4KsT6BZOWmtgE3hBfir8IzZDwgV4ZTZvD8VvPHERo8v+vL1DASHTz/i9OlKueHDjK5Rnx/JB1Vb1ioXdBra16dmt7dgik10yA/FwJSVY6XjA3oy4SqM2frqDPPSRMex9qs3XQtoWxMj7/Er8GWYsXgjaVz4OYumP2+9kbxvny/6kvWsEBw+fcb5bInc8APdhpOSs01tEqIkoiZjbAqKMruLbJYddHuHFRIyJcbdEdbl2sVLaySygunutBg96Y2/JjKRCdyHV+AEFtTvIpbKIXOamknYSiB6KV/0JetZITgcjjk5ZdaskBtWO86UF0ap6ozGXJk2WNiRUlCPFir66lzdm/SLSuK7EUdPz8f1z29Skq6F1fXg8+5UVR6bszncP4Tn4KUkkdJ8UFCY1zR1i8RmL/qQL3rlei4THG7OODlnKko4oI01kd3CaM08Ia18kC3GNoVaO9iDh+hWxSyTXFABXoau7Q6q9OxYg/OVEMw6jdbtSrJ9cBcewGmaZmg+bvkUnUUaGr+ZfnMH45Ivevl61hMcXsxYLFTu1hTm2zViCp7u0o5l+2PSUh9bDj6FgYypufBDhqK2+oXkiuHFHR3zfj+9PtA8oR0xnqX8qn+sx3bFODSbbF0X8EUvWQ8jBIcjo5bRmLOljDNtcqNtOe756h3l0VhKa9hDd2l1eqmsnh0MNMT/Cqnx6BInumhLT8luljzQ53RiJeA/0dxe5NK0o2fA1+GLXr6eNQWHNUOJssQaTRlGpLHKL9fD+IrQzTOMZS9fNQD4AnRNVxvTdjC+fJdcDDWQcyB00B0t9BDwTxXgaAfzDZ/DBXzRnfWMFRwuNqocOmX6OKNkY63h5n/fFcB28McVHqnXZVI27K0i4rDLNE9lDKV/rT+udVbD8dFFu2GGZ8mOt0kAXcoX3ZkIWVtw+MNf5NjR2FbivROHmhV1/pj2egv/fMGIOWTIWrV3Av8N9imV9IWml36H6cUjqEWNv9aNc+veb2sH46PRaHSuMBxvtW+twxctq0z+QsHhux8Q7rCY4Ct8lqsx7c6Sy0dl5T89rIeEuZKoVctIk1hNpfavER6yyH1Vvm3MbsUHy4ab4hWr/OZPcsRBphnaV65/ZcdYPNNwsjN/djlf9NqCw9U5ExCPcdhKxUgLSmfROpLp4WSUr8ojdwbncbvCf+a/YzRaEc6QOvXcGO256TXc5Lab9POvB+AWY7PigWYjzhifbovuunzRawsO24ZqQQAqguBtmpmPB7ysXJfyDDaV/aPGillgz1MdQg4u5MYaEtBNNHFjkRlSpd65lp4hd2AVPTfbV7FGpyIOfmNc/XVsPfg7vzaS/3nkvLL593ANLvMuRMGpQIhiF7kUEW9QDpAUbTWYBcbp4WpacHHY1aacqQyjGZS9HI3yCBT9kUZJhVOD+zUDvEH9ddR11fzPcTDQ5TlgB0KwqdXSavk9BC0pKp0WmcuowSw07VXmXC5guzSa4p0UvRw2lbDiYUx0ExJJRzWzi6Gm8cnEkfXXsdcG/M/jAJa0+bmCgdmQ9CYlNlSYZOKixmRsgiFxkrmW4l3KdFKv1DM8tk6WxPYJZhUUzcd8Kdtgrw/gkfXXDT7+avmfVak32qhtkg6NVdUS5wgkru1YzIkSduTW1FDwVWV3JQVJVuieTc0y4iDpFwc7/BvSalvKdQM8sv662cevz/+8sQVnjVAT0W2wLllw1JiMhJRxgDjCjLQsOzSFSgZqx7lAW1JW0e03yAD3asC+GD3NbQhbe+mN5GXH1F83KDOM4n/e5JIuH4NpdQARrFPBVptUNcjj4cVMcFSRTE2NpR1LEYbYMmfWpXgP9KejaPsLUhuvLCsVXznAG9dfx9SR1ud/3hZdCLHb1GMdPqRJgqDmm76mHbvOXDtiO2QPUcKo/TWkQ0i2JFXpBoo7vij1i1Lp3ADAo+qvG3V0rM//vFnnTE4hxd5Ka/Cor5YEdsLVJyKtDgVoHgtW11pWSjolPNMnrlrVj9Fv2Qn60twMwKPqr+N/wvr8z5tZcDsDrv06tkqyzESM85Ycv6XBWA2birlNCXrI6VbD2lx2L0vQO0QVTVVLH4SE67fgsfVXv8n7sz7/85Z7cMtbE6f088wSaR4kCkCm10s6pKbJhfqiUNGLq+0gLWC6eUAZFPnLjwqtKd8EwGvWX59t7iPW4X/eAN1svgRVSY990YZg06BD1ohLMtyFTI4pKTJsS9xREq9EOaPWiO2gpms7397x6nQJkbh+Fz2q/rqRROX6/M8bJrqlVW4l6JEptKeUFuMYUbtCQ7CIttpGc6MY93x1r1vgAnRXvY5cvwWPqb9uWQm+lP95QxdNMeWhOq1x0Db55C7GcUv2ZUuN6n8iKzsvOxibC//Yfs9Na8r2Rlz02vXXDT57FP/zJi66/EJSmsJKa8QxnoqW3VLQ+jZVUtJwJ8PNX1NQCwfNgdhhHD9on7PdRdrdGPF28rJr1F+3LBdeyv+8yYfLoMYet1vX4upNAjVvwOUWnlNXJXlkzk5Il6kqeoiL0C07qno+/CYBXq/+utlnsz7/Mzvy0tmI4zm4ag23PRN3t/CWryoUVJGm+5+K8RJ0V8Hc88/XHUX/HfiAq7t+BH+x6v8t438enWmdJwFA6ZINriLGKv/95f8lT9/FnyA1NMVEvQyaXuu+gz36f/DD73E4pwqpLcvm/o0Vle78n//+L/NPvoefp1pTJye6e4A/D082FERa5/opeH9zpvh13cNm19/4v/LDe5xMWTi8I0Ta0qKlK27AS/v3/r+/x/2GO9K2c7kVMonDpq7//jc5PKCxeNPpFVzaRr01wF8C4Pu76hXuX18H4LduTr79guuFD3n5BHfI+ZRFhY8w29TYhbbLi/bvBdqKE4fUgg1pBKnV3FEaCWOWyA+m3WpORZr/j+9TKJtW8yBTF2/ZEODI9/QavHkVdGFp/Pjn4Q+u5hXapsP5sOH+OXXA1LiKuqJxiMNbhTkbdJTCy4llEt6NnqRT4dhg1V3nbdrm6dYMecA1yTOL4PWTE9L5VzPFlLBCvlG58AhehnN4uHsAYinyJ+AZ/NkVvELbfOBUuOO5syBIEtiqHU1k9XeISX5bsimrkUUhnGDxourN8SgUsCZVtKyGbyGzHXdjOhsAvOAswSRyIBddRdEZWP6GZhNK/yjwew9ehBo+3jEADu7Ay2n8mDc+TS7awUHg0OMzR0LABhqLD4hJEh/BEGyBdGlSJoXYXtr+3HS4ijzVpgi0paWXtdruGTknXBz+11qT1Q2inxaTzQCO46P3lfLpyS4fou2PH/PupwZgCxNhGlj4IvUuWEsTkqMWm6i4xCSMc9N1RDQoCVcuGItJ/MRWefais+3synowi/dESgJjkilnWnBTGvRWmaw8oR15257t7CHmCf8HOn7cwI8+NQBXMBEmAa8PMRemrNCEhLGEhDQKcGZWS319BX9PFBEwGTbRBhLbDcaV3drFcDqk5kCTd2JF1Wp0HraqBx8U0wwBTnbpCadwBA/gTH/CDrcCs93LV8E0YlmmcyQRQnjBa8JESmGUfIjK/7fkaDJpmD2QptFNVJU1bbtIAjjWQizepOKptRjbzR9Kag6xZmMLLjHOtcLT3Tx9o/0EcTT1XN3E45u24AiwEypDJXihKjQxjLprEwcmRKclaDNZCVqr/V8mYWyFADbusiY5hvgFoU2vio49RgJLn5OsReRFN6tabeetiiy0V7KFHT3HyZLx491u95sn4K1QQSPKM9hNT0wMVvAWbzDSVdrKw4zRjZMyJIHkfq1VAVCDl/bUhNKlGq0zGr05+YAceXVPCttVk0oqjVwMPt+BBefx4yPtGVkUsqY3CHDPiCM5ngupUwCdbkpd8kbPrCWHhkmtIKLEetF2499eS1jZlIPGYnlcPXeM2KD9vLS0bW3ktYNqUllpKLn5ZrsxlIzxvDu5eHxzGLctkZLEY4PgSOg2IUVVcUONzUDBEpRaMoXNmUc0tFZrTZquiLyKxrSm3DvIW9Fil+AkhXu5PhEPx9mUNwqypDvZWdKlhIJQY7vn2OsnmBeOWnYZ0m1iwbbw1U60by5om47iHRV6fOgzjMf/DAZrlP40Z7syxpLK0lJ0gqaAK1c2KQKu7tabTXkLFz0sCftuwX++MyNeNn68k5Buq23YQhUh0SNTJa1ioQ0p4nUG2y0XilF1JqODqdImloPS4Bp111DEWT0jJjVv95uX9BBV7eB3bUWcu0acSVM23YZdd8R8UbQUxJ9wdu3oMuhdt929ME+mh6JXJ8di2RxbTi6TbrDquqV4aUKR2iwT6aZbyOwEXN3DUsWr8Hn4EhwNyHuXHh7/pdaUjtR7vnDh/d8c9xD/s5f501eQ1+CuDiCvGhk1AN/4Tf74RfxPwD3toLarR0zNtsnPzmS64KIRk861dMWCU8ArasG9T9H0ZBpsDGnjtAOM2+/LuIb2iIUGXNgl5ZmKD/Tw8TlaAuihaFP5yrw18v4x1898zIdP+DDAX1bM3GAMvPgRP/cJn3zCW013nrhHkrITyvYuwOUkcHuKlRSW5C6rzIdY4ppnF7J8aAJbQepgbJYBjCY9usGXDKQxq7RZfh9eg5d1UHMVATRaD/4BHK93/1iAgYZ/+jqPn8Dn4UExmWrpa3+ZOK6MvM3bjwfzxNWA2dhs8+51XHSPJiaAhGSpWevEs5xHLXcEGFXYiCONySH3fPWq93JIsBiSWvWyc3CAN+EcXoT7rCSANloPPoa31rt/5PUA/gp8Q/jDD3hyrjzlR8VkanfOvB1XPubt17vzxAfdSVbD1pzAnfgyF3ycadOTOTXhpEUoLC1HZyNGW3dtmjeXgr2r56JNmRwdNNWaQVBddd6rh4MhviEB9EFRD/7RGvePvCbwAL4Mx/D6M541hHO4D3e7g6PafdcZVw689z7NGTwo5om7A8sPhccT6qKcl9NJl9aM/9kX+e59Hh1yPqGuCCZxuITcsmNaJ5F7d0q6J3H48TO1/+M57085q2icdu2U+W36Ldllz9Agiv4YGljoEN908EzvDOrBF98/vtJwCC/BF2AG75xxEmjmMIcjxbjoaxqOK3/4hPOZzhMPBpYPG44CM0dTVm1LjLtUWWVz1Bcf8tEx0zs8O2A2YVHRxKYOiy/aOVoAaMu0i7ubu43njjmd4ibMHU1sIDHaQNKrZND/FZYdk54oCXetjq7E7IVl9eAL7t+oHnwXXtLx44czzoRFHBztYVwtH1d+NOMkupZ5MTM+gUmq90X+Bh9zjRlmaQ+m7YMqUL/veemcecAtOJ0yq1JnVlN27di2E0+Klp1tAJ4KRw1eMI7aJjsO3R8kPSI3fUFXnIOfdQe86sIIVtWDL7h//Ok6vj8vwDk08NEcI8zz7OhBy+WwalzZeZ4+0XniRfst9pAJqQHDGLzVQ2pheZnnv1OWhwO43/AgcvAEXEVVpa4db9sGvNK8wjaENHkfFQ4Ci5i7dqnQlPoLQrHXZDvO3BIXZbJOBrOaEbML6sFL798I4FhKihjHMsPjBUZYCMFr6nvaArxqXPn4lCa+cHfSa2cP27g3Z3ziYTRrcbQNGLQmGF3F3cBdzzzX7AILx0IB9rbwn9kx2G1FW3Inic+ZLIsVvKR8Zwfj0l1fkqo8LWY1M3IX14OX3r9RKTIO+d9XzAI8qRPGPn/4NC2n6o4rN8XJ82TOIvuVA8zLKUHRFgBCetlDZlqR1gLKjS39xoE7Bt8UvA6BxuEDjU3tFsEijgA+615tmZkXKqiEENrh41iLDDZNq4pKTWR3LZfnos81LOuNa15cD956vLMsJd1rqYp51gDUQqMYm2XsxnUhD2jg1DM7SeuJxxgrmpfISSXVIJIS5qJJSvJPEQ49DQTVIbYWJ9QWa/E2+c/oPK1drmC7WSfJRNKBO5Yjvcp7Gc3dmmI/Xh1kDTEuiSnWqQf37h+fTMhGnDf6dsS8SQfQWlqqwXXGlc/PEZ/SC5mtzIV0nAshlQdM/LvUtYutrEZ/Y+EAFtq1k28zQhOwLr1AIeANzhF8t9qzTdZf2qRKO6MWE9ohBYwibbOmrFtNmg3mcS+tB28xv2uKd/agYCvOP+GkSc+0lr7RXzyufL7QbkUpjLjEWFLqOIkAGu2B0tNlO9Eau2W1qcOUvVRgKzypKIQZ5KI3q0MLzqTNRYqiZOqmtqloIRlmkBHVpHmRYV6/HixbO6UC47KOFJnoMrVyr7wYz+SlW6GUaghYbY1I6kkxA2W1fSJokUdSh2LQ1GAimRGm0MT+uu57H5l7QgOWxERpO9moLRPgTtquWCfFlGlIjQaRly9odmzMOWY+IBO5tB4sW/0+VWGUh32qYk79EidWKrjWuiLpiVNGFWFRJVktyeXWmbgBBzVl8anPuXyNJlBJOlKLTgAbi/EYHVHxWiDaVR06GnHQNpJcWcK2jJtiCfG2sEHLzuI66sGrMK47nPIInPnu799935aOK2cvmvubrE38ZzZjrELCmXM2hM7UcpXD2oC3+ECVp7xtIuxptJ0jUr3sBmBS47TVxlvJ1Sqb/E0uLdvLj0lLr29ypdd/eMX3f6lrxGlKwKQxEGvw0qHbkbwrF3uHKwVENbIV2wZ13kNEF6zD+x24aLNMfDTCbDPnEikZFyTNttxWBXDaBuM8KtI2rmaMdUY7cXcUPstqTGvBGSrFWIpNMfbdea990bvAOC1YX0qbc6smDS1mPxSJoW4fwEXvjMmhlijDRq6qale6aJEuFGoppYDoBELQzLBuh/mZNx7jkinv0EtnUp50lO9hbNK57lZaMAWuWR5Yo9/kYwcYI0t4gWM47Umnl3YmpeBPqSyNp3K7s2DSAS/39KRuEN2bS4xvowV3dFRMx/VFcp2Yp8w2nTO9hCXtHG1kF1L4KlrJr2wKfyq77R7MKpFKzWlY9UkhYxyHWW6nBWPaudvEAl3CGcNpSXPZ6R9BbBtIl6cHL3gIBi+42CYXqCx1gfGWe7Ap0h3luyXdt1MKy4YUT9xSF01G16YEdWsouW9mgDHd3veyA97H+Ya47ZmEbqMY72oPztCGvK0onL44AvgC49saZKkWRz4veWljE1FHjbRJaWv6ZKKtl875h4CziFCZhG5rx7tefsl0aRT1bMHZjm8dwL/6u7wCRysaQblQoG5yAQN5zpatMNY/+yf8z+GLcH/Qn0iX2W2oEfXP4GvwQHuIL9AYGnaO3zqAX6946nkgqZNnUhx43DIdQtMFeOPrgy/y3Yd85HlJWwjLFkU3kFwq28xPnuPhMWeS+tDLV9Otllq7pQCf3uXJDN9wFDiUTgefHaiYbdfi3b3u8+iY6TnzhgehI1LTe8lcd7s1wJSzKbahCRxKKztTLXstGAiu3a6rPuQs5pk9TWAan5f0BZmGf7Ylxzzk/A7PAs4QPPPAHeFQ2hbFHszlgZuKZsJcUmbDC40sEU403cEjczstOEypa+YxevL4QBC8oRYqWdK6b7sK25tfE+oDZgtOQ2Jg8T41HGcBE6fTWHn4JtHcu9S7uYgU5KSCkl/mcnq+5/YBXOEr6lCUCwOTOM1taOI8mSxx1NsCXBEmLKbMAg5MkwbLmpBaFOPrNSlO2HnLiEqW3tHEwd8AeiQLmn+2gxjC3k6AxREqvKcJbTEzlpLiw4rNZK6oJdidbMMGX9FULKr0AkW+2qDEPBNNm5QAt2Ik2nftNWHetubosHLo2nG4vQA7GkcVCgVCgaDixHqo9UUn1A6OshapaNR/LPRYFV8siT1cCtJE0k/3WtaNSuUZYKPnsVIW0xXWnMUxq5+En4Kvw/MqQmVXnAXj9Z+9zM98zM/Agy7F/qqj2Nh67b8HjFnPP3iBn/tkpdzwEJX/whIcQUXOaikeliCRGUk7tiwF0rItwMEhjkZ309hikFoRAmLTpEXWuHS6y+am/KB/fM50aLEhGnSMwkpxzOov4H0AvgovwJ1iGzDLtJn/9BU+fAINfwUe6FHSLhu83viV/+/HrOePX+STT2B9uWGbrMHHLldRBlhS/CJQmcRxJFqZica01XixAZsYiH1uolZxLrR/SgxVIJjkpQP4PE9sE59LKLr7kltSBogS5tyszzH8Fvw8/AS8rNOg0xUS9fIaHwb+6et8Q/gyvKRjf5OusOzGx8evA/BP4IP11uN/grca5O0lcsPLJ5YjwI4QkJBOHa0WdMZYGxPbh2W2nR9v3WxEWqgp/G3+6VZbRLSAAZ3BhdhAaUL33VUSw9yjEsvbaQ9u4A/gGXwZXoEHOuU1GSj2chf+Mo+f8IcfcAxfIKVmyunRbYQVnoevwgfw3TXXcw++xNuP4fhyueEUNttEduRVaDttddoP0eSxLe2LENk6itYxlrxBNBYrNNKSQmeaLcm9c8UsaB5WyO6675yyQIAWSDpBVoA/gxmcwEvwoDv0m58UE7gHn+fJOa8/Ywan8EKRfjsopF83eCglX/Sfr7OeaRoQfvt1CGvIDccH5BCvw1sWIzRGC/66t0VTcLZQZtm6PlAasbOJ9iwWtUo7biktTSIPxnR24jxP1ZKaqq+2RcXM9OrBAm/AAs7hDJ5bNmGb+KIfwCs8a3jnjBrOFeMjHSCdbKr+2uOLfnOd9eiA8Hvvwwq54VbP2OqwkB48Ytc4YEOiH2vTXqodabfWEOzso4qxdbqD5L6tbtNPECqbhnA708DZH4QOJUXqScmUlks7Ot6FBuZw3n2mEbaUX7kDzxHOOQk8nKWMzAzu6ZZ8sOFw4RK+6PcuXo9tB4SbMz58ApfKDXf3szjNIIbGpD5TKTRxGkEMLjLl+K3wlWXBsCUxIDU+jbOiysESqAy1MGUJpXgwbTWzNOVEziIXZrJ+VIztl1PUBxTSo0dwn2bOmfDRPD3TRTGlfbCJvO9KvuhL1hMHhB9wPuPRLGHcdOWG2xc0U+5bQtAJT0nRTewXL1pgk2+rZAdeWmz3jxAqfNQQdzTlbF8uJ5ecEIWvTkevAHpwz7w78QujlD/Lr491bD8/1vhM2yrUQRrWXNQY4fGilfctMWYjL72UL/qS9eiA8EmN88nbNdour+PBbbAjOjIa4iBhfFg6rxeKdEGcL6p3EWR1Qq2Qkhs2DrnkRnmN9tG2EAqmgPw6hoL7Oza7B+3SCrR9tRftko+Lsf2F/mkTndN2LmzuMcKTuj/mX2+4Va3ki16+nnJY+S7MefpkidxwnV+4wkXH8TKnX0tsYzYp29DOOoSW1nf7nTh2akYiWmcJOuTidSaqESrTYpwjJJNVGQr+rLI7WsqerHW6Kp/oM2pKuV7T1QY9gjqlZp41/WfKpl56FV/0kvXQFRyeQ83xaTu5E8p5dNP3dUF34ihyI3GSpeCsywSh22ZJdWto9winhqifb7VRvgktxp13vyjrS0EjvrRfZ62uyqddSWaWYlwTPAtJZ2oZ3j/Sgi/mi+6vpzesfAcWNA0n8xVyw90GVFGuZjTXEQy+6GfLGLMLL523f5E0OmxVjDoOuRiH91RKU+vtoCtH7TgmvBLvtFXWLW15H9GTdVw8ow4IlRLeHECN9ym1e9K0I+Cbnhgv4Yu+aD2HaQJ80XDqOzSGAV4+4yCqBxrsJAX6ZTIoX36QnvzhhzzMfFW2dZVLOJfo0zbce5OvwXMFaZ81mOnlTVXpDZsQNuoYWveketKb5+6JOOsgX+NTm7H49fUTlx+WLuWL7qxnOFh4BxpmJx0p2gDzA/BUARuS6phR+pUsY7MMboAHx5xNsSVfVZcYSwqCKrqon7zM+8ecCkeS4nm3rINuaWvVNnMRI1IRpxTqx8PZUZ0Br/UEduo3B3hNvmgZfs9gQPj8vIOxd2kndir3awvJ6BLvoUuOfFWNYB0LR1OQJoUySKb9IlOBx74q1+ADC2G6rOdmFdJcD8BkfualA+BdjOOzP9uUhGUEX/TwhZsUduwRr8wNuXKurCixLBgpQI0mDbJr9dIqUuV+92ngkJZ7xduCk2yZKbfWrH1VBiTg9VdzsgRjW3CVXCvAwDd+c1z9dWw9+B+8MJL/eY15ZQ/HqvTwVdsZn5WQsgRRnMaWaecu3jFvMBEmgg+FJFZsnSl0zjB9OqPYaBD7qmoVyImFvzi41usesV0julaAR9dfR15Xzv9sEruRDyk1nb+QaLU67T885GTls6YgcY+UiMa25M/pwGrbCfzkvR3e0jjtuaFtnwuagHTSb5y7boBH119HXhvwP487jJLsLJ4XnUkHX5sLbS61dpiAXRoZSCrFJ+EjpeU3puVfitngYNo6PJrAigKktmwjyQdZpfq30mmtulaAx9Zfx15Xzv+cyeuiBFUs9zq8Kq+XB9a4PVvph3GV4E3y8HENJrN55H1X2p8VyqSKwVusJDKzXOZzplWdzBUFK9e+B4+uv468xvI/b5xtSAkBHQaPvtqWzllVvEOxPbuiE6+j2pvjcKsbvI7txnRErgfH7LdXqjq0IokKzga14GzQ23SSbCQvO6r+Or7SMIr/efOkkqSdMnj9mBx2DRsiY29Uj6+qK9ZrssCKaptR6HKURdwUYeUWA2kPzVKQO8ku2nU3Anhs/XWkBx3F/7wJtCTTTIKftthue1ty9xvNYLY/zo5KSbIuKbXpbEdSyeRyYdAIwKY2neyoc3+k1XUaufYga3T9daMUx/r8z1s10ITknIO0kuoMt+TB8jK0lpayqqjsJ2qtXAYwBU932zinimgmd6mTRDnQfr88q36NAI+tv24E8Pr8zxtasBqx0+xHH9HhlrwsxxNUfKOHQaZBITNf0uccj8GXiVmXAuPEAKSdN/4GLHhs/XWj92dN/uetNuBMnVR+XWDc25JLjo5Mg5IZIq226tmCsip2zZliL213YrTlL2hcFjpCduyim3M7/eB16q/blQsv5X/esDRbtJeabLIosWy3ycavwLhtxdWzbMmHiBTiVjJo6lCLjXZsi7p9PEPnsq6X6wd4bP11i0rD5fzPm/0A6brrIsllenZs0lCJlU4abakR59enZKrKe3BZihbTxlyZ2zl1+g0wvgmA166/bhwDrcn/7Ddz0eWZuJvfSESug6NzZsox3Z04FIxz0mUjMwVOOVTq1CQ0AhdbBGVdjG/CgsfUX7esJl3K/7ytWHRv683praW/8iDOCqWLLhpljDY1ZpzK75QiaZoOTpLKl60auHS/97oBXrv+umU9+FL+5+NtLFgjqVLCdbmj7pY5zPCPLOHNCwXGOcLquOhi8CmCWvbcuO73XmMUPab+ug3A6/A/78Bwe0bcS2+tgHn4J5pyS2WbOck0F51Vq3LcjhLvZ67p1ABbaL2H67bg78BfjKi/jr3+T/ABV3ilLmNXTI2SpvxWBtt6/Z//D0z/FXaGbSBgylzlsEGp+5//xrd4/ae4d8DUUjlslfIYS3t06HZpvfQtvv0N7AHWqtjP2pW08QD/FLy//da38vo8PNlKHf5y37Dxdfe/oj4kVIgFq3koLReSR76W/bx//n9k8jonZxzWTANVwEniDsg87sOSd/z7//PvMp3jQiptGVWFX2caezzAXwfgtzYUvbr0iozs32c3Uge7varH+CNE6cvEYmzbPZ9hMaYDdjK4V2iecf6EcEbdUDVUARda2KzO/JtCuDbNQB/iTeL0EG1JSO1jbXS+nLxtPMDPw1fh5+EPrgSEKE/8Gry5A73ui87AmxwdatyMEBCPNOCSKUeRZ2P6Myb5MRvgCHmA9ywsMifU+AYXcB6Xa5GibUC5TSyerxyh0j6QgLVpdyhfArRTTLqQjwe4HOD9s92D4Ap54odXAPBWLAwB02igG5Kkc+piN4lvODIFGAZgT+EO4Si1s7fjSR7vcQETUkRm9O+MXyo9OYhfe4xt9STQ2pcZRLayCV90b4D3jR0DYAfyxJ+eywg2IL7NTMXna7S/RpQ63JhWEM8U41ZyQGjwsVS0QBrEKLu8xwZsbi4wLcCT+OGidPIOCe1PiSc9Qt+go+vYqB7cG+B9d8cAD+WJPz0Am2gxXgU9IneOqDpAAXOsOltVuMzpdakJXrdPCzXiNVUpCeOos5cxnpQT39G+XVLhs1osQVvJKPZyNq8HDwd4d7pNDuWJPxVX7MSzqUDU6gfadKiNlUFTzLeFHHDlzO4kpa7aiKhBPGKwOqxsBAmYkOIpipyXcQSPlRTf+Tii0U3EJGaZsDER2qoB3h2hu0qe+NNwUooYU8y5mILbJe6OuX+2FTKy7bieTDAemaQyQ0CPthljSWO+xmFDIYiESjM5xKd6Ik5lvLq5GrQ3aCMLvmCA9wowLuWJb9xF59hVVP6O0CrBi3ZjZSNOvRy+I6klNVRJYRBaEzdN+imiUXQ8iVF8fsp+W4JXw7WISW7fDh7lptWkCwZ4d7QTXyBPfJMYK7SijjFppGnlIVJBJBYj7eUwtiP1IBXGI1XCsjNpbjENVpSAJ2hq2LTywEly3hUYazt31J8w2+aiLx3g3fohXixPfOMYm6zCGs9LVo9MoW3MCJE7R5u/WsOIjrqBoHUO0bJE9vxBpbhsd3+Nb4/vtPCZ4oZYCitNeYuC/8UDvDvy0qvkiW/cgqNqRyzqSZa/s0mqNGjtKOoTm14zZpUauiQgVfqtQiZjq7Q27JNaSK5ExRcrGCXO1FJYh6jR6CFqK7bZdQZ4t8g0rSlPfP1RdBtqaa9diqtzJkQ9duSryi2brQXbxDwbRUpFMBHjRj8+Nt7GDKgvph9okW7LX47gu0SpGnnFQ1S1lYldOsC7hYteR574ZuKs7Ei1lBsfdz7IZoxzzCVmmVqaSySzQbBVAWDek+N4jh9E/4VqZrJjPwiv9BC1XcvOWgO8275CVyBPvAtTVlDJfZkaZGU7NpqBogAj/xEHkeAuJihWYCxGN6e8+9JtSegFXF1TrhhLGP1fak3pebgPz192/8gB4d/6WT7+GdYnpH7hH/DJzzFiYPn/vjW0SgNpTNuPIZoAEZv8tlGw4+RLxy+ZjnKa5NdFoC7UaW0aduoYse6+bXg1DLg6UfRYwmhGEjqPvF75U558SANrElK/+MdpXvmqBpaXOa/MTZaa1DOcSiLaw9j0NNNst3c+63c7EKTpkvKHzu6bPbP0RkuHAVcbRY8ijP46MIbQeeT1mhA+5PV/inyDdQipf8LTvMXbwvoDy7IruDNVZKTfV4CTSRUYdybUCnGU7KUTDxLgCknqUm5aAW6/1p6eMsOYsphLzsHrE0Y/P5bQedx1F/4yPHnMB3/IOoTU9+BL8PhtjuFKBpZXnYNJxTuv+2XqolKR2UQgHhS5novuxVySJhBNRF3SoKK1XZbbXjVwWNyOjlqWJjrWJIy+P5bQedyldNScP+HZ61xKSK3jyrz+NiHG1hcOLL/+P+PDF2gOkekKGiNWKgJ+8Z/x8Iv4DdQHzcpZyF4v19I27w9/yPGDFQvmEpKtqv/TLiWMfn4sofMm9eAH8Ao0zzh7h4sJqYtxZd5/D7hkYPneDzl5idlzNHcIB0jVlQ+8ULzw/nc5/ojzl2juE0apD7LRnJxe04dMz2iOCFNtGFpTuXA5AhcTRo8mdN4kz30nVjEC4YTZQy4gpC7GlTlrePKhGsKKgeXpCYeO0MAd/GH7yKQUlXPLOasOH3FnSphjHuDvEu4gB8g66oNbtr6eMbFIA4fIBJkgayoXriw2XEDQPJrQeROAlY6aeYOcMf+IVYTU3XFlZufMHinGywaW3YLpObVBAsbjF4QJMsVUSayjk4voPsHJOQfPWDhCgDnmDl6XIRerD24HsGtw86RMHOLvVSHrKBdeVE26gKB5NKHzaIwLOmrqBWJYZDLhASG16c0Tn+CdRhWDgWXnqRZUTnPIHuMJTfLVpkoYy5CzylHVTGZMTwkGAo2HBlkQplrJX6U+uF1wZz2uwS1SQ12IqWaPuO4baZaEFBdukksJmkcTOm+YJSvoqPFzxFA/YUhIvWxcmSdPWTWwbAKVp6rxTtPFUZfKIwpzm4IoMfaYQLWgmlG5FME2gdBgm+J7J+rtS/XBbaVLsR7bpPQnpMFlo2doWaVceHk9+MkyguZNCJ1He+kuHTWyQAzNM5YSUg/GlTk9ZunAsg1qELVOhUSAK0LABIJHLKbqaEbHZLL1VA3VgqoiOKXYiS+HRyaEKgsfIqX64HYWbLRXy/qWoylIV9gudL1OWBNgBgTNmxA6b4txDT4gi3Ri7xFSLxtXpmmYnzAcWDZgY8d503LFogz5sbonDgkKcxGsWsE1OI+rcQtlgBBCSOKD1mtqYpIU8cTvBmAT0yZe+zUzeY92fYjTtGipXLhuR0ePoHk0ofNWBX+lo8Z7pAZDk8mEw5L7dVyZZoE/pTewbI6SNbiAL5xeygW4xPRuLCGbhcO4RIeTMFYHEJkYyEO9HmJfXMDEj/LaH781wHHZEtqSQ/69UnGpzH7LKIAZEDSPJnTesJTUa+rwTepI9dLJEawYV+ZkRn9g+QirD8vF8Mq0jFQ29js6kCS3E1+jZIhgPNanHdHFqFvPJLHqFwQqbIA4jhDxcNsOCCQLDomaL/dr5lyJaJU6FxPFjO3JOh3kVMcROo8u+C+jo05GjMF3P3/FuDLn5x2M04xXULPwaS6hBYki+MrMdZJSgPHlcB7nCR5bJ9Kr5ACUn9jk5kivdd8tk95SOGrtqu9lr2IhK65ZtEl7ZKrp7DrqwZfRUSN1el7+7NJxZbywOC8neNKTch5vsTEMNsoCCqHBCqIPRjIPkm0BjvFODGtto99rCl+d3wmHkW0FPdpZtC7MMcVtGFQjJLX5bdQ2+x9ypdc313uj8xlsrfuLgWXz1cRhZvJYX0iNVBRcVcmCXZs6aEf3RQF2WI/TcCbKmGU3IOoDJGDdDub0+hYckt6PlGu2BcxmhbTdj/klhccLGJMcqRjMJP1jW2ETqLSWJ/29MAoORluJ+6LPffBZbi5gqi5h6catQpmOT7/OFf5UorRpLzCqcMltBLhwd1are3kztrSzXO0LUbXRQcdLh/RdSZ+swRm819REDrtqzC4es6Gw4JCKlSnjYVpo0xeq33PrADbFLL3RuCmObVmPN+24kfa+AojDuM4umKe2QwCf6EN906HwjujaitDs5o0s1y+k3lgbT2W2i7FJdnwbLXhJUBq/9liTctSmFC/0OqUinb0QddTWamtjbHRFuWJJ6NpqZ8vO3fZJ37Db+2GkaPYLGHs7XTTdiFQJ68SkVJFVmY6McR5UycflNCsccHFaV9FNbR4NttLxw4pQ7wJd066Z0ohVbzihaxHVExd/ay04oxUKWt+AsdiQ9OUyZ2krzN19IZIwafSTFgIBnMV73ADj7V/K8u1MaY2sJp2HWm0f41tqwajEvdHWOJs510MaAqN4aoSiPCXtN2KSi46dUxHdaMquar82O1x5jqhDGvqmoE9LfxcY3zqA7/x3HA67r9ZG4O6Cuxu12/+TP+eLP+I+HErqDDCDVmBDO4larujNe7x8om2rMug0MX0rL1+IWwdwfR+p1TNTyNmVJ85ljWzbWuGv8/C7HD/izjkHNZNYlhZcUOKVzKFUxsxxN/kax+8zPWPSFKw80rJr9Tizyj3o1gEsdwgWGoxPezDdZ1TSENE1dLdNvuKL+I84nxKesZgxXVA1VA1OcL49dFlpFV5yJMhzyCmNQ+a4BqusPJ2bB+xo8V9u3x48VVIEPS/mc3DvAbXyoYr6VgDfh5do5hhHOCXMqBZUPhWYbWZECwVJljLgMUWOCB4MUuMaxGNUQDVI50TQ+S3kFgIcu2qKkNSHVoM0SHsgoZxP2d5HH8B9woOk4x5bPkKtAHucZsdykjxuIpbUrSILgrT8G7G5oCW+K0990o7E3T6AdW4TilH5kDjds+H64kS0mz24grtwlzDHBJqI8YJQExotPvoC4JBq0lEjjQkyBZ8oH2LnRsQ4Hu1QsgDTJbO8fQDnllitkxuVskoiKbRF9VwzMDvxHAdwB7mD9yCplhHFEyUWHx3WtwCbSMMTCUCcEmSGlg4gTXkHpZXWQ7kpznK3EmCHiXInqndkQjunG5kxTKEeGye7jWz9cyMR2mGiFQ15ENRBTbCp+Gh86vAyASdgmJq2MC6hoADQ3GosP0QHbnMHjyBQvQqfhy/BUbeHd5WY/G/9LK/8Ka8Jd7UFeNWEZvzPb458Dn8DGLOe3/wGL/4xP+HXlRt+M1PE2iLhR8t+lfgxsuh7AfO2AOf+owWhSZRYQbd622hbpKWKuU+XuvNzP0OseRDa+mObgDHJUSc/pKx31QdKffQ5OIJpt8GWjlgTwMc/w5MPCR/yl1XC2a2Yut54SvOtMev55Of45BOat9aWG27p2ZVORRvnEk1hqWMVUmqa7S2YtvlIpspuF1pt0syuZS2NV14mUidCSfzQzg+KqvIYCMljIx2YK2AO34fX4GWdu5xcIAb8MzTw+j/lyWM+Dw/gjs4GD6ehNgA48kX/AI7XXM/XAN4WHr+9ntywqoCakCqmKP0rmQrJJEErG2Upg1JObr01lKQy4jskWalKYfJ/EDLMpjNSHFEUAde2fltaDgmrNaWQ9+AAb8I5vKjz3L1n1LriB/BXkG/wwR9y/oRX4LlioHA4LzP2inzRx/DWmutRweFjeP3tNeSGlaE1Fde0OS11yOpmbIp2u/jF1n2RRZviJM0yBT3IZl2HWImKjQOxIyeU325b/qWyU9Moj1o07tS0G7qJDoGHg5m8yeCxMoEH8GU45tnrNM84D2l297DQ9t1YP7jki/7RmutRweEA77/HWXOh3HCxkRgldDQkAjNTMl2Iloc1qN5JfJeeTlyTRzxURTdn1Ixv2uKjs12AbdEWlBtmVdk2k7FFwj07PCZ9XAwW3dG+8xKzNFr4EnwBZpy9Qzhh3jDXebBpYcpuo4fQ44u+fD1dweEnHzI7v0xuuOALRUV8rXpFyfSTQYkhd7IHm07jpyhlkCmI0ALYqPTpUxXS+z4jgDj1Pflvmz5ecuItpIBxyTHpSTGWd9g1ApfD/bvwUhL4nT1EzqgX7cxfCcNmb3mPL/qi9SwTHJ49oj5ZLjccbTG3pRmlYi6JCG0mQrAt1+i2UXTZ2dv9IlQpN5naMYtviaXlTrFpoMsl3bOAFEa8sqPj2WCMrx3Yjx99qFwO59Aw/wgx+HlqNz8oZvA3exRDvuhL1jMQHPaOJ0+XyA3fp1OfM3qObEVdhxjvynxNMXQV4+GJyvOEFqeQBaIbbO7i63rpxCltdZShPFxkjM2FPVkn3TG+Rp9pO3l2RzFegGfxGDHIAh8SteR0C4HopXzRF61nheDw6TFN05Ebvq8M3VKKpGjjO6r7nhudTEGMtYM92HTDaR1FDMXJ1eThsbKfywyoWwrzRSXkc51flG3vIid62h29bIcFbTGhfV+faaB+ohj7dPN0C2e2lC96+XouFByen9AsunLDJZ9z7NExiUc0OuoYW6UZkIyx2YUR2z6/TiRjyKMx5GbbjLHvHuf7YmtKghf34LJfx63Yg8vrvN2zC7lY0x0tvKezo4HmGYDU+Gab6dFL+KI761lDcNifcjLrrr9LWZJctG1FfU1uwhoQE22ObjdfkSzY63CbU5hzs21WeTddH2BaL11Gi7lVdlxP1nkxqhnKhVY6knS3EPgVGg1JpN5cP/hivujOelhXcPj8HC/LyI6MkteVjlolBdMmF3a3DbsuAYhL44dxzthWSN065xxUd55Lmf0wRbOYOqH09/o9WbO2VtFdaMb4qBgtFJoT1SqoN8wPXMoXLb3p1PUEhxfnnLzGzBI0Ku7FxrKsNJj/8bn/H8fPIVOd3rfrklUB/DOeO+nkghgSPzrlPxluCMtOnDL4Yml6dK1r3vsgMxgtPOrMFUZbEUbTdIzii5beq72G4PD0DKnwjmBULUVFmy8t+k7fZ3pKc0Q4UC6jpVRqS9Umv8bxw35flZVOU1X7qkjnhZlsMbk24qQ6Hz7QcuL6sDC0iHHki96Uh2UdvmgZnjIvExy2TeJdMDZNSbdZyAHe/Yd1xsQhHiKzjh7GxQ4yqMPaywPkjMamvqrYpmO7Knad+ZQC5msCuAPWUoxrxVhrGv7a+KLXFhyONdTMrZ7ke23qiO40ZJUyzgYyX5XyL0mV7NiUzEs9mjtbMN0dERqwyAJpigad0B3/zRV7s4PIfXSu6YV/MK7+OrYe/JvfGMn/PHJe2fyUdtnFrKRNpXV0Y2559aWPt/G4BlvjTMtXlVIWCnNyA3YQBDmYIodFz41PvXPSa6rq9lWZawZ4dP115HXV/M/tnFkkrBOdzg6aP4pID+MZnTJ1SuuB6iZlyiox4HT2y3YBtkUKWooacBQUDTpjwaDt5poBHl1/HXltwP887lKKXxNUEyPqpGTyA699UqY/lt9yGdlUKra0fFWS+36iylVWrAyd7Uw0CZM0z7xKTOduznLIjG2Hx8cDPLb+OvK6Bv7n1DYci4CxUuRxrjBc0bb4vD3rN5Zz36ntLb83eVJIB8LiIzCmn6SMPjlX+yNlTjvIGjs+QzHPf60Aj62/jrzG8j9vYMFtm1VoRWCJdmw7z9N0t+c8cxZpPeK4aTRicS25QhrVtUp7U578chk4q04Wx4YoQSjFryUlpcQ1AbxZ/XVMknIU//OGl7Q6z9Zpxi0+3yFhSkjUDpnCIUhLWVX23KQ+L9vKvFKI0ZWFQgkDLvBoylrHNVmaw10zwCPrr5tlodfnf94EWnQ0lFRWy8pW9LbkLsyUVDc2NSTHGDtnD1uMtchjbCeb1mpxFP0YbcClhzdLu6lfO8Bj6q+bdT2sz/+8SZCV7VIxtt0DUn9L7r4cLYWDSXnseEpOGFuty0qbOVlS7NNzs5FOGJUqQpl2Q64/yBpZf90sxbE+//PGdZ02HSipCbmD6NItmQ4Lk5XUrGpDMkhbMm2ZVheNYV+VbUWTcv99+2NyX1VoafSuC+AN6q9bFIMv5X/eagNWXZxEa9JjlMwNWb00akGUkSoepp1/yRuuqHGbUn3UdBSTxBU6SEVklzWRUkPndVvw2PrrpjvxOvzPmwHc0hpmq82npi7GRro8dXp0KXnUQmhZbRL7NEVp1uuZmO45vuzKsHrktS3GLWXODVjw+vXXLYx4Hf7njRPd0i3aoAGX6W29GnaV5YdyDj9TFkakje7GHYzDoObfddHtOSpoi2SmzJHrB3hM/XUDDEbxP2/oosszcRlehWXUvzHv4TpBVktHqwenFo8uLVmy4DKLa5d3RtLrmrM3aMFr1183E4sewf+85VWeg1c5ag276NZrM9IJVNcmLEvDNaV62aq+14IAOGFsBt973Ra8Xv11YzXwNfmft7Jg2oS+XOyoC8/cwzi66Dhmgk38kUmP1CUiYWOX1bpD2zWXt2FCp7uq8703APAa9dfNdscR/M/bZLIyouVxqJfeWvG9Je+JVckHQ9+CI9NWxz+blX/KYYvO5n2tAP/vrlZ7+8/h9y+9qeB/Hnt967e5mevX10rALDWK//FaAT5MXdBXdP0C/BAes792c40H+AiAp1e1oH8HgH94g/Lttx1gp63op1eyoM/Bvw5/G/7xFbqJPcCXnmBiwDPb/YKO4FX4OjyCb289db2/Noqicw4i7N6TVtoz8tNwDH+8x/i6Ae7lmaQVENzJFb3Di/BFeAwz+Is9SjeQySpPqbLFlNmyz47z5a/AF+AYFvDmHqibSXTEzoT4Gc3OALaqAP4KPFUJ6n+1x+rGAM6Zd78bgJ0a8QN4GU614vxwD9e1Amy6CcskNrczLx1JIp6HE5UZD/DBHrFr2oNlgG4Odv226BodoryjGJ9q2T/AR3vQrsOCS0ctXZi3ruLlhpFDJYl4HmYtjQCP9rhdn4suySLKDt6wLcC52h8xPlcjju1fn+yhuw4LZsAGUuo2b4Fx2UwQu77uqRHXGtg92aN3tQCbFexc0uk93vhTXbct6y7MulLycoUljx8ngDMBg1tvJjAazpEmOtxlzclvj1vQf1Tx7QlPDpGpqgtdSKz/d9/hdy1vTfFHSmC9dGDZbLiezz7Ac801HirGZsWjydfZyPvHXL/Y8Mjzg8BxTZiuwKz4Eb8sBE9zznszmjvFwHKPIWUnwhqfVRcd4Ck0K6ate48m1oOfrX3/yOtvAsJ8zsPAM89sjnddmuLuDPjX9Bu/L7x7xpMzFk6nWtyQfPg278Gn4Aekz2ZgOmU9eJ37R14vwE/BL8G3aibCiWMWWDQ0ZtkPMnlcGeAu/Ag+8ZyecU5BPuy2ILD+sQqyZhAKmn7XZd+jIMTN9eBL7x95xVLSX4On8EcNlXDqmBlqS13jG4LpmGbkF/0CnOi3H8ETOIXzmnmtb0a16Tzxj1sUvQCBiXZGDtmB3KAefPH94xcUa/6vwRn80GOFyjEXFpba4A1e8KQfFF+259tx5XS4egYn8fQsLGrqGrHbztr+uByTahWuL1NUGbDpsnrwBfePPwHHIf9X4RnM4Z2ABWdxUBlqQ2PwhuDxoS0vvqB1JzS0P4h2nA/QgTrsJFn+Y3AOjs9JFC07CGWX1oNX3T/yHOzgDjwPn1PM3g9Jk9lZrMEpxnlPmBbjyo2+KFXRU52TJM/2ALcY57RUzjObbjqxVw++4P6RAOf58pcVsw9Daje3htriYrpDOonre3CudSe6bfkTEgHBHuDiyu5MCsc7BHhYDx7ePxLjqigXZsw+ijMHFhuwBmtoTPtOxOrTvYJDnC75dnUbhfwu/ZW9AgYd+peL68HD+0emKquiXHhWjJg/UrkJYzuiaL3E9aI/ytrCvAd4GcYZMCkSQxfUg3v3j8c4e90j5ZTPdvmJJGHnOCI2nHS8081X013pHuBlV1gB2MX1YNmWLHqqGN/TWmG0y6clJWthxNUl48q38Bi8vtMKyzzpFdSDhxZ5WBA5ZLt8Jv3895DduBlgbPYAj8C4B8hO68FDkoh5lydC4FiWvBOVqjYdqjiLv92t8yPDjrDaiHdUD15qkSURSGmXJwOMSxWAXYwr3zaAufJ66l+94vv3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/wHuD9tQd4f+0B3l97gPfXHuD9tQd4f+0B3l97gG8LwP8G/AL8O/A5OCq0Ys2KIdv/qOIXG/4mvFAMF16gZD+2Xvu/B8as5+8bfllWyg0zaNO5bfXj6vfhhwD86/Aq3NfRS9t9WPnhfnvCIw/CT8GLcFTMnpntdF/z9V+PWc/vWoIH+FL3Znv57PitcdGP4R/C34avw5fgRVUInCwbsn1yyA8C8zm/BH8NXoXnVE6wVPjdeCI38kX/3+Ct9dbz1pTmHFRu+Hm4O9Ch3clr99negxfwj+ER/DR8EV6B5+DuQOnTgUw5rnkY+FbNU3gNXh0o/JYTuWOvyBf9FvzX663HH/HejO8LwAl8Hl5YLTd8q7sqA3wbjuExfAFegQdwfyDoSkWY8swzEf6o4Qyewefg+cHNbqMQruSL/u/WWc+E5g7vnnEXgDmcDeSGb/F4cBcCgT+GGRzDU3hZYburAt9TEtHgbM6JoxJ+6NMzzTcf6c2bycv2+KK/f+l6LBzw5IwfqZJhA3M472pWT/ajKxnjv4AFnMEpnBTPND6s2J7qHbPAqcMK74T2mZ4VGB9uJA465It+/eL1WKhYOD7xHOkr1ajK7d0C4+ke4Hy9qXZwpgLr+Znm/uNFw8xQOSy8H9IzjUrd9+BIfenYaylf9FsXr8fBAadnPIEDna8IBcwlxnuA0/Wv6GAWPd7dDIKjMdSWueAsBj4M7TOd06qBbwDwKr7oleuxMOEcTuEZTHWvDYUO7aHqAe0Bbq+HEFRzOz7WVoTDQkVds7A4sIIxfCQdCefFRoIOF/NFL1mPab/nvOakSL/Q1aFtNpUb/nFOVX6gzyg/1nISyDfUhsokIzaBR9Kxm80s5mK+6P56il1jXic7nhQxsxSm3OwBHl4fFdLqi64nDQZvqE2at7cWAp/IVvrN6/BFL1mPhYrGMBfOi4PyjuSGf6wBBh7p/FZTghCNWGgMzlBbrNJoPJX2mW5mwZfyRffXo7OFi5pZcS4qZUrlViptrXtw+GQoyhDPS+ANjcGBNRiLCQDPZPMHuiZfdFpPSTcQwwKYdRNqpkjm7AFeeT0pJzALgo7g8YYGrMHS0iocy+YTm2vyRUvvpXCIpQ5pe666TJrcygnScUf/p0NDs/iAI/nqDHC8TmQT8x3NF91l76oDdQGwu61Z6E0ABv7uO1dbf/37Zlv+Zw/Pbh8f1s4Avur6657/+YYBvur6657/+YYBvur6657/+YYBvur6657/+aYBvuL6657/+VMA8FXWX/f8zzcN8BXXX/f8zzcNMFdbf93zP38KLPiK6697/uebtuArrr/u+Z9vGmCusP6653/+1FjwVdZf9/zPN7oHX339dc//fNMu+irrr3v+50+Bi+Zq6697/uebA/jz8Pudf9ht/fWv517J/XUzAP8C/BAeX9WCDrUpZ3/dEMBxgPcfbtTVvsYV5Yn32u03B3Ac4P3b8I+vxNBKeeL9dRMAlwO83959qGO78sT769oB7g3w/vGVYFzKE++v6wV4OMD7F7tckFkmT7y/rhHgpQO8b+4Y46XyxPvrugBeNcB7BRiX8sT767oAvmCA9woAHsoT76+rBJjLBnh3txOvkifeX1dswZcO8G6N7sXyxPvr6i340gHe3TnqVfLE++uKAb50gHcXLnrX8sR7gNdPRqwzwLu7Y/FO5Yn3AK9jXCMGeHdgxDuVJ75VAI8ljP7PAb3/RfjcZfePHBB+79dpfpH1CanN30d+mT1h9GqAxxJGM5LQeeQ1+Tb+EQJrElLb38VHQ94TRq900aMIo8cSOo+8Dp8QfsB8zpqE1NO3OI9Zrj1h9EV78PqE0WMJnUdeU6E+Jjyk/hbrEFIfeWbvId8H9oTRFwdZaxJGvziW0Hn0gqYB/wyZ0PwRlxJST+BOw9m77Amj14ii1yGM/txYQudN0qDzGe4EqfA/5GJCagsHcPaEPWH0esekSwmjRxM6b5JEcZ4ww50ilvAOFxBSx4yLW+A/YU8YvfY5+ALC6NGEzhtmyZoFZoarwBLeZxUhtY4rc3bKnjB6TKJjFUHzJoTOozF2YBpsjcyxDgzhQ1YRUse8+J4wenwmaylB82hC5w0zoRXUNXaRBmSMQUqiWSWkLsaVqc/ZE0aPTFUuJWgeTei8SfLZQeMxNaZSIzbII4aE1Nmr13P2hNHjc9E9guYNCZ032YlNwESMLcZiLQHkE4aE1BFg0yAR4z1h9AiAGRA0jyZ03tyIxWMajMPWBIsxYJCnlITU5ShiHYdZ94TR4wCmSxg9jtB5KyPGYzymAYexWEMwAPIsAdYdV6aObmNPGD0aYLoEzaMJnTc0Ygs+YDw0GAtqxBjkuP38bMRWCHn73xNGjz75P73WenCEJnhwyVe3AEe8TtKdJcYhBl97wuhNAObK66lvD/9J9NS75v17wuitAN5fe4D31x7g/bUHeH/tAd5fe4D3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/w/toDvAd4f/24ABzZ8o+KLsSLS+Pv/TqTb3P4hKlQrTGh+fbIBT0Axqznnb+L/V2mb3HkN5Mb/nEHeK7d4IcDld6lmDW/iH9E+AH1MdOw/Jlu2T1xNmY98sv4wHnD7D3uNHu54WUuOsBTbQuvBsPT/UfzNxGYzwkP8c+Yz3C+r/i6DcyRL/rZ+utRwWH5PmfvcvYEt9jLDS/bg0/B64DWKrQM8AL8FPwS9beQCe6EMKNZYJol37jBMy35otdaz0Bw2H/C2Smc7+WGB0HWDELBmOByA3r5QONo4V+DpzR/hFS4U8wMW1PXNB4TOqYz9urxRV++ntWCw/U59Ty9ebdWbrgfRS9AYKKN63ZokZVygr8GZ/gfIhZXIXPsAlNjPOLBby5c1eOLvmQ9lwkOy5x6QV1j5TYqpS05JtUgUHUp5toHGsVfn4NX4RnMCe+AxTpwmApTYxqMxwfCeJGjpXzRF61nbcHhUBPqWze9svwcHJ+S6NPscKrEjug78Dx8Lj3T8D4YxGIdxmJcwhi34fzZUr7olevZCw5vkOhoClq5zBPZAnygD/Tl9EzDh6kl3VhsHYcDEb+hCtJSvuiV69kLDm+WycrOTArHmB5/VYyP6jOVjwgGawk2zQOaTcc1L+aLXrKeveDwZqlKrw8U9Y1p66uK8dEzdYwBeUQAY7DbyYNezBfdWQ97weEtAKYQg2xJIkuveAT3dYeLGH+ShrWNwZgN0b2YL7qznr3g8JYAo5bQBziPjx7BPZ0d9RCQp4UZbnFdzBddor4XHN4KYMrB2qHFRIzzcLAHQZ5the5ovui94PCWAPefaYnxIdzRwdHCbuR4B+tbiy96Lzi8E4D7z7S0mEPd+eqO3cT53Z0Y8SV80XvB4Z0ADJi/f7X113f+7p7/+UYBvur6657/+YYBvur6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+VMA8FXWX/f8z58OgK+y/rrnf75RgLna+uue//lTA/CV1V/3/M837aKvvv6653++UQvmauuve/7nTwfAV1N/3fM/fzr24Cuuv+75nz8FFnxl9dc9//MOr/8/glixwRuUfM4AAAAASUVORK5CYII=";
					}
					getSearchTexture() {
						return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII=";
					}
				}
				const iv = {
					shaderID: "luminosityHighPass",
					uniforms: { tDiffuse: { value: null }, luminosityThreshold: { value: 1 }, smoothWidth: { value: 1 }, defaultColor: { value: new mn(0) }, defaultOpacity: { value: 0 } },
					vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
					fragmentShader:
						"\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec3 defaultColor;\n\t\tuniform float defaultOpacity;\n\t\tuniform float luminosityThreshold;\n\t\tuniform float smoothWidth;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\tvec3 luma = vec3( 0.299, 0.587, 0.114 );\n\n\t\t\tfloat v = dot( texel.xyz, luma );\n\n\t\t\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\n\t\t\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\n\t\t\tgl_FragColor = mix( outputColor, texel, alpha );\n\n\t\t}",
				};
				class rv extends Gm {
					constructor(t, e, n, i) {
						super(), (this.strength = void 0 !== e ? e : 1), (this.radius = n), (this.threshold = i), (this.resolution = void 0 !== t ? new Ot(t.x, t.y) : new Ot(256, 256)), (this.clearColor = new mn(0, 0, 0));
						const r = { minFilter: X, magFilter: X, format: et };
						(this.renderTargetsHorizontal = []), (this.renderTargetsVertical = []), (this.nMips = 5);
						let a = Math.round(this.resolution.x / 2),
							s = Math.round(this.resolution.y / 2);
						(this.renderTargetBright = new Gt(a, s, r)), (this.renderTargetBright.texture.name = "UnrealBloomPass.bright"), (this.renderTargetBright.texture.generateMipmaps = !1);
						for (let t = 0; t < this.nMips; t++) {
							const e = new Gt(a, s, r);
							(e.texture.name = "UnrealBloomPass.h" + t), (e.texture.generateMipmaps = !1), this.renderTargetsHorizontal.push(e);
							const n = new Gt(a, s, r);
							(n.texture.name = "UnrealBloomPass.v" + t), (n.texture.generateMipmaps = !1), this.renderTargetsVertical.push(n), (a = Math.round(a / 2)), (s = Math.round(s / 2));
						}
						void 0 === iv && console.error("THREE.UnrealBloomPass relies on LuminosityHighPassShader");
						const o = iv;
						(this.highPassUniforms = $n.clone(o.uniforms)), (this.highPassUniforms.luminosityThreshold.value = i), (this.highPassUniforms.smoothWidth.value = 0.01), (this.materialHighPassFilter = new ti({ uniforms: this.highPassUniforms, vertexShader: o.vertexShader, fragmentShader: o.fragmentShader, defines: {} })), (this.separableBlurMaterials = []);
						const l = [3, 5, 7, 9, 11];
						(a = Math.round(this.resolution.x / 2)), (s = Math.round(this.resolution.y / 2));
						for (let t = 0; t < this.nMips; t++) this.separableBlurMaterials.push(this.getSeperableBlurMaterial(l[t])), (this.separableBlurMaterials[t].uniforms.texSize.value = new Ot(a, s)), (a = Math.round(a / 2)), (s = Math.round(s / 2));
						(this.compositeMaterial = this.getCompositeMaterial(this.nMips)),
							(this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture),
							(this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture),
							(this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture),
							(this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture),
							(this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture),
							(this.compositeMaterial.uniforms.bloomStrength.value = e),
							(this.compositeMaterial.uniforms.bloomRadius.value = 0.1),
							(this.compositeMaterial.needsUpdate = !0);
						(this.compositeMaterial.uniforms.bloomFactors.value = [1, 0.8, 0.6, 0.4, 0.2]), (this.bloomTintColors = [new Xt(1, 1, 1), new Xt(1, 1, 1), new Xt(1, 1, 1), new Xt(1, 1, 1), new Xt(1, 1, 1)]), (this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors), void 0 === Hm && console.error("THREE.UnrealBloomPass relies on CopyShader");
						const c = Hm;
						(this.copyUniforms = $n.clone(c.uniforms)), (this.copyUniforms.opacity.value = 1), (this.materialCopy = new ti({ uniforms: this.copyUniforms, vertexShader: c.vertexShader, fragmentShader: c.fragmentShader, blending: 2, depthTest: !1, depthWrite: !1, transparent: !0 })), (this.enabled = !0), (this.needsSwap = !1), (this._oldClearColor = new mn()), (this.oldClearAlpha = 1), (this.basic = new vn()), (this.fsQuad = new Xm(null));
					}
					dispose() {
						for (let t = 0; t < this.renderTargetsHorizontal.length; t++) this.renderTargetsHorizontal[t].dispose();
						for (let t = 0; t < this.renderTargetsVertical.length; t++) this.renderTargetsVertical[t].dispose();
						this.renderTargetBright.dispose();
					}
					setSize(t, e) {
						let n = Math.round(t / 2),
							i = Math.round(e / 2);
						this.renderTargetBright.setSize(n, i);
						for (let t = 0; t < this.nMips; t++) this.renderTargetsHorizontal[t].setSize(n, i), this.renderTargetsVertical[t].setSize(n, i), (this.separableBlurMaterials[t].uniforms.texSize.value = new Ot(n, i)), (n = Math.round(n / 2)), (i = Math.round(i / 2));
					}
					render(t, e, n, i, r) {
						t.getClearColor(this._oldClearColor), (this.oldClearAlpha = t.getClearAlpha());
						const a = t.autoClear;
						(t.autoClear = !1),
							t.setClearColor(this.clearColor, 0),
							r && t.state.buffers.stencil.setTest(!1),
							this.renderToScreen && ((this.fsQuad.material = this.basic), (this.basic.map = n.texture), t.setRenderTarget(null), t.clear(), this.fsQuad.render(t)),
							(this.highPassUniforms.tDiffuse.value = n.texture),
							(this.highPassUniforms.luminosityThreshold.value = this.threshold),
							(this.fsQuad.material = this.materialHighPassFilter),
							t.setRenderTarget(this.renderTargetBright),
							t.clear(),
							this.fsQuad.render(t);
						let s = this.renderTargetBright;
						for (let e = 0; e < this.nMips; e++)
							(this.fsQuad.material = this.separableBlurMaterials[e]),
								(this.separableBlurMaterials[e].uniforms.colorTexture.value = s.texture),
								(this.separableBlurMaterials[e].uniforms.direction.value = rv.BlurDirectionX),
								t.setRenderTarget(this.renderTargetsHorizontal[e]),
								t.clear(),
								this.fsQuad.render(t),
								(this.separableBlurMaterials[e].uniforms.colorTexture.value = this.renderTargetsHorizontal[e].texture),
								(this.separableBlurMaterials[e].uniforms.direction.value = rv.BlurDirectionY),
								t.setRenderTarget(this.renderTargetsVertical[e]),
								t.clear(),
								this.fsQuad.render(t),
								(s = this.renderTargetsVertical[e]);
						(this.fsQuad.material = this.compositeMaterial),
							(this.compositeMaterial.uniforms.bloomStrength.value = this.strength),
							(this.compositeMaterial.uniforms.bloomRadius.value = this.radius),
							(this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors),
							t.setRenderTarget(this.renderTargetsHorizontal[0]),
							t.clear(),
							this.fsQuad.render(t),
							(this.fsQuad.material = this.materialCopy),
							(this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture),
							r && t.state.buffers.stencil.setTest(!0),
							this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(n), this.fsQuad.render(t)),
							t.setClearColor(this._oldClearColor, this.oldClearAlpha),
							(t.autoClear = a);
					}
					getSeperableBlurMaterial(t) {
						return new ti({
							defines: { KERNEL_RADIUS: t, SIGMA: t },
							uniforms: { colorTexture: { value: null }, texSize: { value: new Ot(0.5, 0.5) }, direction: { value: new Ot(0.5, 0.5) } },
							vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
							fragmentShader:
								"#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat fSigma = float(SIGMA);\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}",
						});
					}
					getCompositeMaterial(t) {
						return new ti({
							defines: { NUM_MIPS: t },
							uniforms: { blurTexture1: { value: null }, blurTexture2: { value: null }, blurTexture3: { value: null }, blurTexture4: { value: null }, blurTexture5: { value: null }, dirtTexture: { value: null }, bloomStrength: { value: 1 }, bloomFactors: { value: null }, bloomTintColors: { value: null }, bloomRadius: { value: 0 } },
							vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
							fragmentShader:
								"varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform sampler2D dirtTexture;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}",
						});
					}
				}
				(rv.BlurDirectionX = new Ot(1, 0)), (rv.BlurDirectionY = new Ot(0, 1));
				const av = {
					defines: { DEPTH_PACKING: 1, PERSPECTIVE_CAMERA: 1 },
					uniforms: { tColor: { value: null }, tDepth: { value: null }, focus: { value: 1 }, aspect: { value: 1 }, aperture: { value: 0.025 }, maxblur: { value: 0.01 }, nearClip: { value: 1 }, farClip: { value: 1e3 } },
					vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
					fragmentShader:
						"\n\n\t\t#include <common>\n\n\t\tvarying vec2 vUv;\n\n\t\tuniform sampler2D tColor;\n\t\tuniform sampler2D tDepth;\n\n\t\tuniform float maxblur; // max blur amount\n\t\tuniform float aperture; // aperture - bigger values for shallower depth of field\n\n\t\tuniform float nearClip;\n\t\tuniform float farClip;\n\n\t\tuniform float focus;\n\t\tuniform float aspect;\n\n\t\t#include <packing>\n\n\t\tfloat getDepth( const in vec2 screenPosition ) {\n\t\t\t#if DEPTH_PACKING == 1\n\t\t\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\n\t\t\t#else\n\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\t\t\t#endif\n\t\t}\n\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\t\t\treturn perspectiveDepthToViewZ( depth, nearClip, farClip );\n\t\t\t#else\n\t\t\treturn orthographicDepthToViewZ( depth, nearClip, farClip );\n\t\t\t#endif\n\t\t}\n\n\n\t\tvoid main() {\n\n\t\t\tvec2 aspectcorrect = vec2( 1.0, aspect );\n\n\t\t\tfloat viewZ = getViewZ( getDepth( vUv ) );\n\n\t\t\tfloat factor = ( focus + viewZ ); // viewZ is <= 0, so this is a difference equation\n\n\t\t\tvec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );\n\n\t\t\tvec2 dofblur9 = dofblur * 0.9;\n\t\t\tvec2 dofblur7 = dofblur * 0.7;\n\t\t\tvec2 dofblur4 = dofblur * 0.4;\n\n\t\t\tvec4 col = vec4( 0.0 );\n\n\t\t\tcol += texture2D( tColor, vUv.xy );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );\n\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\n\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );\n\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );\n\n\t\t\tgl_FragColor = col / 41.0;\n\t\t\tgl_FragColor.a = 1.0;\n\n\t\t}",
				};
				class sv extends Gm {
					constructor(t, e, n) {
						super(), (this.scene = t), (this.camera = e);
						const i = void 0 !== n.focus ? n.focus : 1,
							r = void 0 !== n.aspect ? n.aspect : e.aspect,
							a = void 0 !== n.aperture ? n.aperture : 0.025,
							s = void 0 !== n.maxblur ? n.maxblur : 1,
							o = n.width || window.innerWidth || 1,
							l = n.height || window.innerHeight || 1;
						(this.renderTargetDepth = new Gt(o, l, { minFilter: G, magFilter: G })), (this.renderTargetDepth.texture.name = "BokehPass.depth"), (this.materialDepth = new Ga()), (this.materialDepth.depthPacking = 3201), (this.materialDepth.blending = 0), void 0 === av && console.error("THREE.BokehPass relies on BokehShader");
						const c = av,
							u = $n.clone(c.uniforms);
						(u.tDepth.value = this.renderTargetDepth.texture), (u.focus.value = i), (u.aspect.value = r), (u.aperture.value = a), (u.maxblur.value = s), (u.nearClip.value = e.near), (u.farClip.value = e.far), (this.materialBokeh = new ti({ defines: Object.assign({}, c.defines), uniforms: u, vertexShader: c.vertexShader, fragmentShader: c.fragmentShader })), (this.uniforms = u), (this.needsSwap = !1), (this.fsQuad = new Xm(this.materialBokeh)), (this._oldClearColor = new mn());
					}
					render(t, e, n) {
						(this.scene.overrideMaterial = this.materialDepth), t.getClearColor(this._oldClearColor);
						const i = t.getClearAlpha(),
							r = t.autoClear;
						(t.autoClear = !1),
							t.setClearColor(16777215),
							t.setClearAlpha(1),
							t.setRenderTarget(this.renderTargetDepth),
							t.clear(),
							t.render(this.scene, this.camera),
							(this.uniforms.tColor.value = n.texture),
							(this.uniforms.nearClip.value = this.camera.near),
							(this.uniforms.farClip.value = this.camera.far),
							this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), t.clear(), this.fsQuad.render(t)),
							(this.scene.overrideMaterial = null),
							t.setClearColor(this._oldClearColor),
							t.setClearAlpha(i),
							(t.autoClear = r);
					}
				}
				var ov = (function () {
					function t(e) {
						var n = e.renderer,
							i = e.scene,
							r = e.camera;
						s(this, t), (this.scene = i), (this.camera = r), (this.renderer = n), (this.composer = {}), this.init(), this.createPasses(), this.addPasses(), this.onUpdateParams(), this.onResize(), this.bindEvents();
					}
					return (
						c(t, [
							{
								key: "bindEvents",
								value: function () {
									var t = this;
									document.addEventListener("layout:change", function () {
										return t.onResize();
									}),
										document.addEventListener("gui:change:enableDof", function () {
											return t.onUpdateParams();
										}),
										document.addEventListener("gui:change:enableBloom", function () {
											return t.onUpdateParams();
										}),
										document.addEventListener("gui:change:strength", function () {
											return t.onUpdateParams();
										}),
										document.addEventListener("gui:change:radius", function () {
											return t.onUpdateParams();
										}),
										document.addEventListener("gui:change:threshold", function () {
											return t.onUpdateParams();
										});
								},
							},
							{
								key: "init",
								value: function () {
									var t = this.renderer,
										e = this.scene,
										n = this.camera,
										i = new (1 === t.getPixelRatio() && t.capabilities.isWebGL2 ? Wt : Gt)();
									(this.finalComposer = new Km(t, i)), (this.composer.finalComposer = this.finalComposer);
									var r = new Qm(e, n);
									this.finalComposer.addPass(r);
								},
							},
							{
								key: "onResize",
								value: function () {
									var t = Layout,
										e = t.W,
										n = t.H,
										i = t.PR;
									this.finalComposer.setSize(e * i, n * i), this.smaaPass && this.smaaPass.setSize(e, n), this.bloomPass && this.bloomPass.setSize(e, n), this.bokehPass && this.bokehPass.setSize(e, n), this.concentratePass && this.concentratePass.setSize(e, n);
								},
							},
							{
								key: "onUpdateParams",
								value: function () {
									var t = af.strength,
										e = af.radius,
										n = af.threshold,
										i = af.enableDof,
										r = af.enableBloom;
									this.bloomPass && ((this.bloomPass.strength = t.uniform.value), (this.bloomPass.radius = e.uniform.value), (this.bloomPass.threshold = n.uniform.value), (this.bloomPass.enabled = r.uniform.value)), this.bokehPass && (this.bokehPass.enabled = i.uniform.value);
								},
							},
							{
								key: "createPasses",
								value: function () {
									var t = af.strength,
										e = af.radius,
										n = af.threshold,
										i = af.focus,
										r = af.maxblur,
										a = af.aperture,
										s = (af.fishEye, af.distortionFishEye, Layout),
										o = s.W,
										l = s.H;
									1 !== s.PR || this.renderer.capabilities.isWebGL2 || (this.smaaPass = new nv(o, l)),
										(this.bloomPass = new rv(new Ot(o, l), t.uniform.value, e.uniform.value, n.uniform.value)),
										(this.bokehPass = new sv(this.scene, this.camera, { focus: 100, aperture: 0.03, maxblur: 0.01, width: o, height: l })),
										(this.bokehPass.uniforms.focus = i.uniform),
										(this.bokehPass.uniforms.maxblur = r.uniform),
										(this.bokehPass.uniforms.aperture = a.uniform),
										(this.bokehPass.materialBokeh.uniformsNeedUpdate = !0);
								},
							},
							{
								key: "addPasses",
								value: function () {
									this.smaaPass && this.finalComposer.addPass(this.smaaPass), this.bloomPass && this.finalComposer.addPass(this.bloomPass), this.bokehPass && this.finalComposer.addPass(this.bokehPass);
								},
							},
							{
								key: "render",
								value: function () {
									this.finalComposer.render();
								},
							},
						]),
						t
					);
				})();
				function lv(t, e, n, i) {
					return new (n || (n = Promise))(function (r, a) {
						function s(t) {
							try {
								l(i.next(t));
							} catch (t) {
								a(t);
							}
						}
						function o(t) {
							try {
								l(i.throw(t));
							} catch (t) {
								a(t);
							}
						}
						function l(t) {
							var e;
							t.done
								? r(t.value)
								: ((e = t.value),
								  e instanceof n
										? e
										: new n(function (t) {
												t(e);
										  })).then(s, o);
						}
						l((i = i.apply(t, e || [])).next());
					});
				}
				const cv = [
						"geforce 320m",
						"geforce 8600",
						"geforce 8600m gt",
						"geforce 8800 gs",
						"geforce 8800 gt",
						"geforce 9400",
						"geforce 9400m g",
						"geforce 9400m",
						"geforce 9600m gt",
						"geforce 9600m",
						"geforce fx go5200",
						"geforce gt 120",
						"geforce gt 130",
						"geforce gt 330m",
						"geforce gtx 285",
						"google swiftshader",
						"intel g41",
						"intel g45",
						"intel gma 4500mhd",
						"intel gma x3100",
						"intel hd 3000",
						"intel q45",
						"legacy",
						"mali-2",
						"mali-3",
						"mali-4",
						"quadro fx 1500",
						"quadro fx 4",
						"quadro fx 5",
						"radeon hd 2400",
						"radeon hd 2600",
						"radeon hd 4670",
						"radeon hd 4850",
						"radeon hd 4870",
						"radeon hd 5670",
						"radeon hd 5750",
						"radeon hd 6290",
						"radeon hd 6300",
						"radeon hd 6310",
						"radeon hd 6320",
						"radeon hd 6490m",
						"radeon hd 6630m",
						"radeon hd 6750m",
						"radeon hd 6770m",
						"radeon hd 6970m",
						"radeon r9 200",
						"sgx 543",
						"sgx543",
					],
					uv = (t) =>
						t
							.toLowerCase()
							.replace(/^angle ?\((.+)\)*$/, "$1")
							.replace(/\s(\d{1,2}gb|direct3d.+$)|\(r\)| \([^)]+\)$/g, ""),
					hv = "undefined" == typeof window,
					dv = (() => {
						if (hv) return;
						const { userAgent: t, platform: e, maxTouchPoints: n } = window.navigator,
							i = /(iphone|ipod|ipad)/i.test(t),
							r = "iPad" === e || ("MacIntel" === e && n > 0 && !window.MSStream);
						return { isIpad: r, isMobile: /android/i.test(t) || i || r, isSafari12: /Version\/12.+Safari/.test(t) };
					})(),
					pv = [],
					fv = [],
					mv = (t, e) => {
						if (t === e) return 0;
						const n = t;
						t.length > e.length && ((t = e), (e = n));
						let i = t.length,
							r = e.length;
						for (; i > 0 && t.charCodeAt(~-i) === e.charCodeAt(~-r); ) i--, r--;
						let a,
							s = 0;
						for (; s < i && t.charCodeAt(s) === e.charCodeAt(s); ) s++;
						if (((i -= s), (r -= s), 0 === i)) return r;
						let o,
							l,
							c = 0,
							u = 0,
							h = 0;
						for (; u < i; ) (fv[u] = t.charCodeAt(s + u)), (pv[u] = ++u);
						for (; h < r; ) for (a = e.charCodeAt(s + h), o = h++, c = h, u = 0; u < i; u++) (l = a === fv[u] ? o : o + 1), (o = pv[u]), (c = pv[u] = o > c ? (l > c ? c + 1 : l) : l > o ? o + 1 : l);
						return c;
					},
					vv = ({ mobileTiers: t = [0, 15, 30, 60], desktopTiers: e = [0, 15, 30, 60], override: n = {}, glContext: i, failIfMajorPerformanceCaveat: r = !1, benchmarksURL: a = "https://unpkg.com/detect-gpu@3.1.25/dist/benchmarks" } = {}) =>
						lv(void 0, void 0, void 0, function* () {
							const s = {};
							if (hv) return { tier: 0, type: "SSR" };
							const {
								isIpad: o = !!(null == dv ? void 0 : dv.isIpad),
								isMobile: l = !!(null == dv ? void 0 : dv.isMobile),
								screenSize: c = window.screen,
								loadBenchmarks: u = (t) =>
									lv(void 0, void 0, void 0, function* () {
										const e = yield fetch(`${a}/${t}`).then((t) => t.json());
										return e.shift(), e;
									}),
							} = n;
							let { renderer: h } = n;
							const d = (t, e, n, i, r) => ({ device: r, fps: i, gpu: n, isMobile: l, tier: t, type: e });
							let p,
								f = "";
							if (h) (h = uv(h)), (p = [h]);
							else {
								const t =
									i ||
									((t, e = !1) => {
										const n = { alpha: !1, antialias: !1, depth: !1, failIfMajorPerformanceCaveat: e, powerPreference: "high-performance", stencil: !1 };
										t && delete n.powerPreference;
										const i = window.document.createElement("canvas"),
											r = i.getContext("webgl", n) || i.getContext("experimental-webgl", n);
										return null != r ? r : void 0;
									})(null == dv ? void 0 : dv.isSafari12, r);
								if (!t) return d(0, "WEBGL_UNSUPPORTED");
								const e = t.getExtension("WEBGL_debug_renderer_info");
								if ((e && (h = t.getParameter(e.UNMASKED_RENDERER_WEBGL)), !h)) return d(1, "FALLBACK");
								(f = h),
									(h = uv(h)),
									(p = ((t, e, n) =>
										"apple gpu" === e
											? ((t, e, n) => {
													let i = [e];
													if (n) {
														const e = "\n      precision highp float;\n      attribute vec3 aPosition;\n      varying float vvv;\n      void main() {\n        vvv = 0.31622776601683794;\n        gl_Position = vec4(aPosition, 1.0);\n      }\n    ",
															n = "\n      precision highp float;\n      varying float vvv;\n      void main() {\n        vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * vvv;\n        enc = fract(enc);\n        enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n        gl_FragColor = enc;\n      }\n    ",
															r = t.createShader(35633),
															a = t.createShader(35632),
															s = t.createProgram();
														if (a && r && s) {
															t.shaderSource(r, e), t.shaderSource(a, n), t.compileShader(r), t.compileShader(a), t.attachShader(s, r), t.attachShader(s, a), t.linkProgram(s), t.detachShader(s, r), t.detachShader(s, a), t.deleteShader(r), t.deleteShader(a), t.useProgram(s);
															const o = t.createBuffer();
															t.bindBuffer(34962, o), t.bufferData(34962, new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), 35044);
															const l = t.getAttribLocation(s, "aPosition");
															t.vertexAttribPointer(l, 3, 5126, !1, 0, 0), t.enableVertexAttribArray(l), t.clearColor(1, 1, 1, 1), t.clear(16384), t.viewport(0, 0, 1, 1), t.drawArrays(4, 0, 3);
															const c = new Uint8Array(4);
															t.readPixels(0, 0, 1, 1, 6408, 5121, c), t.deleteProgram(s), t.deleteBuffer(o), (i = { 801621810: (null == dv ? void 0 : dv.isIpad) ? ["apple a12x gpu"] : ["apple a11 gpu", "apple a12 gpu", "apple a13 gpu", "apple a14 gpu"], 8016218135: (null == dv ? void 0 : dv.isIpad) ? ["apple a9x gpu", "apple a10 gpu", "apple a10x gpu"] : ["apple a9 gpu", "apple a10 gpu"] }[c.join("")] || i);
														}
													}
													return i;
											  })(t, e, n)
											: [e])(t, h, l));
							}
							const m = (yield Promise.all(
								p.map((t) =>
									lv(void 0, void 0, void 0, function* () {
										const e = ((t) => {
											const e = l ? ["adreno", "apple", "mali-t", "mali", "nvidia", "powervr"] : ["intel", "amd", "radeon", "nvidia", "geforce"];
											for (const n of e) if (t.includes(n)) return n;
										})(t);
										if (!e) return;
										const n = `${l ? "m" : "d"}-${e}.json`,
											i = (s[n] = s[n] || u(n));
										let r;
										try {
											r = yield i;
										} catch (e) {
											return;
										}
										const a = ((t) => {
												var e;
												const n = (t = t.replace(/\([^)]+\)/, "")).match(/\d+/) || t.match(/(\W|^)([A-Za-z]{1,3})(\W|$)/g);
												return null !== (e = null == n ? void 0 : n.join("").replace(/\W|amd/g, "")) && void 0 !== e ? e : "";
											})(t),
											h = "apple" === e;
										let d = r.filter(([, t]) => t === a);
										d.length || (d = r.filter(([e]) => e.includes(t)));
										const p = d.length;
										if (0 === p) return;
										let f,
											[m, , , v] = p > 1 ? d.map((e) => [e, mv(t, e[0])]).sort(([, t], [, e]) => t - e)[0][0] : d[0],
											g = Number.MAX_VALUE;
										const { devicePixelRatio: b } = window,
											x = c.width * b * (c.height * b);
										h &&
											l &&
											(v = v.filter(([, , , t]) => {
												var e;
												return (null !== (e = null == t ? void 0 : t.indexOf(o ? "ipad" : "iphone")) && void 0 !== e ? e : -1) > -1;
											}));
										for (const t of v) {
											const [e, n] = t,
												i = e * n,
												r = Math.abs(x - i);
											r < g && ((g = r), (f = t));
										}
										if (!f) return;
										const [, , y, _] = f;
										return [g, y, m, _];
									})
								)
							)).filter((t) => !!t);
							if (!m.length) {
								const t = cv.find((t) => h.includes(t));
								return t ? d(0, "BLOCKLISTED", t) : d(1, "FALLBACK", `${h} (${f})`);
							}
							const [, v, g, b] = m.sort(([t = Number.MAX_VALUE], [e = Number.MAX_VALUE]) => t - e)[0];
							if (-1 === v) return d(0, "BLOCKLISTED", g, v, b);
							const x = l ? t : e;
							let y = 0;
							for (let t = 0; t < x.length; t++) v >= x[t] && (y = t);
							return d(y, "BENCHMARK", g, v, b);
						});
				var gv = { General: { Environment: ["timeScale", "amountParticles", "--", "normalScale", "mulValue"], Physics: ["lambda", "--", "attractionForce", "minSpeed", "maxSpeed", "--", "repulsion", "repulsionForce"] }, PostProcessing: { Dof: ["enableDof", "--", "focus", "maxblur", "aperture"], Bloom: ["enableBloom", "--", "strength", "radius", "threshold"] } },
					bv = (function () {
						function t(e) {
							s(this, t), (this.Stage = e), this.initController();
						}
						return (
							c(t, [
								{
									key: "initController",
									value: function () {
										var t, e;
										this.controller = gf.init(this.Stage, { stats: !0, gui: !0, control: !0, renderOnControl: !this.Stage.autoRender });
										var n = this.controller.gui.addTab({
												pages: _f()((t = am()(gv))).call(t, function (t) {
													return { title: t };
												}),
											}),
											i = !Browser.isMobile;
										Df()((e = n.pages)).call(e, function (t) {
											var e,
												n = t.title,
												r = gv[n];
											Df()((e = am()(r))).call(e, function (e) {
												var n = t.addFolder({ title: e, expanded: i }),
													a = r[e];
												Df()(a).call(a, function (t) {
													if ("--" === t) n.addSeparator();
													else {
														var e = af.get(t),
															i = e.uniform,
															r = e.min,
															a = e.max,
															s = e.label,
															o = e.step,
															l = e.options;
														n.addInput(i, "value", { label: s, min: r, max: a, step: o, options: l }).on("change", function (e) {
															Vc("gui:change:".concat(t), { value: e.value });
														});
													}
												});
											});
										});
									},
								},
								{
									key: "forceRefreshDebugUI",
									value: function () {
										this.controller.gui.refresh();
									},
								},
								{
									key: "beginStats",
									value: function () {
										this.controller.beginStats();
									},
								},
								{
									key: "endStats",
									value: function () {
										this.controller.endStats();
									},
								},
								{
									key: "update",
									value: function () {
										this.controller.update();
									},
								},
							]),
							t
						);
					})(),
					xv = (function () {
						function t() {
							var e = this;
							s(this, t),
								(this.$canvas = document.getElementById("stage")),
								(this.autoRender = !0),
								this.buildRenderer(),
								this.preload().then(function () {
									return e.init();
								});
						}
						var e;
						return (
							c(t, [
								{
									key: "preload",
									value:
										((e = a(
											p().mark(function t() {
												var e, n, i;
												return p().wrap(
													function (t) {
														for (;;)
															switch ((t.prev = t.next)) {
																case 0:
																	return (e = Browser), (n = e.isMobile), (t.next = 3), vv({ glContext: n ? null : this.renderer.getContext() });
																case 3:
																	(i = t.sent), (af.performance.value = i.tier), (af.performance.isMobile = i.isMobile);
																case 6:
																case "end":
																	return t.stop();
															}
													},
													t,
													this
												);
											})
										)),
										function () {
											return e.apply(this, arguments);
										}),
								},
								{
									key: "init",
									value: function () {
										this.buildCamera(), this.initScene(), this.initDebug(), this.initPostProcess(), this.autoRender ? this.renderer.toggleRender(!0) : this.renderStage(200), this.bindEvents(), Vc("stage:isReady");
									},
								},
								{
									key: "buildRenderer",
									value: function () {
										var t = this;
										this.renderer = new xf(this.$canvas, function () {
											return t.render();
										});
									},
								},
								{
									key: "buildCamera",
									value: function () {
										this.camera = new Bm();
									},
								},
								{ key: "buildLights", value: function () {} },
								{
									key: "initDebug",
									value: function () {
										this.DC = new bv(this);
									},
								},
								{
									key: "initScene",
									value: function () {
										(this.pointer = If.init(this.camera)), (this.scene = new km());
									},
								},
								{
									key: "initPostProcess",
									value: function () {
										this.post = new ov(this);
									},
								},
								{
									key: "bindEvents",
									value: function () {
										var t = this;
										document.addEventListener("layout:change", function () {
											return t.onResize();
										}),
											document.addEventListener("stage:render", function () {
												return t.onStageRender();
											});
									},
								},
								{
									key: "onResize",
									value: function () {
										this.renderStage();
									},
								},
								{
									key: "onStageRender",
									value: function () {
										this.renderStage();
									},
								},
								{
									key: "renderStage",
									value: function () {
										var t = this,
											e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 100;
										this.autoRender ||
											(this.renderer.toggleRender(!0),
											clearTimeout(this.renderTimer),
											(this.renderTimer = h()(function () {
												t.renderer.toggleRender(!1);
											}, e)));
									},
								},
								{
									key: "render",
									value: function () {
										this.DC.beginStats();
										this.renderer;
										var t = this.post;
										this.update(), t.render(), this.DC.endStats();
									},
								},
								{
									key: "update",
									value: function () {
										this.DC.update(), this.scene.update();
									},
								},
							]),
							t
						);
					})(),
					yv = (function () {
						function t() {
							s(this, t), this.onResize(), (this.resizeTimer = null), (this.isResizing = !1), (this.isPreventTouch = !1), this.bindEvents();
						}
						return (
							c(t, [
								{
									key: "bindEvents",
									value: function () {
										var t = this;
										window.addEventListener("resize", function () {
											return t.onDelayedResize();
										}),
											window.addEventListener(
												"wheel",
												function (e) {
													t.onScroll(e);
												},
												{ passive: !1 }
											),
											window.addEventListener("scroll", function (e) {
												t.onScroll(e);
											}),
											document.addEventListener(
												"touchmove",
												function (e) {
													return t.onTouchMove(e);
												},
												{ passive: !1 }
											),
											document.addEventListener("stage:isReady", function (e) {
												return t.onStageIsReady(e);
											});
									},
								},
								{
									key: "onStageIsReady",
									value: function () {
										var t = this;
										Stage.$canvas.addEventListener("pointermove", function (e) {
											return t.onMove(e);
										});
									},
								},
								{
									key: "onResize",
									value: function () {
										(this.isMobile = window.matchMedia("(max-width: 767px)").matches), (this.W = window.innerWidth), (this.H = window.innerHeight), (this.PR = Math.min(window.devicePixelRatio, 1.5)), (this.isResizing = !1), this.R ? this.R.value.set(this.W * this.PR, this.H * this.PR, this.PR) : (this.R = { value: _v.set(this.W * this.PR, this.H * this.PR, this.PR) }), Vc("layout:change");
									},
								},
								{
									key: "onDelayedResize",
									value: function () {
										var t = this;
										(this.isResizing = !0),
											this.resizeTimer && clearTimeout(this.resizeTimer),
											(this.resizeTimer = h()(function () {
												return t.onResize();
											}, 200));
									},
								},
								{
									key: "onTouchMove",
									value: function (t) {
										t.preventDefault();
									},
								},
								{
									key: "onScroll",
									value: function (t) {
										t.preventDefault();
									},
								},
								{
									key: "onMove",
									value: function (t) {
										var e,
											n,
											i,
											r,
											a,
											s = ((n = (e = t).changedTouches), (i = e.clientX), (r = e.clientY), (a = e.target), { x: n ? n[0].clientX : i, y: n ? n[0].clientY : r, target: a }),
											o = s.x,
											l = s.y,
											c = this.W,
											u = this.H;
										Vc("layout:pointerMove", { x: o, y: l, nx: (o / c) * 2 - 1, ny: (-l / u) * 2 + 1 });
									},
								},
							]),
							t
						);
					})(),
					_v = new Xt(),
					wv = n(1643),
					Mv = n.n(wv),
					Sv = function t() {
						s(this, t);
						var e = navigator.platform,
							n = navigator.userAgent;
						(this.isMobile = /iPhone|iPad|iPod|Android|webOS|BlackBerry|IEMobile|Opera Mini/i.test(n)),
							(this.isChrome = Mv()(n).call(n, "Chrome") > -1),
							(this.isSafari = Mv()(n).call(n, "Safari") > -1),
							(this.isEdge = /(?:\b(MS)?IE\s+|\bTrident\/7\.0;.*\s+rv:|\bEdge\/)(\d+)/.test(n)),
							this.isChrome && this.isSafari && (this.isSafari = !1),
							this.isChrome && this.isEdge && (this.isChrome = !1),
							(this.isSafariDesktop = !this.isMobile && this.isSafari),
							(this.isiPad = /iPad/i.test(n) || ("MacIntel" === e && navigator.maxTouchPoints > 1)),
							(this.isiPhone = /iPhone|iPod/i.test(n)),
							(this.isWebApp = navigator.standalone),
							(this.isDevice = this.isMobile || this.isiOS);
					};
				(window.Browser = new Sv()), (window.Layout = new yv()), (window.Stage = new xv());
			},
			4493: (t, e, n) => {
				n(7971), n(3242);
				var i = n(4058);
				t.exports = i.Array.from;
			},
			4034: (t, e, n) => {
				n(2988);
				var i = n(4058);
				t.exports = i.Array.isArray;
			},
			2383: (t, e, n) => {
				n(1501);
				var i = n(5703);
				t.exports = i("Array").filter;
			},
			9324: (t, e, n) => {
				n(2437);
				var i = n(5703);
				t.exports = i("Array").forEach;
			},
			8700: (t, e, n) => {
				n(9076);
				var i = n(5703);
				t.exports = i("Array").indexOf;
			},
			3866: (t, e, n) => {
				n(8787);
				var i = n(5703);
				t.exports = i("Array").map;
			},
			4900: (t, e, n) => {
				n(186);
				var i = n(5703);
				t.exports = i("Array").slice;
			},
			3830: (t, e, n) => {
				n(6274), n(7971);
				var i = n(2902);
				t.exports = i;
			},
			2480: (t, e, n) => {
				var i = n(2383),
					r = Array.prototype;
				t.exports = function (t) {
					var e = t.filter;
					return t === r || (t instanceof Array && e === r.filter) ? i : e;
				};
			},
			4570: (t, e, n) => {
				var i = n(8700),
					r = Array.prototype;
				t.exports = function (t) {
					var e = t.indexOf;
					return t === r || (t instanceof Array && e === r.indexOf) ? i : e;
				};
			},
			8287: (t, e, n) => {
				var i = n(3866),
					r = Array.prototype;
				t.exports = function (t) {
					var e = t.map;
					return t === r || (t instanceof Array && e === r.map) ? i : e;
				};
			},
			9601: (t, e, n) => {
				var i = n(4900),
					r = Array.prototype;
				t.exports = function (t) {
					var e = t.slice;
					return t === r || (t instanceof Array && e === r.slice) ? i : e;
				};
			},
			6536: (t, e, n) => {
				n(1507);
				var i = n(4058);
				t.exports = i.Math.cbrt;
			},
			5999: (t, e, n) => {
				n(9221);
				var i = n(4058);
				t.exports = i.Object.assign;
			},
			5254: (t, e, n) => {
				n(3882);
				var i = n(4058).Object;
				t.exports = function (t, e) {
					return i.create(t, e);
				};
			},
			7702: (t, e, n) => {
				n(4979);
				var i = n(4058).Object,
					r = (t.exports = function (t, e) {
						return i.defineProperties(t, e);
					});
				i.defineProperties.sham && (r.sham = !0);
			},
			8171: (t, e, n) => {
				n(6450);
				var i = n(4058).Object,
					r = (t.exports = function (t, e, n) {
						return i.defineProperty(t, e, n);
					});
				i.defineProperty.sham && (r.sham = !0);
			},
			286: (t, e, n) => {
				n(6924);
				var i = n(4058).Object,
					r = (t.exports = function (t, e) {
						return i.getOwnPropertyDescriptor(t, e);
					});
				i.getOwnPropertyDescriptor.sham && (r.sham = !0);
			},
			2766: (t, e, n) => {
				n(8482);
				var i = n(4058);
				t.exports = i.Object.getOwnPropertyDescriptors;
			},
			498: (t, e, n) => {
				n(5824);
				var i = n(4058);
				t.exports = i.Object.getOwnPropertySymbols;
			},
			3966: (t, e, n) => {
				n(7405);
				var i = n(4058);
				t.exports = i.Object.getPrototypeOf;
			},
			8494: (t, e, n) => {
				n(1724);
				var i = n(4058);
				t.exports = i.Object.keys;
			},
			3065: (t, e, n) => {
				n(108);
				var i = n(4058);
				t.exports = i.Object.setPrototypeOf;
			},
			2956: (t, e, n) => {
				n(7627), n(6274), n(5967), n(8881), n(4560), n(7206), n(4349), n(7971);
				var i = n(4058);
				t.exports = i.Promise;
			},
			4983: (t, e, n) => {
				n(7453);
				var i = n(4058);
				t.exports = i.Reflect.construct;
			},
			7473: (t, e, n) => {
				n(5906), n(5967), n(5824), n(8555), n(2615), n(1732), n(5903), n(1825), n(8394), n(5915), n(1766), n(2737), n(9911), n(4315), n(3131), n(4714), n(659), n(9120), n(5327), n(1502);
				var i = n(4058);
				t.exports = i.Symbol;
			},
			4227: (t, e, n) => {
				n(6274), n(5967), n(7971), n(1825);
				var i = n(1477);
				t.exports = i.f("iterator");
			},
			7385: (t, e, n) => {
				var i = n(7698);
				t.exports = i;
			},
			1522: (t, e, n) => {
				var i = n(3363);
				t.exports = i;
			},
			2209: (t, e, n) => {
				var i = n(6243);
				t.exports = i;
			},
			1493: (t, e, n) => {
				var i = n(2073);
				t.exports = i;
			},
			6094: (t, e, n) => {
				var i = n(4471);
				t.exports = i;
			},
			3685: (t, e, n) => {
				var i = n(1910);
				t.exports = i;
			},
			4303: (t, e, n) => {
				var i = n(6507);
				t.exports = i;
			},
			5122: (t, e, n) => {
				var i = n(6670);
				t.exports = i;
			},
			9531: (t, e, n) => {
				var i = n(7460);
				n(9731), n(5708), n(14), n(8731), (t.exports = i);
			},
			6600: (t, e, n) => {
				var i = n(2547);
				n(8783), n(3975), n(5799), n(5414), n(6774), n(620), n(6172), (t.exports = i);
			},
			9759: (t, e, n) => {
				var i = n(6509);
				t.exports = i;
			},
			3916: (t) => {
				t.exports = function (t) {
					if ("function" != typeof t) throw TypeError(String(t) + " is not a function");
					return t;
				};
			},
			1851: (t, e, n) => {
				var i = n(941);
				t.exports = function (t) {
					if (!i(t) && null !== t) throw TypeError("Can't set " + String(t) + " as a prototype");
					return t;
				};
			},
			8479: (t) => {
				t.exports = function () {};
			},
			5743: (t) => {
				t.exports = function (t, e, n) {
					if (!(t instanceof e)) throw TypeError("Incorrect " + (n ? n + " " : "") + "invocation");
					return t;
				};
			},
			6059: (t, e, n) => {
				var i = n(941);
				t.exports = function (t) {
					if (!i(t)) throw TypeError(String(t) + " is not an object");
					return t;
				};
			},
			6837: (t, e, n) => {
				"use strict";
				var i = n(3610).forEach,
					r = n(4194)("forEach");
				t.exports = r
					? [].forEach
					: function (t) {
							return i(this, t, arguments.length > 1 ? arguments[1] : void 0);
					  };
			},
			1354: (t, e, n) => {
				"use strict";
				var i = n(6843),
					r = n(9678),
					a = n(5196),
					s = n(6782),
					o = n(3057),
					l = n(5449),
					c = n(3476),
					u = n(2902);
				t.exports = function (t) {
					var e,
						n,
						h,
						d,
						p,
						f,
						m = r(t),
						v = "function" == typeof this ? this : Array,
						g = arguments.length,
						b = g > 1 ? arguments[1] : void 0,
						x = void 0 !== b,
						y = u(m),
						_ = 0;
					if ((x && (b = i(b, g > 2 ? arguments[2] : void 0, 2)), null == y || (v == Array && s(y)))) for (n = new v((e = o(m.length))); e > _; _++) (f = x ? b(m[_], _) : m[_]), l(n, _, f);
					else for (p = (d = c(m, y)).next, n = new v(); !(h = p.call(d)).done; _++) (f = x ? a(d, b, [h.value, _], !0) : h.value), l(n, _, f);
					return (n.length = _), n;
				};
			},
			1692: (t, e, n) => {
				var i = n(4529),
					r = n(3057),
					a = n(9413),
					s = function (t) {
						return function (e, n, s) {
							var o,
								l = i(e),
								c = r(l.length),
								u = a(s, c);
							if (t && n != n) {
								for (; c > u; ) if ((o = l[u++]) != o) return !0;
							} else for (; c > u; u++) if ((t || u in l) && l[u] === n) return t || u || 0;
							return !t && -1;
						};
					};
				t.exports = { includes: s(!0), indexOf: s(!1) };
			},
			3610: (t, e, n) => {
				var i = n(6843),
					r = n(7026),
					a = n(9678),
					s = n(3057),
					o = n(4692),
					l = [].push,
					c = function (t) {
						var e = 1 == t,
							n = 2 == t,
							c = 3 == t,
							u = 4 == t,
							h = 6 == t,
							d = 7 == t,
							p = 5 == t || h;
						return function (f, m, v, g) {
							for (var b, x, y = a(f), _ = r(y), w = i(m, v, 3), M = s(_.length), S = 0, T = g || o, E = e ? T(f, M) : n || d ? T(f, 0) : void 0; M > S; S++)
								if ((p || S in _) && ((x = w((b = _[S]), S, y)), t))
									if (e) E[S] = x;
									else if (x)
										switch (t) {
											case 3:
												return !0;
											case 5:
												return b;
											case 6:
												return S;
											case 2:
												l.call(E, b);
										}
									else
										switch (t) {
											case 4:
												return !1;
											case 7:
												l.call(E, b);
										}
							return h ? -1 : c || u ? u : E;
						};
					};
				t.exports = { forEach: c(0), map: c(1), filter: c(2), some: c(3), every: c(4), find: c(5), findIndex: c(6), filterReject: c(7) };
			},
			568: (t, e, n) => {
				var i = n(5981),
					r = n(9813),
					a = n(3385),
					s = r("species");
				t.exports = function (t) {
					return (
						a >= 51 ||
						!i(function () {
							var e = [];
							return (
								((e.constructor = {})[s] = function () {
									return { foo: 1 };
								}),
								1 !== e[t](Boolean).foo
							);
						})
					);
				};
			},
			4194: (t, e, n) => {
				"use strict";
				var i = n(5981);
				t.exports = function (t, e) {
					var n = [][t];
					return (
						!!n &&
						i(function () {
							n.call(
								null,
								e ||
									function () {
										throw 1;
									},
								1
							);
						})
					);
				};
			},
			5693: (t, e, n) => {
				var i = n(941),
					r = n(1052),
					a = n(9813)("species");
				t.exports = function (t) {
					var e;
					return r(t) && ("function" != typeof (e = t.constructor) || (e !== Array && !r(e.prototype)) ? i(e) && null === (e = e[a]) && (e = void 0) : (e = void 0)), void 0 === e ? Array : e;
				};
			},
			4692: (t, e, n) => {
				var i = n(5693);
				t.exports = function (t, e) {
					return new (i(t))(0 === e ? 0 : e);
				};
			},
			5196: (t, e, n) => {
				var i = n(6059),
					r = n(7609);
				t.exports = function (t, e, n, a) {
					try {
						return a ? e(i(n)[0], n[1]) : e(n);
					} catch (e) {
						r(t, "throw", e);
					}
				};
			},
			1385: (t, e, n) => {
				var i = n(9813)("iterator"),
					r = !1;
				try {
					var a = 0,
						s = {
							next: function () {
								return { done: !!a++ };
							},
							return: function () {
								r = !0;
							},
						};
					(s[i] = function () {
						return this;
					}),
						Array.from(s, function () {
							throw 2;
						});
				} catch (t) {}
				t.exports = function (t, e) {
					if (!e && !r) return !1;
					var n = !1;
					try {
						var a = {};
						(a[i] = function () {
							return {
								next: function () {
									return { done: (n = !0) };
								},
							};
						}),
							t(a);
					} catch (t) {}
					return n;
				};
			},
			2532: (t) => {
				var e = {}.toString;
				t.exports = function (t) {
					return e.call(t).slice(8, -1);
				};
			},
			9697: (t, e, n) => {
				var i = n(2885),
					r = n(2532),
					a = n(9813)("toStringTag"),
					s =
						"Arguments" ==
						r(
							(function () {
								return arguments;
							})()
						);
				t.exports = i
					? r
					: function (t) {
							var e, n, i;
							return void 0 === t
								? "Undefined"
								: null === t
								? "Null"
								: "string" ==
								  typeof (n = (function (t, e) {
										try {
											return t[e];
										} catch (t) {}
								  })((e = Object(t)), a))
								? n
								: s
								? r(e)
								: "Object" == (i = r(e)) && "function" == typeof e.callee
								? "Arguments"
								: i;
					  };
			},
			4160: (t, e, n) => {
				var i = n(5981);
				t.exports = !i(function () {
					function t() {}
					return (t.prototype.constructor = null), Object.getPrototypeOf(new t()) !== t.prototype;
				});
			},
			1046: (t, e, n) => {
				"use strict";
				var i = n(5143).IteratorPrototype,
					r = n(9290),
					a = n(1887),
					s = n(904),
					o = n(2077),
					l = function () {
						return this;
					};
				t.exports = function (t, e, n) {
					var c = e + " Iterator";
					return (t.prototype = r(i, { next: a(1, n) })), s(t, c, !1, !0), (o[c] = l), t;
				};
			},
			2029: (t, e, n) => {
				var i = n(5746),
					r = n(5988),
					a = n(1887);
				t.exports = i
					? function (t, e, n) {
							return r.f(t, e, a(1, n));
					  }
					: function (t, e, n) {
							return (t[e] = n), t;
					  };
			},
			1887: (t) => {
				t.exports = function (t, e) {
					return { enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: e };
				};
			},
			5449: (t, e, n) => {
				"use strict";
				var i = n(3894),
					r = n(5988),
					a = n(1887);
				t.exports = function (t, e, n) {
					var s = i(e);
					s in t ? r.f(t, s, a(0, n)) : (t[s] = n);
				};
			},
			7771: (t, e, n) => {
				"use strict";
				var i = n(6887),
					r = n(1046),
					a = n(249),
					s = n(8929),
					o = n(904),
					l = n(2029),
					c = n(9754),
					u = n(9813),
					h = n(2529),
					d = n(2077),
					p = n(5143),
					f = p.IteratorPrototype,
					m = p.BUGGY_SAFARI_ITERATORS,
					v = u("iterator"),
					g = "keys",
					b = "values",
					x = "entries",
					y = function () {
						return this;
					};
				t.exports = function (t, e, n, u, p, _, w) {
					r(n, e, u);
					var M,
						S,
						T,
						E = function (t) {
							if (t === p && R) return R;
							if (!m && t in A) return A[t];
							switch (t) {
								case g:
								case b:
								case x:
									return function () {
										return new n(this, t);
									};
							}
							return function () {
								return new n(this);
							};
						},
						C = e + " Iterator",
						P = !1,
						A = t.prototype,
						L = A[v] || A["@@iterator"] || (p && A[p]),
						R = (!m && L) || E(p),
						D = ("Array" == e && A.entries) || L;
					if (
						(D && ((M = a(D.call(new t()))), f !== Object.prototype && M.next && (h || a(M) === f || (s ? s(M, f) : "function" != typeof M[v] && l(M, v, y)), o(M, C, !0, !0), h && (d[C] = y))),
						p == b &&
							L &&
							L.name !== b &&
							((P = !0),
							(R = function () {
								return L.call(this);
							})),
						(h && !w) || A[v] === R || l(A, v, R),
						(d[e] = R),
						p)
					)
						if (((S = { values: E(b), keys: _ ? R : E(g), entries: E(x) }), w)) for (T in S) (m || P || !(T in A)) && c(A, T, S[T]);
						else i({ target: e, proto: !0, forced: m || P }, S);
					return S;
				};
			},
			6349: (t, e, n) => {
				var i = n(4058),
					r = n(7457),
					a = n(1477),
					s = n(5988).f;
				t.exports = function (t) {
					var e = i.Symbol || (i.Symbol = {});
					r(e, t) || s(e, t, { value: a.f(t) });
				};
			},
			5746: (t, e, n) => {
				var i = n(5981);
				t.exports = !i(function () {
					return (
						7 !=
						Object.defineProperty({}, 1, {
							get: function () {
								return 7;
							},
						})[1]
					);
				});
			},
			1333: (t, e, n) => {
				var i = n(1899),
					r = n(941),
					a = i.document,
					s = r(a) && r(a.createElement);
				t.exports = function (t) {
					return s ? a.createElement(t) : {};
				};
			},
			3281: (t) => {
				t.exports = {
					CSSRuleList: 0,
					CSSStyleDeclaration: 0,
					CSSValueList: 0,
					ClientRectList: 0,
					DOMRectList: 0,
					DOMStringList: 0,
					DOMTokenList: 1,
					DataTransferItemList: 0,
					FileList: 0,
					HTMLAllCollection: 0,
					HTMLCollection: 0,
					HTMLFormElement: 0,
					HTMLSelectElement: 0,
					MediaList: 0,
					MimeTypeArray: 0,
					NamedNodeMap: 0,
					NodeList: 1,
					PaintRequestList: 0,
					Plugin: 0,
					PluginArray: 0,
					SVGLengthList: 0,
					SVGNumberList: 0,
					SVGPathSegList: 0,
					SVGPointList: 0,
					SVGStringList: 0,
					SVGTransformList: 0,
					SourceBufferList: 0,
					StyleSheetList: 0,
					TextTrackCueList: 0,
					TextTrackList: 0,
					TouchList: 0,
				};
			},
			3321: (t) => {
				t.exports = "object" == typeof window;
			},
			4470: (t, e, n) => {
				var i = n(2861),
					r = n(1899);
				t.exports = /ipad|iphone|ipod/i.test(i) && void 0 !== r.Pebble;
			},
			2749: (t, e, n) => {
				var i = n(2861);
				t.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(i);
			},
			6049: (t, e, n) => {
				var i = n(2532),
					r = n(1899);
				t.exports = "process" == i(r.process);
			},
			8045: (t, e, n) => {
				var i = n(2861);
				t.exports = /web0s(?!.*chrome)/i.test(i);
			},
			2861: (t, e, n) => {
				var i = n(626);
				t.exports = i("navigator", "userAgent") || "";
			},
			3385: (t, e, n) => {
				var i,
					r,
					a = n(1899),
					s = n(2861),
					o = a.process,
					l = a.Deno,
					c = (o && o.versions) || (l && l.version),
					u = c && c.v8;
				u ? (r = (i = u.split("."))[0] < 4 ? 1 : i[0] + i[1]) : s && (!(i = s.match(/Edge\/(\d+)/)) || i[1] >= 74) && (i = s.match(/Chrome\/(\d+)/)) && (r = i[1]), (t.exports = r && +r);
			},
			5703: (t, e, n) => {
				var i = n(4058);
				t.exports = function (t) {
					return i[t + "Prototype"];
				};
			},
			6759: (t) => {
				t.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
			},
			6887: (t, e, n) => {
				"use strict";
				var i = n(1899),
					r = n(9677).f,
					a = n(7252),
					s = n(4058),
					o = n(6843),
					l = n(2029),
					c = n(7457),
					u = function (t) {
						var e = function (e, n, i) {
							if (this instanceof t) {
								switch (arguments.length) {
									case 0:
										return new t();
									case 1:
										return new t(e);
									case 2:
										return new t(e, n);
								}
								return new t(e, n, i);
							}
							return t.apply(this, arguments);
						};
						return (e.prototype = t.prototype), e;
					};
				t.exports = function (t, e) {
					var n,
						h,
						d,
						p,
						f,
						m,
						v,
						g,
						b = t.target,
						x = t.global,
						y = t.stat,
						_ = t.proto,
						w = x ? i : y ? i[b] : (i[b] || {}).prototype,
						M = x ? s : s[b] || l(s, b, {})[b],
						S = M.prototype;
					for (d in e)
						(n = !a(x ? d : b + (y ? "." : "#") + d, t.forced) && w && c(w, d)),
							(f = M[d]),
							n && (m = t.noTargetGet ? (g = r(w, d)) && g.value : w[d]),
							(p = n && m ? m : e[d]),
							(n && typeof f == typeof p) || ((v = t.bind && n ? o(p, i) : t.wrap && n ? u(p) : _ && "function" == typeof p ? o(Function.call, p) : p), (t.sham || (p && p.sham) || (f && f.sham)) && l(v, "sham", !0), l(M, d, v), _ && (c(s, (h = b + "Prototype")) || l(s, h, {}), l(s[h], d, p), t.real && S && !S[d] && l(S, d, p)));
				};
			},
			5981: (t) => {
				t.exports = function (t) {
					try {
						return !!t();
					} catch (t) {
						return !0;
					}
				};
			},
			6843: (t, e, n) => {
				var i = n(3916);
				t.exports = function (t, e, n) {
					if ((i(t), void 0 === e)) return t;
					switch (n) {
						case 0:
							return function () {
								return t.call(e);
							};
						case 1:
							return function (n) {
								return t.call(e, n);
							};
						case 2:
							return function (n, i) {
								return t.call(e, n, i);
							};
						case 3:
							return function (n, i, r) {
								return t.call(e, n, i, r);
							};
					}
					return function () {
						return t.apply(e, arguments);
					};
				};
			},
			8308: (t, e, n) => {
				"use strict";
				var i = n(3916),
					r = n(941),
					a = [].slice,
					s = {},
					o = function (t, e, n) {
						if (!(e in s)) {
							for (var i = [], r = 0; r < e; r++) i[r] = "a[" + r + "]";
							s[e] = Function("C,a", "return new C(" + i.join(",") + ")");
						}
						return s[e](t, n);
					};
				t.exports =
					Function.bind ||
					function (t) {
						var e = i(this),
							n = a.call(arguments, 1),
							s = function () {
								var i = n.concat(a.call(arguments));
								return this instanceof s ? o(e, i.length, i) : e.apply(t, i);
							};
						return r(e.prototype) && (s.prototype = e.prototype), s;
					};
			},
			626: (t, e, n) => {
				var i = n(4058),
					r = n(1899),
					a = function (t) {
						return "function" == typeof t ? t : void 0;
					};
				t.exports = function (t, e) {
					return arguments.length < 2 ? a(i[t]) || a(r[t]) : (i[t] && i[t][e]) || (r[t] && r[t][e]);
				};
			},
			2902: (t, e, n) => {
				var i = n(9697),
					r = n(2077),
					a = n(9813)("iterator");
				t.exports = function (t) {
					if (null != t) return t[a] || t["@@iterator"] || r[i(t)];
				};
			},
			3476: (t, e, n) => {
				var i = n(6059),
					r = n(2902);
				t.exports = function (t, e) {
					var n = arguments.length < 2 ? r(t) : e;
					if ("function" != typeof n) throw TypeError(String(t) + " is not iterable");
					return i(n.call(t));
				};
			},
			1899: (t, e, n) => {
				var i = function (t) {
					return t && t.Math == Math && t;
				};
				t.exports =
					i("object" == typeof globalThis && globalThis) ||
					i("object" == typeof window && window) ||
					i("object" == typeof self && self) ||
					i("object" == typeof n.g && n.g) ||
					(function () {
						return this;
					})() ||
					Function("return this")();
			},
			7457: (t, e, n) => {
				var i = n(9678),
					r = {}.hasOwnProperty;
				t.exports =
					Object.hasOwn ||
					function (t, e) {
						return r.call(i(t), e);
					};
			},
			7748: (t) => {
				t.exports = {};
			},
			4845: (t, e, n) => {
				var i = n(1899);
				t.exports = function (t, e) {
					var n = i.console;
					n && n.error && (1 === arguments.length ? n.error(t) : n.error(t, e));
				};
			},
			5463: (t, e, n) => {
				var i = n(626);
				t.exports = i("document", "documentElement");
			},
			2840: (t, e, n) => {
				var i = n(5746),
					r = n(5981),
					a = n(1333);
				t.exports =
					!i &&
					!r(function () {
						return (
							7 !=
							Object.defineProperty(a("div"), "a", {
								get: function () {
									return 7;
								},
							}).a
						);
					});
			},
			7026: (t, e, n) => {
				var i = n(5981),
					r = n(2532),
					a = "".split;
				t.exports = i(function () {
					return !Object("z").propertyIsEnumerable(0);
				})
					? function (t) {
							return "String" == r(t) ? a.call(t, "") : Object(t);
					  }
					: Object;
			},
			1302: (t, e, n) => {
				var i = n(3030),
					r = Function.toString;
				"function" != typeof i.inspectSource &&
					(i.inspectSource = function (t) {
						return r.call(t);
					}),
					(t.exports = i.inspectSource);
			},
			5402: (t, e, n) => {
				var i,
					r,
					a,
					s = n(8019),
					o = n(1899),
					l = n(941),
					c = n(2029),
					u = n(7457),
					h = n(3030),
					d = n(4262),
					p = n(7748),
					f = "Object already initialized",
					m = o.WeakMap;
				if (s || h.state) {
					var v = h.state || (h.state = new m()),
						g = v.get,
						b = v.has,
						x = v.set;
					(i = function (t, e) {
						if (b.call(v, t)) throw new TypeError(f);
						return (e.facade = t), x.call(v, t, e), e;
					}),
						(r = function (t) {
							return g.call(v, t) || {};
						}),
						(a = function (t) {
							return b.call(v, t);
						});
				} else {
					var y = d("state");
					(p[y] = !0),
						(i = function (t, e) {
							if (u(t, y)) throw new TypeError(f);
							return (e.facade = t), c(t, y, e), e;
						}),
						(r = function (t) {
							return u(t, y) ? t[y] : {};
						}),
						(a = function (t) {
							return u(t, y);
						});
				}
				t.exports = {
					set: i,
					get: r,
					has: a,
					enforce: function (t) {
						return a(t) ? r(t) : i(t, {});
					},
					getterFor: function (t) {
						return function (e) {
							var n;
							if (!l(e) || (n = r(e)).type !== t) throw TypeError("Incompatible receiver, " + t + " required");
							return n;
						};
					},
				};
			},
			6782: (t, e, n) => {
				var i = n(9813),
					r = n(2077),
					a = i("iterator"),
					s = Array.prototype;
				t.exports = function (t) {
					return void 0 !== t && (r.Array === t || s[a] === t);
				};
			},
			1052: (t, e, n) => {
				var i = n(2532);
				t.exports =
					Array.isArray ||
					function (t) {
						return "Array" == i(t);
					};
			},
			7252: (t, e, n) => {
				var i = n(5981),
					r = /#|\.prototype\./,
					a = function (t, e) {
						var n = o[s(t)];
						return n == c || (n != l && ("function" == typeof e ? i(e) : !!e));
					},
					s = (a.normalize = function (t) {
						return String(t).replace(r, ".").toLowerCase();
					}),
					o = (a.data = {}),
					l = (a.NATIVE = "N"),
					c = (a.POLYFILL = "P");
				t.exports = a;
			},
			941: (t) => {
				t.exports = function (t) {
					return "object" == typeof t ? null !== t : "function" == typeof t;
				};
			},
			2529: (t) => {
				t.exports = !0;
			},
			6664: (t, e, n) => {
				var i = n(626),
					r = n(2302);
				t.exports = r
					? function (t) {
							return "symbol" == typeof t;
					  }
					: function (t) {
							var e = i("Symbol");
							return "function" == typeof e && Object(t) instanceof e;
					  };
			},
			3091: (t, e, n) => {
				var i = n(6059),
					r = n(6782),
					a = n(3057),
					s = n(6843),
					o = n(3476),
					l = n(2902),
					c = n(7609),
					u = function (t, e) {
						(this.stopped = t), (this.result = e);
					};
				t.exports = function (t, e, n) {
					var h,
						d,
						p,
						f,
						m,
						v,
						g,
						b = n && n.that,
						x = !(!n || !n.AS_ENTRIES),
						y = !(!n || !n.IS_ITERATOR),
						_ = !(!n || !n.INTERRUPTED),
						w = s(e, b, 1 + x + _),
						M = function (t) {
							return h && c(h, "normal", t), new u(!0, t);
						},
						S = function (t) {
							return x ? (i(t), _ ? w(t[0], t[1], M) : w(t[0], t[1])) : _ ? w(t, M) : w(t);
						};
					if (y) h = t;
					else {
						if ("function" != typeof (d = l(t))) throw TypeError("Target is not iterable");
						if (r(d)) {
							for (p = 0, f = a(t.length); f > p; p++) if ((m = S(t[p])) && m instanceof u) return m;
							return new u(!1);
						}
						h = o(t, d);
					}
					for (v = h.next; !(g = v.call(h)).done; ) {
						try {
							m = S(g.value);
						} catch (t) {
							c(h, "throw", t);
						}
						if ("object" == typeof m && m && m instanceof u) return m;
					}
					return new u(!1);
				};
			},
			7609: (t, e, n) => {
				var i = n(6059);
				t.exports = function (t, e, n) {
					var r, a;
					i(t);
					try {
						if (void 0 === (r = t.return)) {
							if ("throw" === e) throw n;
							return n;
						}
						r = r.call(t);
					} catch (t) {
						(a = !0), (r = t);
					}
					if ("throw" === e) throw n;
					if (a) throw r;
					return i(r), n;
				};
			},
			5143: (t, e, n) => {
				"use strict";
				var i,
					r,
					a,
					s = n(5981),
					o = n(249),
					l = n(2029),
					c = n(7457),
					u = n(9813),
					h = n(2529),
					d = u("iterator"),
					p = !1;
				[].keys && ("next" in (a = [].keys()) ? (r = o(o(a))) !== Object.prototype && (i = r) : (p = !0));
				var f =
					null == i ||
					s(function () {
						var t = {};
						return i[d].call(t) !== t;
					});
				f && (i = {}),
					(h && !f) ||
						c(i, d) ||
						l(i, d, function () {
							return this;
						}),
					(t.exports = { IteratorPrototype: i, BUGGY_SAFARI_ITERATORS: p });
			},
			2077: (t) => {
				t.exports = {};
			},
			6383: (t) => {
				t.exports =
					Math.sign ||
					function (t) {
						return 0 == (t = +t) || t != t ? t : t < 0 ? -1 : 1;
					};
			},
			6132: (t, e, n) => {
				var i,
					r,
					a,
					s,
					o,
					l,
					c,
					u,
					h = n(1899),
					d = n(9677).f,
					p = n(2941).set,
					f = n(2749),
					m = n(4470),
					v = n(8045),
					g = n(6049),
					b = h.MutationObserver || h.WebKitMutationObserver,
					x = h.document,
					y = h.process,
					_ = h.Promise,
					w = d(h, "queueMicrotask"),
					M = w && w.value;
				M ||
					((i = function () {
						var t, e;
						for (g && (t = y.domain) && t.exit(); r; ) {
							(e = r.fn), (r = r.next);
							try {
								e();
							} catch (t) {
								throw (r ? s() : (a = void 0), t);
							}
						}
						(a = void 0), t && t.enter();
					}),
					f || g || v || !b || !x
						? !m && _ && _.resolve
							? (((c = _.resolve(void 0)).constructor = _),
							  (u = c.then),
							  (s = function () {
									u.call(c, i);
							  }))
							: (s = g
									? function () {
											y.nextTick(i);
									  }
									: function () {
											p.call(h, i);
									  })
						: ((o = !0),
						  (l = x.createTextNode("")),
						  new b(i).observe(l, { characterData: !0 }),
						  (s = function () {
								l.data = o = !o;
						  }))),
					(t.exports =
						M ||
						function (t) {
							var e = { fn: t, next: void 0 };
							a && (a.next = e), r || ((r = e), s()), (a = e);
						});
			},
			9297: (t, e, n) => {
				var i = n(1899);
				t.exports = i.Promise;
			},
			2497: (t, e, n) => {
				var i = n(3385),
					r = n(5981);
				t.exports =
					!!Object.getOwnPropertySymbols &&
					!r(function () {
						var t = Symbol();
						return !String(t) || !(Object(t) instanceof Symbol) || (!Symbol.sham && i && i < 41);
					});
			},
			8019: (t, e, n) => {
				var i = n(1899),
					r = n(1302),
					a = i.WeakMap;
				t.exports = "function" == typeof a && /native code/.test(r(a));
			},
			9520: (t, e, n) => {
				"use strict";
				var i = n(3916),
					r = function (t) {
						var e, n;
						(this.promise = new t(function (t, i) {
							if (void 0 !== e || void 0 !== n) throw TypeError("Bad Promise constructor");
							(e = t), (n = i);
						})),
							(this.resolve = i(e)),
							(this.reject = i(n));
					};
				t.exports.f = function (t) {
					return new r(t);
				};
			},
			4420: (t, e, n) => {
				"use strict";
				var i = n(5746),
					r = n(5981),
					a = n(4771),
					s = n(7857),
					o = n(6760),
					l = n(9678),
					c = n(7026),
					u = Object.assign,
					h = Object.defineProperty;
				t.exports =
					!u ||
					r(function () {
						if (
							i &&
							1 !==
								u(
									{ b: 1 },
									u(
										h({}, "a", {
											enumerable: !0,
											get: function () {
												h(this, "b", { value: 3, enumerable: !1 });
											},
										}),
										{ b: 2 }
									)
								).b
						)
							return !0;
						var t = {},
							e = {},
							n = Symbol(),
							r = "abcdefghijklmnopqrst";
						return (
							(t[n] = 7),
							r.split("").forEach(function (t) {
								e[t] = t;
							}),
							7 != u({}, t)[n] || a(u({}, e)).join("") != r
						);
					})
						? function (t, e) {
								for (var n = l(t), r = arguments.length, u = 1, h = s.f, d = o.f; r > u; ) for (var p, f = c(arguments[u++]), m = h ? a(f).concat(h(f)) : a(f), v = m.length, g = 0; v > g; ) (p = m[g++]), (i && !d.call(f, p)) || (n[p] = f[p]);
								return n;
						  }
						: u;
			},
			9290: (t, e, n) => {
				var i,
					r = n(6059),
					a = n(9938),
					s = n(6759),
					o = n(7748),
					l = n(5463),
					c = n(1333),
					u = n(4262),
					h = u("IE_PROTO"),
					d = function () {},
					p = function (t) {
						return "<script>" + t + "</" + "script>";
					},
					f = function (t) {
						t.write(p("")), t.close();
						var e = t.parentWindow.Object;
						return (t = null), e;
					},
					m = function () {
						try {
							i = new ActiveXObject("htmlfile");
						} catch (t) {}
						var t, e;
						m = "undefined" != typeof document ? (document.domain && i ? f(i) : (((e = c("iframe")).style.display = "none"), l.appendChild(e), (e.src = String("javascript:")), (t = e.contentWindow.document).open(), t.write(p("document.F=Object")), t.close(), t.F)) : f(i);
						for (var n = s.length; n--; ) delete m.prototype[s[n]];
						return m();
					};
				(o[h] = !0),
					(t.exports =
						Object.create ||
						function (t, e) {
							var n;
							return null !== t ? ((d.prototype = r(t)), (n = new d()), (d.prototype = null), (n[h] = t)) : (n = m()), void 0 === e ? n : a(n, e);
						});
			},
			9938: (t, e, n) => {
				var i = n(5746),
					r = n(5988),
					a = n(6059),
					s = n(4771);
				t.exports = i
					? Object.defineProperties
					: function (t, e) {
							a(t);
							for (var n, i = s(e), o = i.length, l = 0; o > l; ) r.f(t, (n = i[l++]), e[n]);
							return t;
					  };
			},
			5988: (t, e, n) => {
				var i = n(5746),
					r = n(2840),
					a = n(6059),
					s = n(3894),
					o = Object.defineProperty;
				e.f = i
					? o
					: function (t, e, n) {
							if ((a(t), (e = s(e)), a(n), r))
								try {
									return o(t, e, n);
								} catch (t) {}
							if ("get" in n || "set" in n) throw TypeError("Accessors not supported");
							return "value" in n && (t[e] = n.value), t;
					  };
			},
			9677: (t, e, n) => {
				var i = n(5746),
					r = n(6760),
					a = n(1887),
					s = n(4529),
					o = n(3894),
					l = n(7457),
					c = n(2840),
					u = Object.getOwnPropertyDescriptor;
				e.f = i
					? u
					: function (t, e) {
							if (((t = s(t)), (e = o(e)), c))
								try {
									return u(t, e);
								} catch (t) {}
							if (l(t, e)) return a(!r.f.call(t, e), t[e]);
					  };
			},
			684: (t, e, n) => {
				var i = n(4529),
					r = n(946).f,
					a = {}.toString,
					s = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
				t.exports.f = function (t) {
					return s && "[object Window]" == a.call(t)
						? (function (t) {
								try {
									return r(t);
								} catch (t) {
									return s.slice();
								}
						  })(t)
						: r(i(t));
				};
			},
			946: (t, e, n) => {
				var i = n(5629),
					r = n(6759).concat("length", "prototype");
				e.f =
					Object.getOwnPropertyNames ||
					function (t) {
						return i(t, r);
					};
			},
			7857: (t, e) => {
				e.f = Object.getOwnPropertySymbols;
			},
			249: (t, e, n) => {
				var i = n(7457),
					r = n(9678),
					a = n(4262),
					s = n(4160),
					o = a("IE_PROTO"),
					l = Object.prototype;
				t.exports = s
					? Object.getPrototypeOf
					: function (t) {
							return (t = r(t)), i(t, o) ? t[o] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? l : null;
					  };
			},
			5629: (t, e, n) => {
				var i = n(7457),
					r = n(4529),
					a = n(1692).indexOf,
					s = n(7748);
				t.exports = function (t, e) {
					var n,
						o = r(t),
						l = 0,
						c = [];
					for (n in o) !i(s, n) && i(o, n) && c.push(n);
					for (; e.length > l; ) i(o, (n = e[l++])) && (~a(c, n) || c.push(n));
					return c;
				};
			},
			4771: (t, e, n) => {
				var i = n(5629),
					r = n(6759);
				t.exports =
					Object.keys ||
					function (t) {
						return i(t, r);
					};
			},
			6760: (t, e) => {
				"use strict";
				var n = {}.propertyIsEnumerable,
					i = Object.getOwnPropertyDescriptor,
					r = i && !n.call({ 1: 2 }, 1);
				e.f = r
					? function (t) {
							var e = i(this, t);
							return !!e && e.enumerable;
					  }
					: n;
			},
			8929: (t, e, n) => {
				var i = n(6059),
					r = n(1851);
				t.exports =
					Object.setPrototypeOf ||
					("__proto__" in {}
						? (function () {
								var t,
									e = !1,
									n = {};
								try {
									(t = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(n, []), (e = n instanceof Array);
								} catch (t) {}
								return function (n, a) {
									return i(n), r(a), e ? t.call(n, a) : (n.__proto__ = a), n;
								};
						  })()
						: void 0);
			},
			5623: (t, e, n) => {
				"use strict";
				var i = n(2885),
					r = n(9697);
				t.exports = i
					? {}.toString
					: function () {
							return "[object " + r(this) + "]";
					  };
			},
			9811: (t, e, n) => {
				var i = n(941);
				t.exports = function (t, e) {
					var n, r;
					if ("string" === e && "function" == typeof (n = t.toString) && !i((r = n.call(t)))) return r;
					if ("function" == typeof (n = t.valueOf) && !i((r = n.call(t)))) return r;
					if ("string" !== e && "function" == typeof (n = t.toString) && !i((r = n.call(t)))) return r;
					throw TypeError("Can't convert object to primitive value");
				};
			},
			1136: (t, e, n) => {
				var i = n(626),
					r = n(946),
					a = n(7857),
					s = n(6059);
				t.exports =
					i("Reflect", "ownKeys") ||
					function (t) {
						var e = r.f(s(t)),
							n = a.f;
						return n ? e.concat(n(t)) : e;
					};
			},
			4058: (t) => {
				t.exports = {};
			},
			2: (t) => {
				t.exports = function (t) {
					try {
						return { error: !1, value: t() };
					} catch (t) {
						return { error: !0, value: t };
					}
				};
			},
			6584: (t, e, n) => {
				var i = n(6059),
					r = n(941),
					a = n(9520);
				t.exports = function (t, e) {
					if ((i(t), r(e) && e.constructor === t)) return e;
					var n = a.f(t);
					return (0, n.resolve)(e), n.promise;
				};
			},
			7524: (t, e, n) => {
				var i = n(9754);
				t.exports = function (t, e, n) {
					for (var r in e) n && n.unsafe && t[r] ? (t[r] = e[r]) : i(t, r, e[r], n);
					return t;
				};
			},
			9754: (t, e, n) => {
				var i = n(2029);
				t.exports = function (t, e, n, r) {
					r && r.enumerable ? (t[e] = n) : i(t, e, n);
				};
			},
			8219: (t) => {
				t.exports = function (t) {
					if (null == t) throw TypeError("Can't call method on " + t);
					return t;
				};
			},
			4911: (t, e, n) => {
				var i = n(1899);
				t.exports = function (t, e) {
					try {
						Object.defineProperty(i, t, { value: e, configurable: !0, writable: !0 });
					} catch (n) {
						i[t] = e;
					}
					return e;
				};
			},
			4431: (t, e, n) => {
				"use strict";
				var i = n(626),
					r = n(5988),
					a = n(9813),
					s = n(5746),
					o = a("species");
				t.exports = function (t) {
					var e = i(t),
						n = r.f;
					s &&
						e &&
						!e[o] &&
						n(e, o, {
							configurable: !0,
							get: function () {
								return this;
							},
						});
				};
			},
			904: (t, e, n) => {
				var i = n(2885),
					r = n(5988).f,
					a = n(2029),
					s = n(7457),
					o = n(5623),
					l = n(9813)("toStringTag");
				t.exports = function (t, e, n, c) {
					if (t) {
						var u = n ? t : t.prototype;
						s(u, l) || r(u, l, { configurable: !0, value: e }), c && !i && a(u, "toString", o);
					}
				};
			},
			4262: (t, e, n) => {
				var i = n(8726),
					r = n(9418),
					a = i("keys");
				t.exports = function (t) {
					return a[t] || (a[t] = r(t));
				};
			},
			3030: (t, e, n) => {
				var i = n(1899),
					r = n(4911),
					a = "__core-js_shared__",
					s = i[a] || r(a, {});
				t.exports = s;
			},
			8726: (t, e, n) => {
				var i = n(2529),
					r = n(3030);
				(t.exports = function (t, e) {
					return r[t] || (r[t] = void 0 !== e ? e : {});
				})("versions", []).push({ version: "3.17.2", mode: i ? "pure" : "global", copyright: "© 2021 Denis Pushkarev (zloirock.ru)" });
			},
			487: (t, e, n) => {
				var i = n(6059),
					r = n(3916),
					a = n(9813)("species");
				t.exports = function (t, e) {
					var n,
						s = i(t).constructor;
					return void 0 === s || null == (n = i(s)[a]) ? e : r(n);
				};
			},
			4620: (t, e, n) => {
				var i = n(8459),
					r = n(5803),
					a = n(8219),
					s = function (t) {
						return function (e, n) {
							var s,
								o,
								l = r(a(e)),
								c = i(n),
								u = l.length;
							return c < 0 || c >= u ? (t ? "" : void 0) : (s = l.charCodeAt(c)) < 55296 || s > 56319 || c + 1 === u || (o = l.charCodeAt(c + 1)) < 56320 || o > 57343 ? (t ? l.charAt(c) : s) : t ? l.slice(c, c + 2) : o - 56320 + ((s - 55296) << 10) + 65536;
						};
					};
				t.exports = { codeAt: s(!1), charAt: s(!0) };
			},
			2941: (t, e, n) => {
				var i,
					r,
					a,
					s,
					o = n(1899),
					l = n(5981),
					c = n(6843),
					u = n(5463),
					h = n(1333),
					d = n(2749),
					p = n(6049),
					f = o.setImmediate,
					m = o.clearImmediate,
					v = o.process,
					g = o.MessageChannel,
					b = o.Dispatch,
					x = 0,
					y = {},
					_ = "onreadystatechange";
				try {
					i = o.location;
				} catch (t) {}
				var w = function (t) {
						if (y.hasOwnProperty(t)) {
							var e = y[t];
							delete y[t], e();
						}
					},
					M = function (t) {
						return function () {
							w(t);
						};
					},
					S = function (t) {
						w(t.data);
					},
					T = function (t) {
						o.postMessage(String(t), i.protocol + "//" + i.host);
					};
				(f && m) ||
					((f = function (t) {
						for (var e = [], n = arguments.length, i = 1; n > i; ) e.push(arguments[i++]);
						return (
							(y[++x] = function () {
								("function" == typeof t ? t : Function(t)).apply(void 0, e);
							}),
							r(x),
							x
						);
					}),
					(m = function (t) {
						delete y[t];
					}),
					p
						? (r = function (t) {
								v.nextTick(M(t));
						  })
						: b && b.now
						? (r = function (t) {
								b.now(M(t));
						  })
						: g && !d
						? ((s = (a = new g()).port2), (a.port1.onmessage = S), (r = c(s.postMessage, s, 1)))
						: o.addEventListener && "function" == typeof postMessage && !o.importScripts && i && "file:" !== i.protocol && !l(T)
						? ((r = T), o.addEventListener("message", S, !1))
						: (r =
								_ in h("script")
									? function (t) {
											u.appendChild(h("script")).onreadystatechange = function () {
												u.removeChild(this), w(t);
											};
									  }
									: function (t) {
											setTimeout(M(t), 0);
									  })),
					(t.exports = { set: f, clear: m });
			},
			9413: (t, e, n) => {
				var i = n(8459),
					r = Math.max,
					a = Math.min;
				t.exports = function (t, e) {
					var n = i(t);
					return n < 0 ? r(n + e, 0) : a(n, e);
				};
			},
			4529: (t, e, n) => {
				var i = n(7026),
					r = n(8219);
				t.exports = function (t) {
					return i(r(t));
				};
			},
			8459: (t) => {
				var e = Math.ceil,
					n = Math.floor;
				t.exports = function (t) {
					return isNaN((t = +t)) ? 0 : (t > 0 ? n : e)(t);
				};
			},
			3057: (t, e, n) => {
				var i = n(8459),
					r = Math.min;
				t.exports = function (t) {
					return t > 0 ? r(i(t), 9007199254740991) : 0;
				};
			},
			9678: (t, e, n) => {
				var i = n(8219);
				t.exports = function (t) {
					return Object(i(t));
				};
			},
			6935: (t, e, n) => {
				var i = n(941),
					r = n(6664),
					a = n(9811),
					s = n(9813)("toPrimitive");
				t.exports = function (t, e) {
					if (!i(t) || r(t)) return t;
					var n,
						o = t[s];
					if (void 0 !== o) {
						if ((void 0 === e && (e = "default"), (n = o.call(t, e)), !i(n) || r(n))) return n;
						throw TypeError("Can't convert object to primitive value");
					}
					return void 0 === e && (e = "number"), a(t, e);
				};
			},
			3894: (t, e, n) => {
				var i = n(6935),
					r = n(6664);
				t.exports = function (t) {
					var e = i(t, "string");
					return r(e) ? e : String(e);
				};
			},
			2885: (t, e, n) => {
				var i = {};
				(i[n(9813)("toStringTag")] = "z"), (t.exports = "[object z]" === String(i));
			},
			5803: (t, e, n) => {
				var i = n(6664);
				t.exports = function (t) {
					if (i(t)) throw TypeError("Cannot convert a Symbol value to a string");
					return String(t);
				};
			},
			9418: (t) => {
				var e = 0,
					n = Math.random();
				t.exports = function (t) {
					return "Symbol(" + String(void 0 === t ? "" : t) + ")_" + (++e + n).toString(36);
				};
			},
			2302: (t, e, n) => {
				var i = n(2497);
				t.exports = i && !Symbol.sham && "symbol" == typeof Symbol.iterator;
			},
			1477: (t, e, n) => {
				var i = n(9813);
				e.f = i;
			},
			9813: (t, e, n) => {
				var i = n(1899),
					r = n(8726),
					a = n(7457),
					s = n(9418),
					o = n(2497),
					l = n(2302),
					c = r("wks"),
					u = i.Symbol,
					h = l ? u : (u && u.withoutSetter) || s;
				t.exports = function (t) {
					return (a(c, t) && (o || "string" == typeof c[t])) || (o && a(u, t) ? (c[t] = u[t]) : (c[t] = h("Symbol." + t))), c[t];
				};
			},
			7627: (t, e, n) => {
				"use strict";
				var i = n(6887),
					r = n(249),
					a = n(8929),
					s = n(9290),
					o = n(2029),
					l = n(1887),
					c = n(3091),
					u = n(5803),
					h = function (t, e) {
						var n = this;
						if (!(n instanceof h)) return new h(t, e);
						a && (n = a(new Error(void 0), r(n))), void 0 !== e && o(n, "message", u(e));
						var i = [];
						return c(t, i.push, { that: i }), o(n, "errors", i), n;
					};
				(h.prototype = s(Error.prototype, { constructor: l(5, h), message: l(5, ""), name: l(5, "AggregateError") })), i({ global: !0 }, { AggregateError: h });
			},
			5906: (t, e, n) => {
				"use strict";
				var i = n(6887),
					r = n(5981),
					a = n(1052),
					s = n(941),
					o = n(9678),
					l = n(3057),
					c = n(5449),
					u = n(4692),
					h = n(568),
					d = n(9813),
					p = n(3385),
					f = d("isConcatSpreadable"),
					m = 9007199254740991,
					v = "Maximum allowed index exceeded",
					g =
						p >= 51 ||
						!r(function () {
							var t = [];
							return (t[f] = !1), t.concat()[0] !== t;
						}),
					b = h("concat"),
					x = function (t) {
						if (!s(t)) return !1;
						var e = t[f];
						return void 0 !== e ? !!e : a(t);
					};
				i(
					{ target: "Array", proto: !0, forced: !g || !b },
					{
						concat: function (t) {
							var e,
								n,
								i,
								r,
								a,
								s = o(this),
								h = u(s, 0),
								d = 0;
							for (e = -1, i = arguments.length; e < i; e++)
								if (x((a = -1 === e ? s : arguments[e]))) {
									if (d + (r = l(a.length)) > m) throw TypeError(v);
									for (n = 0; n < r; n++, d++) n in a && c(h, d, a[n]);
								} else {
									if (d >= m) throw TypeError(v);
									c(h, d++, a);
								}
							return (h.length = d), h;
						},
					}
				);
			},
			1501: (t, e, n) => {
				"use strict";
				var i = n(6887),
					r = n(3610).filter;
				i(
					{ target: "Array", proto: !0, forced: !n(568)("filter") },
					{
						filter: function (t) {
							return r(this, t, arguments.length > 1 ? arguments[1] : void 0);
						},
					}
				);
			},
			2437: (t, e, n) => {
				"use strict";
				var i = n(6887),
					r = n(6837);
				i({ target: "Array", proto: !0, forced: [].forEach != r }, { forEach: r });
			},
			3242: (t, e, n) => {
				var i = n(6887),
					r = n(1354);
				i(
					{
						target: "Array",
						stat: !0,
						forced: !n(1385)(function (t) {
							Array.from(t);
						}),
					},
					{ from: r }
				);
			},
			9076: (t, e, n) => {
				"use strict";
				var i = n(6887),
					r = n(1692).indexOf,
					a = n(4194),
					s = [].indexOf,
					o = !!s && 1 / [1].indexOf(1, -0) < 0,
					l = a("indexOf");
				i(
					{ target: "Array", proto: !0, forced: o || !l },
					{
						indexOf: function (t) {
							return o ? s.apply(this, arguments) || 0 : r(this, t, arguments.length > 1 ? arguments[1] : void 0);
						},
					}
				);
			},
			2988: (t, e, n) => {
				n(6887)({ target: "Array", stat: !0 }, { isArray: n(1052) });
			},
			6274: (t, e, n) => {
				"use strict";
				var i = n(4529),
					r = n(8479),
					a = n(2077),
					s = n(5402),
					o = n(7771),
					l = "Array Iterator",
					c = s.set,
					u = s.getterFor(l);
				(t.exports = o(
					Array,
					"Array",
					function (t, e) {
						c(this, { type: l, target: i(t), index: 0, kind: e });
					},
					function () {
						var t = u(this),
							e = t.target,
							n = t.kind,
							i = t.index++;
						return !e || i >= e.length ? ((t.target = void 0), { value: void 0, done: !0 }) : "keys" == n ? { value: i, done: !1 } : "values" == n ? { value: e[i], done: !1 } : { value: [i, e[i]], done: !1 };
					},
					"values"
				)),
					(a.Arguments = a.Array),
					r("keys"),
					r("values"),
					r("entries");
			},
			8787: (t, e, n) => {
				"use strict";
				var i = n(6887),
					r = n(3610).map;
				i(
					{ target: "Array", proto: !0, forced: !n(568)("map") },
					{
						map: function (t) {
							return r(this, t, arguments.length > 1 ? arguments[1] : void 0);
						},
					}
				);
			},
			186: (t, e, n) => {
				"use strict";
				var i = n(6887),
					r = n(941),
					a = n(1052),
					s = n(9413),
					o = n(3057),
					l = n(4529),
					c = n(5449),
					u = n(9813),
					h = n(568)("slice"),
					d = u("species"),
					p = [].slice,
					f = Math.max;
				i(
					{ target: "Array", proto: !0, forced: !h },
					{
						slice: function (t, e) {
							var n,
								i,
								u,
								h = l(this),
								m = o(h.length),
								v = s(t, m),
								g = s(void 0 === e ? m : e, m);
							if (a(h) && ("function" != typeof (n = h.constructor) || (n !== Array && !a(n.prototype)) ? r(n) && null === (n = n[d]) && (n = void 0) : (n = void 0), n === Array || void 0 === n)) return p.call(h, v, g);
							for (i = new (void 0 === n ? Array : n)(f(g - v, 0)), u = 0; v < g; v++, u++) v in h && c(i, u, h[v]);
							return (i.length = u), i;
						},
					}
				);
			},
			9120: (t, e, n) => {
				var i = n(1899);
				n(904)(i.JSON, "JSON", !0);
			},
			1507: (t, e, n) => {
				var i = n(6887),
					r = n(6383),
					a = Math.abs,
					s = Math.pow;
				i(
					{ target: "Math", stat: !0 },
					{
						cbrt: function (t) {
							return r((t = +t)) * s(a(t), 1 / 3);
						},
					}
				);
			},
			5327: () => {},
			9221: (t, e, n) => {
				var i = n(6887),
					r = n(4420);
				i({ target: "Object", stat: !0, forced: Object.assign !== r }, { assign: r });
			},
			3882: (t, e, n) => {
				n(6887)({ target: "Object", stat: !0, sham: !n(5746) }, { create: n(9290) });
			},
			4979: (t, e, n) => {
				var i = n(6887),
					r = n(5746);
				i({ target: "Object", stat: !0, forced: !r, sham: !r }, { defineProperties: n(9938) });
			},
			6450: (t, e, n) => {
				var i = n(6887),
					r = n(5746);
				i({ target: "Object", stat: !0, forced: !r, sham: !r }, { defineProperty: n(5988).f });
			},
			6924: (t, e, n) => {
				var i = n(6887),
					r = n(5981),
					a = n(4529),
					s = n(9677).f,
					o = n(5746),
					l = r(function () {
						s(1);
					});
				i(
					{ target: "Object", stat: !0, forced: !o || l, sham: !o },
					{
						getOwnPropertyDescriptor: function (t, e) {
							return s(a(t), e);
						},
					}
				);
			},
			8482: (t, e, n) => {
				var i = n(6887),
					r = n(5746),
					a = n(1136),
					s = n(4529),
					o = n(9677),
					l = n(5449);
				i(
					{ target: "Object", stat: !0, sham: !r },
					{
						getOwnPropertyDescriptors: function (t) {
							for (var e, n, i = s(t), r = o.f, c = a(i), u = {}, h = 0; c.length > h; ) void 0 !== (n = r(i, (e = c[h++]))) && l(u, e, n);
							return u;
						},
					}
				);
			},
			7405: (t, e, n) => {
				var i = n(6887),
					r = n(5981),
					a = n(9678),
					s = n(249),
					o = n(4160);
				i(
					{
						target: "Object",
						stat: !0,
						forced: r(function () {
							s(1);
						}),
						sham: !o,
					},
					{
						getPrototypeOf: function (t) {
							return s(a(t));
						},
					}
				);
			},
			1724: (t, e, n) => {
				var i = n(6887),
					r = n(9678),
					a = n(4771);
				i(
					{
						target: "Object",
						stat: !0,
						forced: n(5981)(function () {
							a(1);
						}),
					},
					{
						keys: function (t) {
							return a(r(t));
						},
					}
				);
			},
			108: (t, e, n) => {
				n(6887)({ target: "Object", stat: !0 }, { setPrototypeOf: n(8929) });
			},
			5967: () => {},
			4560: (t, e, n) => {
				"use strict";
				var i = n(6887),
					r = n(3916),
					a = n(9520),
					s = n(2),
					o = n(3091);
				i(
					{ target: "Promise", stat: !0 },
					{
						allSettled: function (t) {
							var e = this,
								n = a.f(e),
								i = n.resolve,
								l = n.reject,
								c = s(function () {
									var n = r(e.resolve),
										a = [],
										s = 0,
										l = 1;
									o(t, function (t) {
										var r = s++,
											o = !1;
										a.push(void 0),
											l++,
											n.call(e, t).then(
												function (t) {
													o || ((o = !0), (a[r] = { status: "fulfilled", value: t }), --l || i(a));
												},
												function (t) {
													o || ((o = !0), (a[r] = { status: "rejected", reason: t }), --l || i(a));
												}
											);
									}),
										--l || i(a);
								});
							return c.error && l(c.value), n.promise;
						},
					}
				);
			},
			7206: (t, e, n) => {
				"use strict";
				var i = n(6887),
					r = n(3916),
					a = n(626),
					s = n(9520),
					o = n(2),
					l = n(3091),
					c = "No one promise resolved";
				i(
					{ target: "Promise", stat: !0 },
					{
						any: function (t) {
							var e = this,
								n = s.f(e),
								i = n.resolve,
								u = n.reject,
								h = o(function () {
									var n = r(e.resolve),
										s = [],
										o = 0,
										h = 1,
										d = !1;
									l(t, function (t) {
										var r = o++,
											l = !1;
										s.push(void 0),
											h++,
											n.call(e, t).then(
												function (t) {
													l || d || ((d = !0), i(t));
												},
												function (t) {
													l || d || ((l = !0), (s[r] = t), --h || u(new (a("AggregateError"))(s, c)));
												}
											);
									}),
										--h || u(new (a("AggregateError"))(s, c));
								});
							return h.error && u(h.value), n.promise;
						},
					}
				);
			},
			4349: (t, e, n) => {
				"use strict";
				var i = n(6887),
					r = n(2529),
					a = n(9297),
					s = n(5981),
					o = n(626),
					l = n(487),
					c = n(6584),
					u = n(9754);
				if (
					(i(
						{
							target: "Promise",
							proto: !0,
							real: !0,
							forced:
								!!a &&
								s(function () {
									a.prototype.finally.call({ then: function () {} }, function () {});
								}),
						},
						{
							finally: function (t) {
								var e = l(this, o("Promise")),
									n = "function" == typeof t;
								return this.then(
									n
										? function (n) {
												return c(e, t()).then(function () {
													return n;
												});
										  }
										: t,
									n
										? function (n) {
												return c(e, t()).then(function () {
													throw n;
												});
										  }
										: t
								);
							},
						}
					),
					!r && "function" == typeof a)
				) {
					var h = o("Promise").prototype.finally;
					a.prototype.finally !== h && u(a.prototype, "finally", h, { unsafe: !0 });
				}
			},
			8881: (t, e, n) => {
				"use strict";
				var i,
					r,
					a,
					s,
					o = n(6887),
					l = n(2529),
					c = n(1899),
					u = n(626),
					h = n(9297),
					d = n(9754),
					p = n(7524),
					f = n(8929),
					m = n(904),
					v = n(4431),
					g = n(941),
					b = n(3916),
					x = n(5743),
					y = n(1302),
					_ = n(3091),
					w = n(1385),
					M = n(487),
					S = n(2941).set,
					T = n(6132),
					E = n(6584),
					C = n(4845),
					P = n(9520),
					A = n(2),
					L = n(5402),
					R = n(7252),
					D = n(9813),
					O = n(3321),
					z = n(6049),
					I = n(3385),
					k = D("species"),
					N = "Promise",
					V = L.get,
					B = L.set,
					F = L.getterFor(N),
					U = h && h.prototype,
					H = h,
					G = U,
					W = c.TypeError,
					j = c.document,
					X = c.process,
					q = P.f,
					Y = q,
					Z = !!(j && j.createEvent && c.dispatchEvent),
					K = "function" == typeof PromiseRejectionEvent,
					J = "unhandledrejection",
					Q = !1,
					$ = R(N, function () {
						var t = y(H),
							e = t !== String(H);
						if (!e && 66 === I) return !0;
						if (l && !G.finally) return !0;
						if (I >= 51 && /native code/.test(t)) return !1;
						var n = new H(function (t) {
								t(1);
							}),
							i = function (t) {
								t(
									function () {},
									function () {}
								);
							};
						return ((n.constructor = {})[k] = i), !(Q = n.then(function () {}) instanceof i) || (!e && O && !K);
					}),
					tt =
						$ ||
						!w(function (t) {
							H.all(t).catch(function () {});
						}),
					et = function (t) {
						var e;
						return !(!g(t) || "function" != typeof (e = t.then)) && e;
					},
					nt = function (t, e) {
						if (!t.notified) {
							t.notified = !0;
							var n = t.reactions;
							T(function () {
								for (var i = t.value, r = 1 == t.state, a = 0; n.length > a; ) {
									var s,
										o,
										l,
										c = n[a++],
										u = r ? c.ok : c.fail,
										h = c.resolve,
										d = c.reject,
										p = c.domain;
									try {
										u ? (r || (2 === t.rejection && st(t), (t.rejection = 1)), !0 === u ? (s = i) : (p && p.enter(), (s = u(i)), p && (p.exit(), (l = !0))), s === c.promise ? d(W("Promise-chain cycle")) : (o = et(s)) ? o.call(s, h, d) : h(s)) : d(i);
									} catch (t) {
										p && !l && p.exit(), d(t);
									}
								}
								(t.reactions = []), (t.notified = !1), e && !t.rejection && rt(t);
							});
						}
					},
					it = function (t, e, n) {
						var i, r;
						Z ? (((i = j.createEvent("Event")).promise = e), (i.reason = n), i.initEvent(t, !1, !0), c.dispatchEvent(i)) : (i = { promise: e, reason: n }), !K && (r = c["on" + t]) ? r(i) : t === J && C("Unhandled promise rejection", n);
					},
					rt = function (t) {
						S.call(c, function () {
							var e,
								n = t.facade,
								i = t.value;
							if (
								at(t) &&
								((e = A(function () {
									z ? X.emit("unhandledRejection", i, n) : it(J, n, i);
								})),
								(t.rejection = z || at(t) ? 2 : 1),
								e.error)
							)
								throw e.value;
						});
					},
					at = function (t) {
						return 1 !== t.rejection && !t.parent;
					},
					st = function (t) {
						S.call(c, function () {
							var e = t.facade;
							z ? X.emit("rejectionHandled", e) : it("rejectionhandled", e, t.value);
						});
					},
					ot = function (t, e, n) {
						return function (i) {
							t(e, i, n);
						};
					},
					lt = function (t, e, n) {
						t.done || ((t.done = !0), n && (t = n), (t.value = e), (t.state = 2), nt(t, !0));
					},
					ct = function (t, e, n) {
						if (!t.done) {
							(t.done = !0), n && (t = n);
							try {
								if (t.facade === e) throw W("Promise can't be resolved itself");
								var i = et(e);
								i
									? T(function () {
											var n = { done: !1 };
											try {
												i.call(e, ot(ct, n, t), ot(lt, n, t));
											} catch (e) {
												lt(n, e, t);
											}
									  })
									: ((t.value = e), (t.state = 1), nt(t, !1));
							} catch (e) {
								lt({ done: !1 }, e, t);
							}
						}
					};
				if (
					$ &&
					((G = (H = function (t) {
						x(this, H, N), b(t), i.call(this);
						var e = V(this);
						try {
							t(ot(ct, e), ot(lt, e));
						} catch (t) {
							lt(e, t);
						}
					}).prototype),
					((i = function (t) {
						B(this, { type: N, done: !1, notified: !1, parent: !1, reactions: [], rejection: !1, state: 0, value: void 0 });
					}).prototype = p(G, {
						then: function (t, e) {
							var n = F(this),
								i = q(M(this, H));
							return (i.ok = "function" != typeof t || t), (i.fail = "function" == typeof e && e), (i.domain = z ? X.domain : void 0), (n.parent = !0), n.reactions.push(i), 0 != n.state && nt(n, !1), i.promise;
						},
						catch: function (t) {
							return this.then(void 0, t);
						},
					})),
					(r = function () {
						var t = new i(),
							e = V(t);
						(this.promise = t), (this.resolve = ot(ct, e)), (this.reject = ot(lt, e));
					}),
					(P.f = q =
						function (t) {
							return t === H || t === a ? new r(t) : Y(t);
						}),
					!l && "function" == typeof h && U !== Object.prototype)
				) {
					(s = U.then),
						Q ||
							(d(
								U,
								"then",
								function (t, e) {
									var n = this;
									return new H(function (t, e) {
										s.call(n, t, e);
									}).then(t, e);
								},
								{ unsafe: !0 }
							),
							d(U, "catch", G.catch, { unsafe: !0 }));
					try {
						delete U.constructor;
					} catch (t) {}
					f && f(U, G);
				}
				o({ global: !0, wrap: !0, forced: $ }, { Promise: H }),
					m(H, N, !1, !0),
					v(N),
					(a = u(N)),
					o(
						{ target: N, stat: !0, forced: $ },
						{
							reject: function (t) {
								var e = q(this);
								return e.reject.call(void 0, t), e.promise;
							},
						}
					),
					o(
						{ target: N, stat: !0, forced: l || $ },
						{
							resolve: function (t) {
								return E(l && this === a ? H : this, t);
							},
						}
					),
					o(
						{ target: N, stat: !0, forced: tt },
						{
							all: function (t) {
								var e = this,
									n = q(e),
									i = n.resolve,
									r = n.reject,
									a = A(function () {
										var n = b(e.resolve),
											a = [],
											s = 0,
											o = 1;
										_(t, function (t) {
											var l = s++,
												c = !1;
											a.push(void 0),
												o++,
												n.call(e, t).then(function (t) {
													c || ((c = !0), (a[l] = t), --o || i(a));
												}, r);
										}),
											--o || i(a);
									});
								return a.error && r(a.value), n.promise;
							},
							race: function (t) {
								var e = this,
									n = q(e),
									i = n.reject,
									r = A(function () {
										var r = b(e.resolve);
										_(t, function (t) {
											r.call(e, t).then(n.resolve, i);
										});
									});
								return r.error && i(r.value), n.promise;
							},
						}
					);
			},
			7453: (t, e, n) => {
				var i = n(6887),
					r = n(626),
					a = n(3916),
					s = n(6059),
					o = n(941),
					l = n(9290),
					c = n(8308),
					u = n(5981),
					h = r("Reflect", "construct"),
					d = u(function () {
						function t() {}
						return !(h(function () {}, [], t) instanceof t);
					}),
					p = !u(function () {
						h(function () {});
					}),
					f = d || p;
				i(
					{ target: "Reflect", stat: !0, forced: f, sham: f },
					{
						construct: function (t, e) {
							a(t), s(e);
							var n = arguments.length < 3 ? t : a(arguments[2]);
							if (p && !d) return h(t, e, n);
							if (t == n) {
								switch (e.length) {
									case 0:
										return new t();
									case 1:
										return new t(e[0]);
									case 2:
										return new t(e[0], e[1]);
									case 3:
										return new t(e[0], e[1], e[2]);
									case 4:
										return new t(e[0], e[1], e[2], e[3]);
								}
								var i = [null];
								return i.push.apply(i, e), new (c.apply(t, i))();
							}
							var r = n.prototype,
								u = l(o(r) ? r : Object.prototype),
								f = Function.apply.call(t, u, e);
							return o(f) ? f : u;
						},
					}
				);
			},
			1502: () => {},
			7971: (t, e, n) => {
				"use strict";
				var i = n(4620).charAt,
					r = n(5803),
					a = n(5402),
					s = n(7771),
					o = "String Iterator",
					l = a.set,
					c = a.getterFor(o);
				s(
					String,
					"String",
					function (t) {
						l(this, { type: o, string: r(t), index: 0 });
					},
					function () {
						var t,
							e = c(this),
							n = e.string,
							r = e.index;
						return r >= n.length ? { value: void 0, done: !0 } : ((t = i(n, r)), (e.index += t.length), { value: t, done: !1 });
					}
				);
			},
			8555: (t, e, n) => {
				n(6349)("asyncIterator");
			},
			2615: () => {},
			1732: (t, e, n) => {
				n(6349)("hasInstance");
			},
			5903: (t, e, n) => {
				n(6349)("isConcatSpreadable");
			},
			1825: (t, e, n) => {
				n(6349)("iterator");
			},
			5824: (t, e, n) => {
				"use strict";
				var i = n(6887),
					r = n(1899),
					a = n(626),
					s = n(2529),
					o = n(5746),
					l = n(2497),
					c = n(5981),
					u = n(7457),
					h = n(1052),
					d = n(941),
					p = n(6664),
					f = n(6059),
					m = n(9678),
					v = n(4529),
					g = n(3894),
					b = n(5803),
					x = n(1887),
					y = n(9290),
					_ = n(4771),
					w = n(946),
					M = n(684),
					S = n(7857),
					T = n(9677),
					E = n(5988),
					C = n(6760),
					P = n(2029),
					A = n(9754),
					L = n(8726),
					R = n(4262),
					D = n(7748),
					O = n(9418),
					z = n(9813),
					I = n(1477),
					k = n(6349),
					N = n(904),
					V = n(5402),
					B = n(3610).forEach,
					F = R("hidden"),
					U = "Symbol",
					H = z("toPrimitive"),
					G = V.set,
					W = V.getterFor(U),
					j = Object.prototype,
					X = r.Symbol,
					q = a("JSON", "stringify"),
					Y = T.f,
					Z = E.f,
					K = M.f,
					J = C.f,
					Q = L("symbols"),
					$ = L("op-symbols"),
					tt = L("string-to-symbol-registry"),
					et = L("symbol-to-string-registry"),
					nt = L("wks"),
					it = r.QObject,
					rt = !it || !it.prototype || !it.prototype.findChild,
					at =
						o &&
						c(function () {
							return (
								7 !=
								y(
									Z({}, "a", {
										get: function () {
											return Z(this, "a", { value: 7 }).a;
										},
									})
								).a
							);
						})
							? function (t, e, n) {
									var i = Y(j, e);
									i && delete j[e], Z(t, e, n), i && t !== j && Z(j, e, i);
							  }
							: Z,
					st = function (t, e) {
						var n = (Q[t] = y(X.prototype));
						return G(n, { type: U, tag: t, description: e }), o || (n.description = e), n;
					},
					ot = function (t, e, n) {
						t === j && ot($, e, n), f(t);
						var i = g(e);
						return f(n), u(Q, i) ? (n.enumerable ? (u(t, F) && t[F][i] && (t[F][i] = !1), (n = y(n, { enumerable: x(0, !1) }))) : (u(t, F) || Z(t, F, x(1, {})), (t[F][i] = !0)), at(t, i, n)) : Z(t, i, n);
					},
					lt = function (t, e) {
						f(t);
						var n = v(e),
							i = _(n).concat(dt(n));
						return (
							B(i, function (e) {
								(o && !ct.call(n, e)) || ot(t, e, n[e]);
							}),
							t
						);
					},
					ct = function (t) {
						var e = g(t),
							n = J.call(this, e);
						return !(this === j && u(Q, e) && !u($, e)) && (!(n || !u(this, e) || !u(Q, e) || (u(this, F) && this[F][e])) || n);
					},
					ut = function (t, e) {
						var n = v(t),
							i = g(e);
						if (n !== j || !u(Q, i) || u($, i)) {
							var r = Y(n, i);
							return !r || !u(Q, i) || (u(n, F) && n[F][i]) || (r.enumerable = !0), r;
						}
					},
					ht = function (t) {
						var e = K(v(t)),
							n = [];
						return (
							B(e, function (t) {
								u(Q, t) || u(D, t) || n.push(t);
							}),
							n
						);
					},
					dt = function (t) {
						var e = t === j,
							n = K(e ? $ : v(t)),
							i = [];
						return (
							B(n, function (t) {
								!u(Q, t) || (e && !u(j, t)) || i.push(Q[t]);
							}),
							i
						);
					};
				(l ||
					(A(
						(X = function () {
							if (this instanceof X) throw TypeError("Symbol is not a constructor");
							var t = arguments.length && void 0 !== arguments[0] ? b(arguments[0]) : void 0,
								e = O(t),
								n = function (t) {
									this === j && n.call($, t), u(this, F) && u(this[F], e) && (this[F][e] = !1), at(this, e, x(1, t));
								};
							return o && rt && at(j, e, { configurable: !0, set: n }), st(e, t);
						}).prototype,
						"toString",
						function () {
							return W(this).tag;
						}
					),
					A(X, "withoutSetter", function (t) {
						return st(O(t), t);
					}),
					(C.f = ct),
					(E.f = ot),
					(T.f = ut),
					(w.f = M.f = ht),
					(S.f = dt),
					(I.f = function (t) {
						return st(z(t), t);
					}),
					o &&
						(Z(X.prototype, "description", {
							configurable: !0,
							get: function () {
								return W(this).description;
							},
						}),
						s || A(j, "propertyIsEnumerable", ct, { unsafe: !0 }))),
				i({ global: !0, wrap: !0, forced: !l, sham: !l }, { Symbol: X }),
				B(_(nt), function (t) {
					k(t);
				}),
				i(
					{ target: U, stat: !0, forced: !l },
					{
						for: function (t) {
							var e = b(t);
							if (u(tt, e)) return tt[e];
							var n = X(e);
							return (tt[e] = n), (et[n] = e), n;
						},
						keyFor: function (t) {
							if (!p(t)) throw TypeError(t + " is not a symbol");
							if (u(et, t)) return et[t];
						},
						useSetter: function () {
							rt = !0;
						},
						useSimple: function () {
							rt = !1;
						},
					}
				),
				i(
					{ target: "Object", stat: !0, forced: !l, sham: !o },
					{
						create: function (t, e) {
							return void 0 === e ? y(t) : lt(y(t), e);
						},
						defineProperty: ot,
						defineProperties: lt,
						getOwnPropertyDescriptor: ut,
					}
				),
				i({ target: "Object", stat: !0, forced: !l }, { getOwnPropertyNames: ht, getOwnPropertySymbols: dt }),
				i(
					{
						target: "Object",
						stat: !0,
						forced: c(function () {
							S.f(1);
						}),
					},
					{
						getOwnPropertySymbols: function (t) {
							return S.f(m(t));
						},
					}
				),
				q) &&
					i(
						{
							target: "JSON",
							stat: !0,
							forced:
								!l ||
								c(function () {
									var t = X();
									return "[null]" != q([t]) || "{}" != q({ a: t }) || "{}" != q(Object(t));
								}),
						},
						{
							stringify: function (t, e, n) {
								for (var i, r = [t], a = 1; arguments.length > a; ) r.push(arguments[a++]);
								if (((i = e), (d(e) || void 0 !== t) && !p(t)))
									return (
										h(e) ||
											(e = function (t, e) {
												if (("function" == typeof i && (e = i.call(this, t, e)), !p(e))) return e;
											}),
										(r[1] = e),
										q.apply(null, r)
									);
							},
						}
					);
				X.prototype[H] || P(X.prototype, H, X.prototype.valueOf), N(X, U), (D[F] = !0);
			},
			5915: (t, e, n) => {
				n(6349)("matchAll");
			},
			8394: (t, e, n) => {
				n(6349)("match");
			},
			1766: (t, e, n) => {
				n(6349)("replace");
			},
			2737: (t, e, n) => {
				n(6349)("search");
			},
			9911: (t, e, n) => {
				n(6349)("species");
			},
			4315: (t, e, n) => {
				n(6349)("split");
			},
			3131: (t, e, n) => {
				n(6349)("toPrimitive");
			},
			4714: (t, e, n) => {
				n(6349)("toStringTag");
			},
			659: (t, e, n) => {
				n(6349)("unscopables");
			},
			9731: (t, e, n) => {
				n(7627);
			},
			5708: (t, e, n) => {
				n(4560);
			},
			8731: (t, e, n) => {
				n(7206);
			},
			14: (t, e, n) => {
				"use strict";
				var i = n(6887),
					r = n(9520),
					a = n(2);
				i(
					{ target: "Promise", stat: !0 },
					{
						try: function (t) {
							var e = r.f(this),
								n = a(t);
							return (n.error ? e.reject : e.resolve)(n.value), e.promise;
						},
					}
				);
			},
			8783: (t, e, n) => {
				n(6349)("asyncDispose");
			},
			3975: (t, e, n) => {
				n(6349)("dispose");
			},
			5799: (t, e, n) => {
				n(6349)("matcher");
			},
			5414: (t, e, n) => {
				n(6349)("metadata");
			},
			6774: (t, e, n) => {
				n(6349)("observable");
			},
			620: (t, e, n) => {
				n(6349)("patternMatch");
			},
			6172: (t, e, n) => {
				n(6349)("replaceAll");
			},
			7634: (t, e, n) => {
				n(6274);
				var i = n(3281),
					r = n(1899),
					a = n(9697),
					s = n(2029),
					o = n(2077),
					l = n(9813)("toStringTag");
				for (var c in i) {
					var u = r[c],
						h = u && u.prototype;
					h && a(h) !== l && s(h, l, c), (o[c] = o.Array);
				}
			},
			1249: (t, e, n) => {
				var i = n(6887),
					r = n(1899),
					a = n(2861),
					s = [].slice,
					o = function (t) {
						return function (e, n) {
							var i = arguments.length > 2,
								r = i ? s.call(arguments, 2) : void 0;
							return t(
								i
									? function () {
											("function" == typeof e ? e : Function(e)).apply(this, r);
									  }
									: e,
								n
							);
						};
					};
				i({ global: !0, bind: !0, forced: /MSIE .\./.test(a) }, { setTimeout: o(r.setTimeout), setInterval: o(r.setInterval) });
			},
			7698: (t, e, n) => {
				var i = n(4493);
				t.exports = i;
			},
			3363: (t, e, n) => {
				var i = n(4034);
				t.exports = i;
			},
			9216: (t, e, n) => {
				var i = n(9324);
				t.exports = i;
			},
			6243: (t, e, n) => {
				var i = n(3830);
				n(7634), (t.exports = i);
			},
			1955: (t, e, n) => {
				var i = n(2480);
				t.exports = i;
			},
			6279: (t, e, n) => {
				n(7634);
				var i = n(9216),
					r = n(9697),
					a = Array.prototype,
					s = { DOMTokenList: !0, NodeList: !0 };
				t.exports = function (t) {
					var e = t.forEach;
					return t === a || (t instanceof Array && e === a.forEach) || s.hasOwnProperty(r(t)) ? i : e;
				};
			},
			9373: (t, e, n) => {
				var i = n(4570);
				t.exports = i;
			},
			1798: (t, e, n) => {
				var i = n(8287);
				t.exports = i;
			},
			2073: (t, e, n) => {
				var i = n(9601);
				t.exports = i;
			},
			4604: (t, e, n) => {
				var i = n(6536);
				t.exports = i;
			},
			3383: (t, e, n) => {
				var i = n(5999);
				t.exports = i;
			},
			4471: (t, e, n) => {
				var i = n(5254);
				t.exports = i;
			},
			7396: (t, e, n) => {
				var i = n(7702);
				t.exports = i;
			},
			1910: (t, e, n) => {
				var i = n(8171);
				t.exports = i;
			},
			9427: (t, e, n) => {
				var i = n(286);
				t.exports = i;
			},
			2857: (t, e, n) => {
				var i = n(2766);
				t.exports = i;
			},
			9534: (t, e, n) => {
				var i = n(498);
				t.exports = i;
			},
			6507: (t, e, n) => {
				var i = n(3966);
				t.exports = i;
			},
			3059: (t, e, n) => {
				var i = n(8494);
				t.exports = i;
			},
			6670: (t, e, n) => {
				var i = n(3065);
				t.exports = i;
			},
			7460: (t, e, n) => {
				var i = n(2956);
				n(7634), (t.exports = i);
			},
			1895: (t, e, n) => {
				var i = n(4983);
				t.exports = i;
			},
			7989: (t, e, n) => {
				n(1249);
				var i = n(4058);
				t.exports = i.setTimeout;
			},
			2547: (t, e, n) => {
				var i = n(7473);
				n(7634), (t.exports = i);
			},
			6509: (t, e, n) => {
				var i = n(4227);
				n(7634), (t.exports = i);
			},
			5666: (t) => {
				var e = (function (t) {
					"use strict";
					var e,
						n = Object.prototype,
						i = n.hasOwnProperty,
						r = "function" == typeof Symbol ? Symbol : {},
						a = r.iterator || "@@iterator",
						s = r.asyncIterator || "@@asyncIterator",
						o = r.toStringTag || "@@toStringTag";
					function l(t, e, n) {
						return Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }), t[e];
					}
					try {
						l({}, "");
					} catch (t) {
						l = function (t, e, n) {
							return (t[e] = n);
						};
					}
					function c(t, e, n, i) {
						var r = e && e.prototype instanceof v ? e : v,
							a = Object.create(r.prototype),
							s = new P(i || []);
						return (
							(a._invoke = (function (t, e, n) {
								var i = h;
								return function (r, a) {
									if (i === p) throw new Error("Generator is already running");
									if (i === f) {
										if ("throw" === r) throw a;
										return L();
									}
									for (n.method = r, n.arg = a; ; ) {
										var s = n.delegate;
										if (s) {
											var o = T(s, n);
											if (o) {
												if (o === m) continue;
												return o;
											}
										}
										if ("next" === n.method) n.sent = n._sent = n.arg;
										else if ("throw" === n.method) {
											if (i === h) throw ((i = f), n.arg);
											n.dispatchException(n.arg);
										} else "return" === n.method && n.abrupt("return", n.arg);
										i = p;
										var l = u(t, e, n);
										if ("normal" === l.type) {
											if (((i = n.done ? f : d), l.arg === m)) continue;
											return { value: l.arg, done: n.done };
										}
										"throw" === l.type && ((i = f), (n.method = "throw"), (n.arg = l.arg));
									}
								};
							})(t, n, s)),
							a
						);
					}
					function u(t, e, n) {
						try {
							return { type: "normal", arg: t.call(e, n) };
						} catch (t) {
							return { type: "throw", arg: t };
						}
					}
					t.wrap = c;
					var h = "suspendedStart",
						d = "suspendedYield",
						p = "executing",
						f = "completed",
						m = {};
					function v() {}
					function g() {}
					function b() {}
					var x = {};
					l(x, a, function () {
						return this;
					});
					var y = Object.getPrototypeOf,
						_ = y && y(y(A([])));
					_ && _ !== n && i.call(_, a) && (x = _);
					var w = (b.prototype = v.prototype = Object.create(x));
					function M(t) {
						["next", "throw", "return"].forEach(function (e) {
							l(t, e, function (t) {
								return this._invoke(e, t);
							});
						});
					}
					function S(t, e) {
						function n(r, a, s, o) {
							var l = u(t[r], t, a);
							if ("throw" !== l.type) {
								var c = l.arg,
									h = c.value;
								return h && "object" == typeof h && i.call(h, "__await")
									? e.resolve(h.__await).then(
											function (t) {
												n("next", t, s, o);
											},
											function (t) {
												n("throw", t, s, o);
											}
									  )
									: e.resolve(h).then(
											function (t) {
												(c.value = t), s(c);
											},
											function (t) {
												return n("throw", t, s, o);
											}
									  );
							}
							o(l.arg);
						}
						var r;
						this._invoke = function (t, i) {
							function a() {
								return new e(function (e, r) {
									n(t, i, e, r);
								});
							}
							return (r = r ? r.then(a, a) : a());
						};
					}
					function T(t, n) {
						var i = t.iterator[n.method];
						if (i === e) {
							if (((n.delegate = null), "throw" === n.method)) {
								if (t.iterator.return && ((n.method = "return"), (n.arg = e), T(t, n), "throw" === n.method)) return m;
								(n.method = "throw"), (n.arg = new TypeError("The iterator does not provide a 'throw' method"));
							}
							return m;
						}
						var r = u(i, t.iterator, n.arg);
						if ("throw" === r.type) return (n.method = "throw"), (n.arg = r.arg), (n.delegate = null), m;
						var a = r.arg;
						return a ? (a.done ? ((n[t.resultName] = a.value), (n.next = t.nextLoc), "return" !== n.method && ((n.method = "next"), (n.arg = e)), (n.delegate = null), m) : a) : ((n.method = "throw"), (n.arg = new TypeError("iterator result is not an object")), (n.delegate = null), m);
					}
					function E(t) {
						var e = { tryLoc: t[0] };
						1 in t && (e.catchLoc = t[1]), 2 in t && ((e.finallyLoc = t[2]), (e.afterLoc = t[3])), this.tryEntries.push(e);
					}
					function C(t) {
						var e = t.completion || {};
						(e.type = "normal"), delete e.arg, (t.completion = e);
					}
					function P(t) {
						(this.tryEntries = [{ tryLoc: "root" }]), t.forEach(E, this), this.reset(!0);
					}
					function A(t) {
						if (t) {
							var n = t[a];
							if (n) return n.call(t);
							if ("function" == typeof t.next) return t;
							if (!isNaN(t.length)) {
								var r = -1,
									s = function n() {
										for (; ++r < t.length; ) if (i.call(t, r)) return (n.value = t[r]), (n.done = !1), n;
										return (n.value = e), (n.done = !0), n;
									};
								return (s.next = s);
							}
						}
						return { next: L };
					}
					function L() {
						return { value: e, done: !0 };
					}
					return (
						(g.prototype = b),
						l(w, "constructor", b),
						l(b, "constructor", g),
						(g.displayName = l(b, o, "GeneratorFunction")),
						(t.isGeneratorFunction = function (t) {
							var e = "function" == typeof t && t.constructor;
							return !!e && (e === g || "GeneratorFunction" === (e.displayName || e.name));
						}),
						(t.mark = function (t) {
							return Object.setPrototypeOf ? Object.setPrototypeOf(t, b) : ((t.__proto__ = b), l(t, o, "GeneratorFunction")), (t.prototype = Object.create(w)), t;
						}),
						(t.awrap = function (t) {
							return { __await: t };
						}),
						M(S.prototype),
						l(S.prototype, s, function () {
							return this;
						}),
						(t.AsyncIterator = S),
						(t.async = function (e, n, i, r, a) {
							void 0 === a && (a = Promise);
							var s = new S(c(e, n, i, r), a);
							return t.isGeneratorFunction(n)
								? s
								: s.next().then(function (t) {
										return t.done ? t.value : s.next();
								  });
						}),
						M(w),
						l(w, o, "Generator"),
						l(w, a, function () {
							return this;
						}),
						l(w, "toString", function () {
							return "[object Generator]";
						}),
						(t.keys = function (t) {
							var e = [];
							for (var n in t) e.push(n);
							return (
								e.reverse(),
								function n() {
									for (; e.length; ) {
										var i = e.pop();
										if (i in t) return (n.value = i), (n.done = !1), n;
									}
									return (n.done = !0), n;
								}
							);
						}),
						(t.values = A),
						(P.prototype = {
							constructor: P,
							reset: function (t) {
								if (((this.prev = 0), (this.next = 0), (this.sent = this._sent = e), (this.done = !1), (this.delegate = null), (this.method = "next"), (this.arg = e), this.tryEntries.forEach(C), !t)) for (var n in this) "t" === n.charAt(0) && i.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = e);
							},
							stop: function () {
								this.done = !0;
								var t = this.tryEntries[0].completion;
								if ("throw" === t.type) throw t.arg;
								return this.rval;
							},
							dispatchException: function (t) {
								if (this.done) throw t;
								var n = this;
								function r(i, r) {
									return (o.type = "throw"), (o.arg = t), (n.next = i), r && ((n.method = "next"), (n.arg = e)), !!r;
								}
								for (var a = this.tryEntries.length - 1; a >= 0; --a) {
									var s = this.tryEntries[a],
										o = s.completion;
									if ("root" === s.tryLoc) return r("end");
									if (s.tryLoc <= this.prev) {
										var l = i.call(s, "catchLoc"),
											c = i.call(s, "finallyLoc");
										if (l && c) {
											if (this.prev < s.catchLoc) return r(s.catchLoc, !0);
											if (this.prev < s.finallyLoc) return r(s.finallyLoc);
										} else if (l) {
											if (this.prev < s.catchLoc) return r(s.catchLoc, !0);
										} else {
											if (!c) throw new Error("try statement without catch or finally");
											if (this.prev < s.finallyLoc) return r(s.finallyLoc);
										}
									}
								}
							},
							abrupt: function (t, e) {
								for (var n = this.tryEntries.length - 1; n >= 0; --n) {
									var r = this.tryEntries[n];
									if (r.tryLoc <= this.prev && i.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
										var a = r;
										break;
									}
								}
								a && ("break" === t || "continue" === t) && a.tryLoc <= e && e <= a.finallyLoc && (a = null);
								var s = a ? a.completion : {};
								return (s.type = t), (s.arg = e), a ? ((this.method = "next"), (this.next = a.finallyLoc), m) : this.complete(s);
							},
							complete: function (t, e) {
								if ("throw" === t.type) throw t.arg;
								return "break" === t.type || "continue" === t.type ? (this.next = t.arg) : "return" === t.type ? ((this.rval = this.arg = t.arg), (this.method = "return"), (this.next = "end")) : "normal" === t.type && e && (this.next = e), m;
							},
							finish: function (t) {
								for (var e = this.tryEntries.length - 1; e >= 0; --e) {
									var n = this.tryEntries[e];
									if (n.finallyLoc === t) return this.complete(n.completion, n.afterLoc), C(n), m;
								}
							},
							catch: function (t) {
								for (var e = this.tryEntries.length - 1; e >= 0; --e) {
									var n = this.tryEntries[e];
									if (n.tryLoc === t) {
										var i = n.completion;
										if ("throw" === i.type) {
											var r = i.arg;
											C(n);
										}
										return r;
									}
								}
								throw new Error("illegal catch attempt");
							},
							delegateYield: function (t, n, i) {
								return (this.delegate = { iterator: A(t), resultName: n, nextLoc: i }), "next" === this.method && (this.arg = e), m;
							},
						}),
						t
					);
				})(t.exports);
				try {
					regeneratorRuntime = e;
				} catch (t) {
					"object" == typeof globalThis ? (globalThis.regeneratorRuntime = e) : Function("r", "regeneratorRuntime = r")(e);
				}
			},
			3466: function (t) {
				var e;
				t.exports =
					(((e = function () {
						function t(t) {
							return r.appendChild(t.dom), t;
						}
						function n(t) {
							for (var e = 0; e < r.children.length; e++) r.children[e].style.display = e === t ? "block" : "none";
							i = t;
						}
						var i = 0,
							r = document.createElement("div");
						(r.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000"),
							r.addEventListener(
								"click",
								function (t) {
									t.preventDefault(), n(++i % r.children.length);
								},
								!1
							);
						var a = (performance || Date).now(),
							s = a,
							o = 0,
							l = t(new e.Panel("FPS", "#0ff", "#002")),
							c = t(new e.Panel("MS", "#0f0", "#020"));
						if (self.performance && self.performance.memory) var u = t(new e.Panel("MB", "#f08", "#201"));
						return (
							n(0),
							{
								REVISION: 16,
								dom: r,
								addPanel: t,
								showPanel: n,
								begin: function () {
									a = (performance || Date).now();
								},
								end: function () {
									o++;
									var t = (performance || Date).now();
									if ((c.update(t - a, 200), t > s + 1e3 && (l.update((1e3 * o) / (t - s), 100), (s = t), (o = 0), u))) {
										var e = performance.memory;
										u.update(e.usedJSHeapSize / 1048576, e.jsHeapSizeLimit / 1048576);
									}
									return t;
								},
								update: function () {
									a = this.end();
								},
								domElement: r,
								setMode: n,
							}
						);
					}).Panel = function (t, e, n) {
						var i = 1 / 0,
							r = 0,
							a = Math.round,
							s = a(window.devicePixelRatio || 1),
							o = 80 * s,
							l = 48 * s,
							c = 3 * s,
							u = 2 * s,
							h = 3 * s,
							d = 15 * s,
							p = 74 * s,
							f = 30 * s,
							m = document.createElement("canvas");
						(m.width = o), (m.height = l), (m.style.cssText = "width:80px;height:48px");
						var v = m.getContext("2d");
						return (
							(v.font = "bold " + 9 * s + "px Helvetica,Arial,sans-serif"),
							(v.textBaseline = "top"),
							(v.fillStyle = n),
							v.fillRect(0, 0, o, l),
							(v.fillStyle = e),
							v.fillText(t, c, u),
							v.fillRect(h, d, p, f),
							(v.fillStyle = n),
							(v.globalAlpha = 0.9),
							v.fillRect(h, d, p, f),
							{
								dom: m,
								update: function (l, g) {
									(i = Math.min(i, l)), (r = Math.max(r, l)), (v.fillStyle = n), (v.globalAlpha = 1), v.fillRect(0, 0, o, d), (v.fillStyle = e), v.fillText(a(l) + " " + t + " (" + a(i) + "-" + a(r) + ")", c, u), v.drawImage(m, h + s, d, p - s, f, h, d, p - s, f), v.fillRect(h + p - s, d, s, f), (v.fillStyle = n), (v.globalAlpha = 0.9), v.fillRect(h + p - s, d, s, a((1 - l / g) * f));
								},
							}
						);
					}),
					e);
			},
			6498: function (t, e) {
				!(function (t) {
					"use strict";
					class e {
						constructor(t) {
							const [e, n] = t.split("-"),
								i = e.split(".");
							(this.major = parseInt(i[0], 10)), (this.minor = parseInt(i[1], 10)), (this.patch = parseInt(i[2], 10)), (this.prerelease = null != n ? n : null);
						}
						toString() {
							const t = [this.major, this.minor, this.patch].join(".");
							return null !== this.prerelease ? [t, this.prerelease].join("-") : t;
						}
					}
					class n {
						constructor(t) {
							this.controller_ = t;
						}
						get disabled() {
							return this.controller_.viewProps.get("disabled");
						}
						set disabled(t) {
							this.controller_.viewProps.set("disabled", t);
						}
						get hidden() {
							return this.controller_.viewProps.get("hidden");
						}
						set hidden(t) {
							this.controller_.viewProps.set("hidden", t);
						}
						dispose() {
							this.controller_.viewProps.set("disposed", !0);
						}
					}
					class i {
						constructor(t) {
							this.target = t;
						}
					}
					class r extends i {
						constructor(t, e, n, i) {
							super(t), (this.value = e), (this.presetKey = n), (this.last = null == i || i);
						}
					}
					class a extends i {
						constructor(t, e, n) {
							super(t), (this.value = e), (this.presetKey = n);
						}
					}
					class s extends i {
						constructor(t, e) {
							super(t), (this.expanded = e);
						}
					}
					function o(t) {
						return t;
					}
					function l(t) {
						return null == t;
					}
					function c(t, e) {
						if (t.length !== e.length) return !1;
						for (let n = 0; n < t.length; n++) if (t[n] !== e[n]) return !1;
						return !0;
					}
					const u = { alreadydisposed: () => "View has been already disposed", invalidparams: (t) => `Invalid parameters for '${t.name}'`, nomatchingcontroller: (t) => `No matching controller for '${t.key}'`, nomatchingview: (t) => `No matching view for '${JSON.stringify(t.params)}'`, notbindable: () => "Value is not bindable", propertynotfound: (t) => `Property '${t.name}' not found`, shouldneverhappen: () => "This error should never happen" };
					class h {
						constructor(t) {
							var e;
							(this.message = null !== (e = u[t.type](o(t.context))) && void 0 !== e ? e : "Unexpected error"), (this.name = this.constructor.name), (this.stack = new Error(this.message).stack), (this.type = t.type);
						}
						static alreadyDisposed() {
							return new h({ type: "alreadydisposed" });
						}
						static notBindable() {
							return new h({ type: "notbindable" });
						}
						static propertyNotFound(t) {
							return new h({ type: "propertynotfound", context: { name: t } });
						}
						static shouldNeverHappen() {
							return new h({ type: "shouldneverhappen" });
						}
					}
					class d {
						constructor(t, e, n) {
							(this.obj_ = t), (this.key_ = e), (this.presetKey_ = null != n ? n : e);
						}
						static isBindable(t) {
							return null !== t && "object" == typeof t;
						}
						get key() {
							return this.key_;
						}
						get presetKey() {
							return this.presetKey_;
						}
						read() {
							return this.obj_[this.key_];
						}
						write(t) {
							this.obj_[this.key_] = t;
						}
						writeProperty(t, e) {
							const n = this.read();
							if (!d.isBindable(n)) throw h.notBindable();
							if (!(t in n)) throw h.propertyNotFound(t);
							n[t] = e;
						}
					}
					class p extends n {
						get label() {
							return this.controller_.props.get("label");
						}
						set label(t) {
							this.controller_.props.set("label", t);
						}
						get title() {
							var t;
							return null !== (t = this.controller_.valueController.props.get("title")) && void 0 !== t ? t : "";
						}
						set title(t) {
							this.controller_.valueController.props.set("title", t);
						}
						on(t, e) {
							const n = e.bind(this);
							return (
								this.controller_.valueController.emitter.on(t, () => {
									n(new i(this));
								}),
								this
							);
						}
					}
					class f {
						constructor() {
							this.observers_ = {};
						}
						on(t, e) {
							let n = this.observers_[t];
							return n || (n = this.observers_[t] = []), n.push({ handler: e }), this;
						}
						off(t, e) {
							const n = this.observers_[t];
							return n && (this.observers_[t] = n.filter((t) => t.handler !== e)), this;
						}
						emit(t, e) {
							const n = this.observers_[t];
							n &&
								n.forEach((t) => {
									t.handler(e);
								});
						}
					}
					const m = "tp";
					function v(t) {
						return (e, n) => [m, "-", t, "v", e ? `_${e}` : "", n ? `-${n}` : ""].join("");
					}
					function g(t, e) {
						return (n) => e(t(n));
					}
					function b(t) {
						return t.rawValue;
					}
					function x(t, e) {
						t.emitter.on("change", g(b, e)), e(t.rawValue);
					}
					function y(t, e, n) {
						x(t.value(e), n);
					}
					function _(t, e, n) {
						n ? t.classList.add(e) : t.classList.remove(e);
					}
					function w(t, e) {
						return (n) => {
							_(t, e, n);
						};
					}
					function M(t, e) {
						x(t, (t) => {
							e.textContent = null != t ? t : "";
						});
					}
					const S = v("btn");
					class T {
						constructor(t, e) {
							(this.element = t.createElement("div")), this.element.classList.add(S()), e.viewProps.bindClassModifiers(this.element);
							const n = t.createElement("button");
							n.classList.add(S("b")), e.viewProps.bindDisabled(n), this.element.appendChild(n), (this.buttonElement = n);
							const i = t.createElement("div");
							i.classList.add(S("t")), M(e.props.value("title"), i), this.buttonElement.appendChild(i);
						}
					}
					class E {
						constructor(t, e) {
							(this.emitter = new f()), (this.onClick_ = this.onClick_.bind(this)), (this.props = e.props), (this.viewProps = e.viewProps), (this.view = new T(t, { props: this.props, viewProps: this.viewProps })), this.view.buttonElement.addEventListener("click", this.onClick_);
						}
						onClick_() {
							this.emitter.emit("click", { sender: this });
						}
					}
					class C {
						constructor(t, e) {
							var n;
							(this.constraint_ = null == e ? void 0 : e.constraint), (this.equals_ = null !== (n = null == e ? void 0 : e.equals) && void 0 !== n ? n : (t, e) => t === e), (this.emitter = new f()), (this.rawValue_ = t);
						}
						get constraint() {
							return this.constraint_;
						}
						get rawValue() {
							return this.rawValue_;
						}
						set rawValue(t) {
							this.setRawValue(t, { forceEmit: !1, last: !0 });
						}
						setRawValue(t, e) {
							const n = null != e ? e : { forceEmit: !1, last: !0 },
								i = this.constraint_ ? this.constraint_.constrain(t) : t;
							(!this.equals_(this.rawValue_, i) || n.forceEmit) && (this.emitter.emit("beforechange", { sender: this }), (this.rawValue_ = i), this.emitter.emit("change", { options: n, rawValue: i, sender: this }));
						}
					}
					class P {
						constructor(t) {
							(this.emitter = new f()), (this.value_ = t);
						}
						get rawValue() {
							return this.value_;
						}
						set rawValue(t) {
							this.setRawValue(t, { forceEmit: !1, last: !0 });
						}
						setRawValue(t, e) {
							const n = null != e ? e : { forceEmit: !1, last: !0 };
							(this.value_ !== t || n.forceEmit) && (this.emitter.emit("beforechange", { sender: this }), (this.value_ = t), this.emitter.emit("change", { options: n, rawValue: this.value_, sender: this }));
						}
					}
					function A(t, e) {
						const n = null == e ? void 0 : e.constraint,
							i = null == e ? void 0 : e.equals;
						return n || i ? new C(t, e) : new P(t);
					}
					class L {
						constructor(t) {
							(this.emitter = new f()), (this.valMap_ = t);
							for (const t in this.valMap_)
								this.valMap_[t].emitter.on("change", () => {
									this.emitter.emit("change", { key: t, sender: this });
								});
						}
						static createCore(t) {
							return Object.keys(t).reduce((e, n) => Object.assign(e, { [n]: A(t[n]) }), {});
						}
						static fromObject(t) {
							const e = this.createCore(t);
							return new L(e);
						}
						get(t) {
							return this.valMap_[t].rawValue;
						}
						set(t, e) {
							this.valMap_[t].rawValue = e;
						}
						value(t) {
							return this.valMap_[t];
						}
					}
					function R(t, e) {
						return o(
							Object.keys(e).reduce((n, i) => {
								if (void 0 === n) return;
								const r = (0, e[i])(t[i]);
								return r.succeeded ? Object.assign(Object.assign({}, n), { [i]: r.value }) : void 0;
							}, {})
						);
					}
					function D(t, e) {
						return t.reduce((t, n) => {
							if (void 0 === t) return;
							const i = e(n);
							return i.succeeded && void 0 !== i.value ? [...t, i.value] : void 0;
						}, []);
					}
					function O(t) {
						return null !== t && "object" == typeof t;
					}
					function z(t) {
						return (e) => (n) => {
							if (!e && void 0 === n) return { succeeded: !1, value: void 0 };
							if (e && void 0 === n) return { succeeded: !0, value: void 0 };
							const i = t(n);
							return void 0 !== i ? { succeeded: !0, value: i } : { succeeded: !1, value: void 0 };
						};
					}
					function I(t) {
						return {
							custom: (e) => z(e)(t),
							boolean: z((t) => ("boolean" == typeof t ? t : void 0))(t),
							number: z((t) => ("number" == typeof t ? t : void 0))(t),
							string: z((t) => ("string" == typeof t ? t : void 0))(t),
							function: z((t) => ("function" == typeof t ? t : void 0))(t),
							constant: (e) => z((t) => (t === e ? e : void 0))(t),
							raw: z((t) => t)(t),
							object: (e) =>
								z((t) => {
									if (O(t)) return R(t, e);
								})(t),
							array: (e) =>
								z((t) => {
									if (Array.isArray(t)) return D(t, e);
								})(t),
						};
					}
					const k = { optional: I(!0), required: I(!1) };
					function N(t, e) {
						const n = k.required.object(e)(t);
						return n.succeeded ? n.value : void 0;
					}
					function V(t) {
						return t && t.parentElement && t.parentElement.removeChild(t), null;
					}
					function B() {
						return ["veryfirst", "first", "last", "verylast"];
					}
					const F = v(""),
						U = { veryfirst: "vfst", first: "fst", last: "lst", verylast: "vlst" };
					class H {
						constructor(t) {
							(this.parent_ = null), (this.blade = t.blade), (this.view = t.view), (this.viewProps = t.viewProps);
							const e = this.view.element;
							this.blade.value("positions").emitter.on("change", () => {
								B().forEach((t) => {
									e.classList.remove(F(void 0, U[t]));
								}),
									this.blade.get("positions").forEach((t) => {
										e.classList.add(F(void 0, U[t]));
									});
							}),
								this.viewProps.handleDispose(() => {
									V(e);
								});
						}
						get parent() {
							return this.parent_;
						}
					}
					const G = "http://www.w3.org/2000/svg";
					function W(t) {
						t.offsetHeight;
					}
					function j(t, e) {
						const n = t.style.transition;
						(t.style.transition = "none"), e(), (t.style.transition = n);
					}
					function X(t) {
						return void 0 !== t.ontouchstart;
					}
					function q() {
						return new Function("return this")();
					}
					function Y() {
						return o(q()).document;
					}
					function Z() {
						return "document" in q();
					}
					function K(t) {
						return Z() ? t.getContext("2d") : null;
					}
					const J = { check: '<path d="M2 8l4 4l8 -8"/>', dropdown: '<path d="M5 7h6l-3 3 z"/>', p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>' };
					function Q(t, e) {
						const n = t.createElementNS(G, "svg");
						return (n.innerHTML = J[e]), n;
					}
					function $(t, e, n) {
						t.insertBefore(e, t.children[n]);
					}
					function tt(t) {
						t.parentElement && t.parentElement.removeChild(t);
					}
					function et(t) {
						for (; t.children.length > 0; ) t.removeChild(t.children[0]);
					}
					function nt(t) {
						for (; t.childNodes.length > 0; ) t.removeChild(t.childNodes[0]);
					}
					function it(t) {
						return t.relatedTarget ? o(t.relatedTarget) : "explicitOriginalTarget" in t ? t.explicitOriginalTarget : null;
					}
					const rt = v("lbl");
					function at(t, e) {
						const n = t.createDocumentFragment();
						return (
							e
								.split("\n")
								.map((e) => t.createTextNode(e))
								.forEach((e, i) => {
									i > 0 && n.appendChild(t.createElement("br")), n.appendChild(e);
								}),
							n
						);
					}
					class st {
						constructor(t, e) {
							(this.element = t.createElement("div")), this.element.classList.add(rt()), e.viewProps.bindClassModifiers(this.element);
							const n = t.createElement("div");
							n.classList.add(rt("l")),
								y(e.props, "label", (e) => {
									l(e) ? this.element.classList.add(rt(void 0, "nol")) : (this.element.classList.remove(rt(void 0, "nol")), nt(n), n.appendChild(at(t, e)));
								}),
								this.element.appendChild(n),
								(this.labelElement = n);
							const i = t.createElement("div");
							i.classList.add(rt("v")), this.element.appendChild(i), (this.valueElement = i);
						}
					}
					class ot extends H {
						constructor(t, e) {
							const n = e.valueController.viewProps;
							super(Object.assign(Object.assign({}, e), { view: new st(t, { props: e.props, viewProps: n }), viewProps: n })), (this.props = e.props), (this.valueController = e.valueController), this.view.valueElement.appendChild(this.valueController.view.element);
						}
					}
					const lt = {
						id: "button",
						type: "blade",
						accept(t) {
							const e = k,
								n = N(t, { title: e.required.string, view: e.required.constant("button"), label: e.optional.string });
							return n ? { params: n } : null;
						},
						controller: (t) => new ot(t.document, { blade: t.blade, props: L.fromObject({ label: t.params.label }), valueController: new E(t.document, { props: L.fromObject({ title: t.params.title }), viewProps: t.viewProps }) }),
						api: (t) => (t.controller instanceof ot && t.controller.valueController instanceof E ? new p(t.controller) : null),
					};
					class ct extends H {
						constructor(t) {
							super(t), (this.value = t.value);
						}
					}
					function ut() {
						return new L({ positions: A([], { equals: c }) });
					}
					class ht extends L {
						constructor(t) {
							super(t);
						}
						static create(t) {
							const e = { completed: !0, expanded: t, expandedHeight: null, shouldFixHeight: !1, temporaryExpanded: null },
								n = L.createCore(e);
							return new ht(n);
						}
						get styleExpanded() {
							var t;
							return null !== (t = this.get("temporaryExpanded")) && void 0 !== t ? t : this.get("expanded");
						}
						get styleHeight() {
							if (!this.styleExpanded) return "0";
							const t = this.get("expandedHeight");
							return this.get("shouldFixHeight") && !l(t) ? `${t}px` : "auto";
						}
						bindExpandedClass(t, e) {
							y(this, "expanded", () => {
								this.styleExpanded ? t.classList.add(e) : t.classList.remove(e);
							});
						}
					}
					function dt(t, e) {
						let n = 0;
						return (
							j(e, () => {
								t.set("expandedHeight", null), t.set("temporaryExpanded", !0), W(e), (n = e.clientHeight), t.set("temporaryExpanded", null), W(e);
							}),
							n
						);
					}
					function pt(t, e) {
						e.style.height = t.styleHeight;
					}
					function ft(t, e) {
						t.value("expanded").emitter.on("beforechange", () => {
							t.set("completed", !1), l(t.get("expandedHeight")) && t.set("expandedHeight", dt(t, e)), t.set("shouldFixHeight", !0), W(e);
						}),
							t.emitter.on("change", () => {
								pt(t, e);
							}),
							pt(t, e),
							e.addEventListener("transitionend", (e) => {
								"height" === e.propertyName && (t.set("shouldFixHeight", !1), t.set("expandedHeight", null), t.set("completed", !0));
							});
					}
					class mt extends n {
						constructor(t, e) {
							super(t), (this.rackApi_ = e);
						}
					}
					function vt(t, e) {
						return t.addBlade(Object.assign(Object.assign({}, e), { view: "button" }));
					}
					function gt(t, e) {
						return t.addBlade(Object.assign(Object.assign({}, e), { view: "folder" }));
					}
					function bt(t, e) {
						const n = e || {};
						return t.addBlade(Object.assign(Object.assign({}, n), { view: "separator" }));
					}
					function xt(t, e) {
						return t.addBlade(Object.assign(Object.assign({}, e), { view: "tab" }));
					}
					class yt {
						constructor(t) {
							(this.emitter = new f()), (this.items_ = []), (this.cache_ = new Set()), (this.onSubListAdd_ = this.onSubListAdd_.bind(this)), (this.onSubListRemove_ = this.onSubListRemove_.bind(this)), (this.extract_ = t);
						}
						get items() {
							return this.items_;
						}
						allItems() {
							return Array.from(this.cache_);
						}
						find(t) {
							for (const e of this.allItems()) if (t(e)) return e;
							return null;
						}
						includes(t) {
							return this.cache_.has(t);
						}
						add(t, e) {
							if (this.includes(t)) throw h.shouldNeverHappen();
							const n = void 0 !== e ? e : this.items_.length;
							this.items_.splice(n, 0, t), this.cache_.add(t);
							const i = this.extract_(t);
							i &&
								(i.emitter.on("add", this.onSubListAdd_),
								i.emitter.on("remove", this.onSubListRemove_),
								i.allItems().forEach((t) => {
									this.cache_.add(t);
								})),
								this.emitter.emit("add", { index: n, item: t, root: this, target: this });
						}
						remove(t) {
							const e = this.items_.indexOf(t);
							if (e < 0) return;
							this.items_.splice(e, 1), this.cache_.delete(t);
							const n = this.extract_(t);
							n && (n.emitter.off("add", this.onSubListAdd_), n.emitter.off("remove", this.onSubListRemove_)), this.emitter.emit("remove", { index: e, item: t, root: this, target: this });
						}
						onSubListAdd_(t) {
							this.cache_.add(t.item), this.emitter.emit("add", { index: t.index, item: t.item, root: this, target: t.target });
						}
						onSubListRemove_(t) {
							this.cache_.delete(t.item), this.emitter.emit("remove", { index: t.index, item: t.item, root: this, target: t.target });
						}
					}
					class _t extends n {
						constructor(t) {
							super(t), (this.onBindingChange_ = this.onBindingChange_.bind(this)), (this.emitter_ = new f()), this.controller_.binding.emitter.on("change", this.onBindingChange_);
						}
						get label() {
							return this.controller_.props.get("label");
						}
						set label(t) {
							this.controller_.props.set("label", t);
						}
						on(t, e) {
							const n = e.bind(this);
							return (
								this.emitter_.on(t, (t) => {
									n(t.event);
								}),
								this
							);
						}
						refresh() {
							this.controller_.binding.read();
						}
						onBindingChange_(t) {
							const e = t.sender.target.read();
							this.emitter_.emit("change", { event: new r(this, o(e), this.controller_.binding.target.presetKey, t.options.last) });
						}
					}
					class wt extends ot {
						constructor(t, e) {
							super(t, e), (this.binding = e.binding);
						}
					}
					class Mt extends n {
						constructor(t) {
							super(t), (this.onBindingUpdate_ = this.onBindingUpdate_.bind(this)), (this.emitter_ = new f()), this.controller_.binding.emitter.on("update", this.onBindingUpdate_);
						}
						get label() {
							return this.controller_.props.get("label");
						}
						set label(t) {
							this.controller_.props.set("label", t);
						}
						on(t, e) {
							const n = e.bind(this);
							return (
								this.emitter_.on(t, (t) => {
									n(t.event);
								}),
								this
							);
						}
						refresh() {
							this.controller_.binding.read();
						}
						onBindingUpdate_(t) {
							const e = t.sender.target.read();
							this.emitter_.emit("update", { event: new a(this, o(e), this.controller_.binding.target.presetKey) });
						}
					}
					class St extends ot {
						constructor(t, e) {
							super(t, e),
								(this.binding = e.binding),
								this.viewProps.bindDisabled(this.binding.ticker),
								this.viewProps.handleDispose(() => {
									this.binding.dispose();
								});
						}
					}
					function Tt(t) {
						return t instanceof Pt ? t.apiSet_ : t instanceof mt ? t.rackApi_.apiSet_ : null;
					}
					function Et(t, e) {
						const n = t.find((t) => t.controller_ === e);
						if (!n) throw h.shouldNeverHappen();
						return n;
					}
					function Ct(t, e, n) {
						if (!d.isBindable(t)) throw h.notBindable();
						return new d(t, e, n);
					}
					class Pt extends n {
						constructor(t, e) {
							super(t), (this.onRackAdd_ = this.onRackAdd_.bind(this)), (this.onRackRemove_ = this.onRackRemove_.bind(this)), (this.onRackInputChange_ = this.onRackInputChange_.bind(this)), (this.onRackMonitorUpdate_ = this.onRackMonitorUpdate_.bind(this)), (this.emitter_ = new f()), (this.apiSet_ = new yt(Tt)), (this.pool_ = e);
							const n = this.controller_.rack;
							n.emitter.on("add", this.onRackAdd_),
								n.emitter.on("remove", this.onRackRemove_),
								n.emitter.on("inputchange", this.onRackInputChange_),
								n.emitter.on("monitorupdate", this.onRackMonitorUpdate_),
								n.children.forEach((t) => {
									this.setUpApi_(t);
								});
						}
						get children() {
							return this.controller_.rack.children.map((t) => Et(this.apiSet_, t));
						}
						addInput(t, e, n) {
							const i = n || {},
								r = this.controller_.view.element.ownerDocument,
								a = this.pool_.createInput(r, Ct(t, e, i.presetKey), i),
								s = new _t(a);
							return this.add(s, i.index);
						}
						addMonitor(t, e, n) {
							const i = n || {},
								r = this.controller_.view.element.ownerDocument,
								a = this.pool_.createMonitor(r, Ct(t, e), i),
								s = new Mt(a);
							return o(this.add(s, i.index));
						}
						addFolder(t) {
							return gt(this, t);
						}
						addButton(t) {
							return vt(this, t);
						}
						addSeparator(t) {
							return bt(this, t);
						}
						addTab(t) {
							return xt(this, t);
						}
						add(t, e) {
							this.controller_.rack.add(t.controller_, e);
							const n = this.apiSet_.find((e) => e.controller_ === t.controller_);
							return n && this.apiSet_.remove(n), this.apiSet_.add(t), t;
						}
						remove(t) {
							this.controller_.rack.remove(t.controller_);
						}
						addBlade(t) {
							const e = this.controller_.view.element.ownerDocument,
								n = this.pool_.createBlade(e, t),
								i = this.pool_.createBladeApi(n);
							return this.add(i, t.index);
						}
						on(t, e) {
							const n = e.bind(this);
							return (
								this.emitter_.on(t, (t) => {
									n(t.event);
								}),
								this
							);
						}
						setUpApi_(t) {
							this.apiSet_.find((e) => e.controller_ === t) || this.apiSet_.add(this.pool_.createBladeApi(t));
						}
						onRackAdd_(t) {
							this.setUpApi_(t.bladeController);
						}
						onRackRemove_(t) {
							if (t.isRoot) {
								const e = Et(this.apiSet_, t.bladeController);
								this.apiSet_.remove(e);
							}
						}
						onRackInputChange_(t) {
							const e = t.bladeController;
							if (e instanceof wt) {
								const n = Et(this.apiSet_, e),
									i = e.binding;
								this.emitter_.emit("change", { event: new r(n, o(i.target.read()), i.target.presetKey, t.options.last) });
							} else if (e instanceof ct) {
								const n = Et(this.apiSet_, e);
								this.emitter_.emit("change", { event: new r(n, e.value.rawValue, void 0, t.options.last) });
							}
						}
						onRackMonitorUpdate_(t) {
							if (!(t.bladeController instanceof St)) throw h.shouldNeverHappen();
							const e = Et(this.apiSet_, t.bladeController),
								n = t.bladeController.binding;
							this.emitter_.emit("update", { event: new a(e, o(n.target.read()), n.target.presetKey) });
						}
					}
					class At extends mt {
						constructor(t, e) {
							super(t, new Pt(t.rackController, e)),
								(this.emitter_ = new f()),
								this.controller_.foldable.value("expanded").emitter.on("change", (t) => {
									this.emitter_.emit("fold", { event: new s(this, t.sender.rawValue) });
								}),
								this.rackApi_.on("change", (t) => {
									this.emitter_.emit("change", { event: t });
								}),
								this.rackApi_.on("update", (t) => {
									this.emitter_.emit("update", { event: t });
								});
						}
						get expanded() {
							return this.controller_.foldable.get("expanded");
						}
						set expanded(t) {
							this.controller_.foldable.set("expanded", t);
						}
						get title() {
							return this.controller_.props.get("title");
						}
						set title(t) {
							this.controller_.props.set("title", t);
						}
						get children() {
							return this.rackApi_.children;
						}
						addInput(t, e, n) {
							return this.rackApi_.addInput(t, e, n);
						}
						addMonitor(t, e, n) {
							return this.rackApi_.addMonitor(t, e, n);
						}
						addFolder(t) {
							return this.rackApi_.addFolder(t);
						}
						addButton(t) {
							return this.rackApi_.addButton(t);
						}
						addSeparator(t) {
							return this.rackApi_.addSeparator(t);
						}
						addTab(t) {
							return this.rackApi_.addTab(t);
						}
						add(t, e) {
							return this.rackApi_.add(t, e);
						}
						remove(t) {
							this.rackApi_.remove(t);
						}
						addBlade(t) {
							return this.rackApi_.addBlade(t);
						}
						on(t, e) {
							const n = e.bind(this);
							return (
								this.emitter_.on(t, (t) => {
									n(t.event);
								}),
								this
							);
						}
					}
					class Lt extends H {
						constructor(t) {
							super({ blade: t.blade, view: t.view, viewProps: t.rackController.viewProps }), (this.rackController = t.rackController);
						}
					}
					class Rt {
						constructor(t, e) {
							const n = v(e.viewName);
							(this.element = t.createElement("div")), this.element.classList.add(n()), e.viewProps.bindClassModifiers(this.element);
						}
					}
					function Dt(t, e) {
						for (let n = 0; n < t.length; n++) {
							const i = t[n];
							if (i instanceof wt && i.binding === e) return i;
						}
						return null;
					}
					function Ot(t, e) {
						for (let n = 0; n < t.length; n++) {
							const i = t[n];
							if (i instanceof St && i.binding === e) return i;
						}
						return null;
					}
					function zt(t, e) {
						for (let n = 0; n < t.length; n++) {
							const i = t[n];
							if (i instanceof ct && i.value === e) return i;
						}
						return null;
					}
					function It(t) {
						return t instanceof Vt ? t.rack : t instanceof Lt ? t.rackController.rack : null;
					}
					function kt(t) {
						const e = It(t);
						return e ? e.bcSet_ : null;
					}
					class Nt {
						constructor(t) {
							var e;
							(this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this)),
								(this.onSetAdd_ = this.onSetAdd_.bind(this)),
								(this.onSetRemove_ = this.onSetRemove_.bind(this)),
								(this.onChildDispose_ = this.onChildDispose_.bind(this)),
								(this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this)),
								(this.onChildInputChange_ = this.onChildInputChange_.bind(this)),
								(this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this)),
								(this.onChildValueChange_ = this.onChildValueChange_.bind(this)),
								(this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this)),
								(this.onDescendantLayout_ = this.onDescendantLayout_.bind(this)),
								(this.onDescendantInputChange_ = this.onDescendantInputChange_.bind(this)),
								(this.onDescendantMonitorUpdate_ = this.onDescendantMonitorUpdate_.bind(this)),
								(this.emitter = new f()),
								(this.blade_ = null != t ? t : null),
								null === (e = this.blade_) || void 0 === e || e.value("positions").emitter.on("change", this.onBladePositionsChange_),
								(this.bcSet_ = new yt(kt)),
								this.bcSet_.emitter.on("add", this.onSetAdd_),
								this.bcSet_.emitter.on("remove", this.onSetRemove_);
						}
						get children() {
							return this.bcSet_.items;
						}
						add(t, e) {
							t.parent && t.parent.remove(t), (t.parent_ = this), this.bcSet_.add(t, e);
						}
						remove(t) {
							(t.parent_ = null), this.bcSet_.remove(t);
						}
						find(t) {
							return o(this.bcSet_.allItems().filter((e) => e instanceof t));
						}
						onSetAdd_(t) {
							this.updatePositions_();
							const e = t.target === t.root;
							if ((this.emitter.emit("add", { bladeController: t.item, index: t.index, isRoot: e, sender: this }), !e)) return;
							const n = t.item;
							if ((n.viewProps.emitter.on("change", this.onChildViewPropsChange_), n.blade.value("positions").emitter.on("change", this.onChildPositionsChange_), n.viewProps.handleDispose(this.onChildDispose_), n instanceof wt)) n.binding.emitter.on("change", this.onChildInputChange_);
							else if (n instanceof St) n.binding.emitter.on("update", this.onChildMonitorUpdate_);
							else if (n instanceof ct) n.value.emitter.on("change", this.onChildValueChange_);
							else {
								const t = It(n);
								if (t) {
									const e = t.emitter;
									e.on("layout", this.onDescendantLayout_), e.on("inputchange", this.onDescendantInputChange_), e.on("monitorupdate", this.onDescendantMonitorUpdate_);
								}
							}
						}
						onSetRemove_(t) {
							this.updatePositions_();
							const e = t.target === t.root;
							if ((this.emitter.emit("remove", { bladeController: t.item, isRoot: e, sender: this }), !e)) return;
							const n = t.item;
							if (n instanceof wt) n.binding.emitter.off("change", this.onChildInputChange_);
							else if (n instanceof St) n.binding.emitter.off("update", this.onChildMonitorUpdate_);
							else if (n instanceof ct) n.value.emitter.off("change", this.onChildValueChange_);
							else {
								const t = It(n);
								if (t) {
									const e = t.emitter;
									e.off("layout", this.onDescendantLayout_), e.off("inputchange", this.onDescendantInputChange_), e.off("monitorupdate", this.onDescendantMonitorUpdate_);
								}
							}
						}
						updatePositions_() {
							const t = this.bcSet_.items.filter((t) => !t.viewProps.get("hidden")),
								e = t[0],
								n = t[t.length - 1];
							this.bcSet_.items.forEach((t) => {
								const i = [];
								t === e && (i.push("first"), (this.blade_ && !this.blade_.get("positions").includes("veryfirst")) || i.push("veryfirst")), t === n && (i.push("last"), (this.blade_ && !this.blade_.get("positions").includes("verylast")) || i.push("verylast")), t.blade.set("positions", i);
							});
						}
						onChildPositionsChange_() {
							this.updatePositions_(), this.emitter.emit("layout", { sender: this });
						}
						onChildViewPropsChange_(t) {
							this.updatePositions_(), this.emitter.emit("layout", { sender: this });
						}
						onChildDispose_() {
							this.bcSet_.items
								.filter((t) => t.viewProps.get("disposed"))
								.forEach((t) => {
									this.bcSet_.remove(t);
								});
						}
						onChildInputChange_(t) {
							const e = Dt(this.find(wt), t.sender);
							if (!e) throw h.shouldNeverHappen();
							this.emitter.emit("inputchange", { bladeController: e, options: t.options, sender: this });
						}
						onChildMonitorUpdate_(t) {
							const e = Ot(this.find(St), t.sender);
							if (!e) throw h.shouldNeverHappen();
							this.emitter.emit("monitorupdate", { bladeController: e, sender: this });
						}
						onChildValueChange_(t) {
							const e = zt(this.find(ct), t.sender);
							if (!e) throw h.shouldNeverHappen();
							this.emitter.emit("inputchange", { bladeController: e, options: t.options, sender: this });
						}
						onDescendantLayout_(t) {
							this.updatePositions_(), this.emitter.emit("layout", { sender: this });
						}
						onDescendantInputChange_(t) {
							this.emitter.emit("inputchange", { bladeController: t.bladeController, options: t.options, sender: this });
						}
						onDescendantMonitorUpdate_(t) {
							this.emitter.emit("monitorupdate", { bladeController: t.bladeController, sender: this });
						}
						onBladePositionsChange_() {
							this.updatePositions_();
						}
					}
					class Vt extends H {
						constructor(t, e) {
							super(Object.assign(Object.assign({}, e), { view: new Rt(t, { viewName: "brk", viewProps: e.viewProps }) })), (this.onRackAdd_ = this.onRackAdd_.bind(this)), (this.onRackRemove_ = this.onRackRemove_.bind(this));
							const n = new Nt(e.root ? void 0 : e.blade);
							n.emitter.on("add", this.onRackAdd_),
								n.emitter.on("remove", this.onRackRemove_),
								(this.rack = n),
								this.viewProps.handleDispose(() => {
									for (let t = this.rack.children.length - 1; t >= 0; t--) this.rack.children[t].viewProps.set("disposed", !0);
								});
						}
						onRackAdd_(t) {
							t.isRoot && $(this.view.element, t.bladeController.view.element, t.index);
						}
						onRackRemove_(t) {
							t.isRoot && tt(t.bladeController.view.element);
						}
					}
					const Bt = v("cnt");
					class Ft {
						constructor(t, e) {
							(this.className_ = v(e.viewName || "fld")), (this.element = t.createElement("div")), this.element.classList.add(this.className_(), Bt()), e.viewProps.bindClassModifiers(this.element), (this.foldable_ = e.foldable), this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded")), y(this.foldable_, "completed", w(this.element, this.className_(void 0, "cpl")));
							const n = t.createElement("button");
							n.classList.add(this.className_("b")),
								y(e.props, "title", (t) => {
									l(t) ? this.element.classList.add(this.className_(void 0, "not")) : this.element.classList.remove(this.className_(void 0, "not"));
								}),
								e.viewProps.bindDisabled(n),
								this.element.appendChild(n),
								(this.buttonElement = n);
							const i = t.createElement("div");
							i.classList.add(this.className_("t")), M(e.props.value("title"), i), this.buttonElement.appendChild(i), (this.titleElement = i);
							const r = t.createElement("div");
							r.classList.add(this.className_("m")), this.buttonElement.appendChild(r);
							const a = e.containerElement;
							a.classList.add(this.className_("c")), this.element.appendChild(a), (this.containerElement = a);
						}
					}
					class Ut extends Lt {
						constructor(t, e) {
							var n;
							const i = ht.create(null === (n = e.expanded) || void 0 === n || n),
								r = new Vt(t, { blade: e.blade, root: e.root, viewProps: e.viewProps });
							super(Object.assign(Object.assign({}, e), { rackController: r, view: new Ft(t, { containerElement: r.view.element, foldable: i, props: e.props, viewName: e.root ? "rot" : void 0, viewProps: e.viewProps }) })), (this.onTitleClick_ = this.onTitleClick_.bind(this)), (this.props = e.props), (this.foldable = i), ft(this.foldable, this.view.containerElement), this.view.buttonElement.addEventListener("click", this.onTitleClick_);
						}
						get document() {
							return this.view.element.ownerDocument;
						}
						onTitleClick_() {
							this.foldable.set("expanded", !this.foldable.get("expanded"));
						}
					}
					const Ht = {
						id: "folder",
						type: "blade",
						accept(t) {
							const e = k,
								n = N(t, { title: e.required.string, view: e.required.constant("folder"), expanded: e.optional.boolean });
							return n ? { params: n } : null;
						},
						controller: (t) => new Ut(t.document, { blade: t.blade, expanded: t.params.expanded, props: L.fromObject({ title: t.params.title }), viewProps: t.viewProps }),
						api: (t) => (t.controller instanceof Ut ? new At(t.controller, t.pool) : null),
					};
					class Gt extends ct {
						constructor(t, e) {
							const n = e.valueController.viewProps;
							super(Object.assign(Object.assign({}, e), { value: e.valueController.value, view: new st(t, { props: e.props, viewProps: n }), viewProps: n })), (this.props = e.props), (this.valueController = e.valueController), this.view.valueElement.appendChild(this.valueController.view.element);
						}
					}
					class Wt extends n {}
					const jt = v("spr");
					class Xt {
						constructor(t, e) {
							(this.element = t.createElement("div")), this.element.classList.add(jt()), e.viewProps.bindClassModifiers(this.element);
							const n = t.createElement("hr");
							n.classList.add(jt("r")), this.element.appendChild(n);
						}
					}
					class qt extends H {
						constructor(t, e) {
							super(Object.assign(Object.assign({}, e), { view: new Xt(t, { viewProps: e.viewProps }) }));
						}
					}
					const Yt = {
							id: "separator",
							type: "blade",
							accept(t) {
								const e = N(t, { view: k.required.constant("separator") });
								return e ? { params: e } : null;
							},
							controller: (t) => new qt(t.document, { blade: t.blade, viewProps: t.viewProps }),
							api: (t) => (t.controller instanceof qt ? new Wt(t.controller) : null),
						},
						Zt = v("");
					function Kt(t, e) {
						return w(t, Zt(void 0, e));
					}
					class Jt extends L {
						constructor(t) {
							super(t);
						}
						static create(t) {
							var e, n;
							const i = null != t ? t : {},
								r = { disabled: null !== (e = i.disabled) && void 0 !== e && e, disposed: !1, hidden: null !== (n = i.hidden) && void 0 !== n && n },
								a = L.createCore(r);
							return new Jt(a);
						}
						bindClassModifiers(t) {
							y(this, "disabled", Kt(t, "disabled")), y(this, "hidden", Kt(t, "hidden"));
						}
						bindDisabled(t) {
							y(this, "disabled", (e) => {
								t.disabled = e;
							});
						}
						bindTabIndex(t) {
							y(this, "disabled", (e) => {
								t.tabIndex = e ? -1 : 0;
							});
						}
						handleDispose(t) {
							this.value("disposed").emitter.on("change", (e) => {
								e && t();
							});
						}
					}
					const Qt = v("tbi");
					class $t {
						constructor(t, e) {
							(this.element = t.createElement("div")),
								this.element.classList.add(Qt()),
								e.viewProps.bindClassModifiers(this.element),
								y(e.props, "selected", (t) => {
									t ? this.element.classList.add(Qt(void 0, "sel")) : this.element.classList.remove(Qt(void 0, "sel"));
								});
							const n = t.createElement("button");
							n.classList.add(Qt("b")), e.viewProps.bindDisabled(n), this.element.appendChild(n), (this.buttonElement = n);
							const i = t.createElement("div");
							i.classList.add(Qt("t")), M(e.props.value("title"), i), this.buttonElement.appendChild(i), (this.titleElement = i);
						}
					}
					class te {
						constructor(t, e) {
							(this.emitter = new f()), (this.onClick_ = this.onClick_.bind(this)), (this.props = e.props), (this.viewProps = e.viewProps), (this.view = new $t(t, { props: e.props, viewProps: e.viewProps })), this.view.buttonElement.addEventListener("click", this.onClick_);
						}
						onClick_() {
							this.emitter.emit("click", { sender: this });
						}
					}
					class ee {
						constructor(t, e) {
							(this.onItemClick_ = this.onItemClick_.bind(this)),
								(this.ic_ = new te(t, { props: e.itemProps, viewProps: Jt.create() })),
								this.ic_.emitter.on("click", this.onItemClick_),
								(this.cc_ = new Vt(t, { blade: ut(), viewProps: Jt.create() })),
								(this.props = e.props),
								y(this.props, "selected", (t) => {
									this.itemController.props.set("selected", t), this.contentController.viewProps.set("hidden", !t);
								});
						}
						get itemController() {
							return this.ic_;
						}
						get contentController() {
							return this.cc_;
						}
						onItemClick_() {
							this.props.set("selected", !0);
						}
					}
					class ne {
						constructor(t, e) {
							(this.controller_ = t), (this.rackApi_ = e);
						}
						get title() {
							var t;
							return null !== (t = this.controller_.itemController.props.get("title")) && void 0 !== t ? t : "";
						}
						set title(t) {
							this.controller_.itemController.props.set("title", t);
						}
						get selected() {
							return this.controller_.props.get("selected");
						}
						set selected(t) {
							this.controller_.props.set("selected", t);
						}
						get children() {
							return this.rackApi_.children;
						}
						addButton(t) {
							return this.rackApi_.addButton(t);
						}
						addFolder(t) {
							return this.rackApi_.addFolder(t);
						}
						addSeparator(t) {
							return this.rackApi_.addSeparator(t);
						}
						addTab(t) {
							return this.rackApi_.addTab(t);
						}
						add(t, e) {
							this.rackApi_.add(t, e);
						}
						remove(t) {
							this.rackApi_.remove(t);
						}
						addInput(t, e, n) {
							return this.rackApi_.addInput(t, e, n);
						}
						addMonitor(t, e, n) {
							return this.rackApi_.addMonitor(t, e, n);
						}
						addBlade(t) {
							return this.rackApi_.addBlade(t);
						}
					}
					class ie extends mt {
						constructor(t, e) {
							super(t, new Pt(t.rackController, e)),
								(this.onPageAdd_ = this.onPageAdd_.bind(this)),
								(this.onPageRemove_ = this.onPageRemove_.bind(this)),
								(this.emitter_ = new f()),
								(this.pageApiMap_ = new Map()),
								this.rackApi_.on("change", (t) => {
									this.emitter_.emit("change", { event: t });
								}),
								this.rackApi_.on("update", (t) => {
									this.emitter_.emit("update", { event: t });
								}),
								this.controller_.pageSet.emitter.on("add", this.onPageAdd_),
								this.controller_.pageSet.emitter.on("remove", this.onPageRemove_),
								this.controller_.pageSet.items.forEach((t) => {
									this.setUpPageApi_(t);
								});
						}
						get pages() {
							return this.controller_.pageSet.items.map((t) => {
								const e = this.pageApiMap_.get(t);
								if (!e) throw h.shouldNeverHappen();
								return e;
							});
						}
						addPage(t) {
							const e = this.controller_.view.element.ownerDocument,
								n = new ee(e, { itemProps: L.fromObject({ selected: !1, title: t.title }), props: L.fromObject({ selected: !1 }) });
							this.controller_.add(n, t.index);
							const i = this.pageApiMap_.get(n);
							if (!i) throw h.shouldNeverHappen();
							return i;
						}
						removePage(t) {
							this.controller_.remove(t);
						}
						on(t, e) {
							const n = e.bind(this);
							return (
								this.emitter_.on(t, (t) => {
									n(t.event);
								}),
								this
							);
						}
						setUpPageApi_(t) {
							const e = this.rackApi_.apiSet_.find((e) => e.controller_ === t.contentController);
							if (!e) throw h.shouldNeverHappen();
							const n = new ne(t, e);
							this.pageApiMap_.set(t, n);
						}
						onPageAdd_(t) {
							this.setUpPageApi_(t.item);
						}
						onPageRemove_(t) {
							if (!this.pageApiMap_.get(t.item)) throw h.shouldNeverHappen();
							this.pageApiMap_.delete(t.item);
						}
					}
					const re = v("tab");
					class ae {
						constructor(t, e) {
							(this.element = t.createElement("div")), this.element.classList.add(re(), Bt()), e.viewProps.bindClassModifiers(this.element), x(e.empty, w(this.element, re(void 0, "nop")));
							const n = t.createElement("div");
							n.classList.add(re("i")), this.element.appendChild(n), (this.itemsElement = n);
							const i = e.contentsElement;
							i.classList.add(re("c")), this.element.appendChild(i), (this.contentsElement = i);
						}
					}
					class se extends Lt {
						constructor(t, e) {
							const n = new Vt(t, { blade: e.blade, viewProps: e.viewProps }),
								i = A(!0);
							super({ blade: e.blade, rackController: n, view: new ae(t, { contentsElement: n.view.element, empty: i, viewProps: e.viewProps }) }),
								(this.onPageAdd_ = this.onPageAdd_.bind(this)),
								(this.onPageRemove_ = this.onPageRemove_.bind(this)),
								(this.onPageSelectedChange_ = this.onPageSelectedChange_.bind(this)),
								(this.pageSet_ = new yt(() => null)),
								this.pageSet_.emitter.on("add", this.onPageAdd_),
								this.pageSet_.emitter.on("remove", this.onPageRemove_),
								(this.empty_ = i),
								this.applyPages_();
						}
						get pageSet() {
							return this.pageSet_;
						}
						add(t, e) {
							this.pageSet_.add(t, null != e ? e : this.pageSet_.items.length);
						}
						remove(t) {
							this.pageSet_.remove(this.pageSet_.items[t]);
						}
						applyPages_() {
							this.keepSelection_(), (this.empty_.rawValue = 0 === this.pageSet_.items.length);
						}
						onPageAdd_(t) {
							const e = t.item;
							$(this.view.itemsElement, e.itemController.view.element, t.index), this.rackController.rack.add(e.contentController, t.index), e.props.value("selected").emitter.on("change", this.onPageSelectedChange_), this.applyPages_();
						}
						onPageRemove_(t) {
							const e = t.item;
							tt(e.itemController.view.element), this.rackController.rack.remove(e.contentController), e.props.value("selected").emitter.off("change", this.onPageSelectedChange_), this.applyPages_();
						}
						keepSelection_() {
							if (0 === this.pageSet_.items.length) return;
							const t = this.pageSet_.items.findIndex((t) => t.props.get("selected"));
							t < 0
								? this.pageSet_.items.forEach((t, e) => {
										t.props.set("selected", 0 === e);
								  })
								: this.pageSet_.items.forEach((e, n) => {
										e.props.set("selected", n === t);
								  });
						}
						onPageSelectedChange_(t) {
							if (t.rawValue) {
								const e = this.pageSet_.items.findIndex((e) => e.props.value("selected") === t.sender);
								this.pageSet_.items.forEach((t, n) => {
									t.props.set("selected", n === e);
								});
							} else this.keepSelection_();
						}
					}
					const oe = {
						id: "tab",
						type: "blade",
						accept(t) {
							const e = k,
								n = N(t, { pages: e.required.array(e.required.object({ title: e.required.string })), view: e.required.constant("tab") });
							return n && 0 !== n.pages.length ? { params: n } : null;
						},
						controller(t) {
							const e = new se(t.document, { blade: t.blade, viewProps: t.viewProps });
							return (
								t.params.pages.forEach((n) => {
									const i = new ee(t.document, { itemProps: L.fromObject({ selected: !1, title: n.title }), props: L.fromObject({ selected: !1 }) });
									e.add(i);
								}),
								e
							);
						},
						api: (t) => (t.controller instanceof se ? new ie(t.controller, t.pool) : null),
					};
					function le(t, e) {
						const n = t.accept(e.params);
						if (!n) return null;
						const i = k.optional.boolean(e.params.disabled).value,
							r = k.optional.boolean(e.params.hidden).value;
						return t.controller({ blade: ut(), document: e.document, params: o(Object.assign(Object.assign({}, n.params), { disabled: i, hidden: r })), viewProps: Jt.create({ disabled: i, hidden: r }) });
					}
					class ce {
						constructor() {
							(this.disabled = !1), (this.emitter = new f());
						}
						dispose() {}
						tick() {
							this.disabled || this.emitter.emit("tick", { sender: this });
						}
					}
					class ue {
						constructor(t, e) {
							(this.disabled_ = !1), (this.timerId_ = null), (this.onTick_ = this.onTick_.bind(this)), (this.doc_ = t), (this.emitter = new f()), (this.interval_ = e), this.setTimer_();
						}
						get disabled() {
							return this.disabled_;
						}
						set disabled(t) {
							(this.disabled_ = t), this.disabled_ ? this.clearTimer_() : this.setTimer_();
						}
						dispose() {
							this.clearTimer_();
						}
						clearTimer_() {
							if (null === this.timerId_) return;
							const t = this.doc_.defaultView;
							t && t.clearInterval(this.timerId_), (this.timerId_ = null);
						}
						setTimer_() {
							if ((this.clearTimer_(), this.interval_ <= 0)) return;
							const t = this.doc_.defaultView;
							t && (this.timerId_ = t.setInterval(this.onTick_, this.interval_));
						}
						onTick_() {
							this.disabled_ || this.emitter.emit("tick", { sender: this });
						}
					}
					class he {
						constructor(t) {
							this.constraints = t;
						}
						constrain(t) {
							return this.constraints.reduce((t, e) => e.constrain(t), t);
						}
					}
					function de(t, e) {
						if (t instanceof e) return t;
						if (t instanceof he) {
							const n = t.constraints.reduce((t, n) => t || (n instanceof e ? n : null), null);
							if (n) return n;
						}
						return null;
					}
					class pe {
						constructor(t) {
							this.options = t;
						}
						constrain(t) {
							const e = this.options;
							return 0 === e.length || e.filter((e) => e.value === t).length > 0 ? t : e[0].value;
						}
					}
					class fe {
						constructor(t) {
							(this.maxValue = t.max), (this.minValue = t.min);
						}
						constrain(t) {
							let e = t;
							return l(this.minValue) || (e = Math.max(e, this.minValue)), l(this.maxValue) || (e = Math.min(e, this.maxValue)), e;
						}
					}
					class me {
						constructor(t) {
							this.step = t;
						}
						constrain(t) {
							return (t < 0 ? -Math.round(-t / this.step) : Math.round(t / this.step)) * this.step;
						}
					}
					const ve = v("lst");
					class ge {
						constructor(t, e) {
							(this.onValueChange_ = this.onValueChange_.bind(this)), (this.props_ = e.props), (this.element = t.createElement("div")), this.element.classList.add(ve()), e.viewProps.bindClassModifiers(this.element);
							const n = t.createElement("select");
							n.classList.add(ve("s")),
								y(this.props_, "options", (e) => {
									et(n),
										e.forEach((e, i) => {
											const r = t.createElement("option");
											(r.dataset.index = String(i)), (r.textContent = e.text), (r.value = String(e.value)), n.appendChild(r);
										});
								}),
								e.viewProps.bindDisabled(n),
								this.element.appendChild(n),
								(this.selectElement = n);
							const i = t.createElement("div");
							i.classList.add(ve("m")), i.appendChild(Q(t, "dropdown")), this.element.appendChild(i), e.value.emitter.on("change", this.onValueChange_), (this.value_ = e.value), this.update_();
						}
						update_() {
							this.selectElement.value = String(this.value_.rawValue);
						}
						onValueChange_() {
							this.update_();
						}
					}
					class be {
						constructor(t, e) {
							(this.onSelectChange_ = this.onSelectChange_.bind(this)), (this.props = e.props), (this.value = e.value), (this.viewProps = e.viewProps), (this.view = new ge(t, { props: this.props, value: this.value, viewProps: this.viewProps })), this.view.selectElement.addEventListener("change", this.onSelectChange_);
						}
						onSelectChange_(t) {
							const e = o(t.currentTarget).selectedOptions.item(0);
							if (!e) return;
							const n = Number(e.dataset.index);
							this.value.rawValue = this.props.get("options")[n].value;
						}
					}
					const xe = v("pop");
					class ye {
						constructor(t, e) {
							(this.element = t.createElement("div")), this.element.classList.add(xe()), e.viewProps.bindClassModifiers(this.element), x(e.shows, w(this.element, xe(void 0, "v")));
						}
					}
					class _e {
						constructor(t, e) {
							(this.shows = A(!1)), (this.viewProps = e.viewProps), (this.view = new ye(t, { shows: this.shows, viewProps: this.viewProps }));
						}
					}
					const we = v("txt");
					class Me {
						constructor(t, e) {
							(this.onChange_ = this.onChange_.bind(this)), (this.element = t.createElement("div")), this.element.classList.add(we()), e.viewProps.bindClassModifiers(this.element), (this.props_ = e.props), this.props_.emitter.on("change", this.onChange_);
							const n = t.createElement("input");
							n.classList.add(we("i")), (n.type = "text"), e.viewProps.bindDisabled(n), this.element.appendChild(n), (this.inputElement = n), e.value.emitter.on("change", this.onChange_), (this.value_ = e.value), this.refresh();
						}
						refresh() {
							const t = this.props_.get("formatter");
							this.inputElement.value = t(this.value_.rawValue);
						}
						onChange_() {
							this.refresh();
						}
					}
					class Se {
						constructor(t, e) {
							(this.onInputChange_ = this.onInputChange_.bind(this)), (this.parser_ = e.parser), (this.props = e.props), (this.value = e.value), (this.viewProps = e.viewProps), (this.view = new Me(t, { props: e.props, value: this.value, viewProps: this.viewProps })), this.view.inputElement.addEventListener("change", this.onInputChange_);
						}
						onInputChange_(t) {
							const e = o(t.currentTarget).value,
								n = this.parser_(e);
							l(n) || (this.value.rawValue = n), this.view.refresh();
						}
					}
					function Te(t) {
						return String(t);
					}
					function Ee(t) {
						return "false" !== t && !!t;
					}
					function Ce(t) {
						return Te(t);
					}
					class Pe {
						constructor(t) {
							this.text = t;
						}
						evaluate() {
							return Number(this.text);
						}
						toString() {
							return this.text;
						}
					}
					const Ae = { "**": (t, e) => Math.pow(t, e), "*": (t, e) => t * e, "/": (t, e) => t / e, "%": (t, e) => t % e, "+": (t, e) => t + e, "-": (t, e) => t - e, "<<": (t, e) => t << e, ">>": (t, e) => t >> e, ">>>": (t, e) => t >>> e, "&": (t, e) => t & e, "^": (t, e) => t ^ e, "|": (t, e) => t | e };
					class Le {
						constructor(t, e, n) {
							(this.left = e), (this.operator = t), (this.right = n);
						}
						evaluate() {
							const t = Ae[this.operator];
							if (!t) throw new Error(`unexpected binary operator: '${this.operator}`);
							return t(this.left.evaluate(), this.right.evaluate());
						}
						toString() {
							return ["b(", this.left.toString(), this.operator, this.right.toString(), ")"].join(" ");
						}
					}
					const Re = { "+": (t) => t, "-": (t) => -t, "~": (t) => ~t };
					class De {
						constructor(t, e) {
							(this.operator = t), (this.expression = e);
						}
						evaluate() {
							const t = Re[this.operator];
							if (!t) throw new Error(`unexpected unary operator: '${this.operator}`);
							return t(this.expression.evaluate());
						}
						toString() {
							return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
						}
					}
					function Oe(t) {
						return (e, n) => {
							for (let i = 0; i < t.length; i++) {
								const r = t[i](e, n);
								if ("" !== r) return r;
							}
							return "";
						};
					}
					function ze(t, e) {
						var n;
						const i = t.substr(e).match(/^\s+/);
						return null !== (n = i && i[0]) && void 0 !== n ? n : "";
					}
					function Ie(t, e) {
						const n = t.substr(e, 1);
						return n.match(/^[1-9]$/) ? n : "";
					}
					function ke(t, e) {
						var n;
						const i = t.substr(e).match(/^[0-9]+/);
						return null !== (n = i && i[0]) && void 0 !== n ? n : "";
					}
					function Ne(t, e) {
						const n = ke(t, e);
						if ("" !== n) return n;
						const i = t.substr(e, 1);
						if ("-" !== i && "+" !== i) return "";
						const r = ke(t, (e += 1));
						return "" === r ? "" : i + r;
					}
					function Ve(t, e) {
						const n = t.substr(e, 1);
						if (((e += 1), "e" !== n.toLowerCase())) return "";
						const i = Ne(t, e);
						return "" === i ? "" : n + i;
					}
					function Be(t, e) {
						const n = t.substr(e, 1);
						if ("0" === n) return n;
						const i = Ie(t, e);
						return (e += i.length), "" === i ? "" : i + ke(t, e);
					}
					function Fe(t, e) {
						const n = Be(t, e);
						if (((e += n.length), "" === n)) return "";
						const i = t.substr(e, 1);
						if (((e += i.length), "." !== i)) return "";
						const r = ke(t, e);
						return n + i + r + Ve(t, (e += r.length));
					}
					function Ue(t, e) {
						const n = t.substr(e, 1);
						if (((e += n.length), "." !== n)) return "";
						const i = ke(t, e);
						return (e += i.length), "" === i ? "" : n + i + Ve(t, e);
					}
					function He(t, e) {
						const n = Be(t, e);
						return (e += n.length), "" === n ? "" : n + Ve(t, e);
					}
					const Ge = Oe([Fe, Ue, He]);
					function We(t, e) {
						var n;
						const i = t.substr(e).match(/^[01]+/);
						return null !== (n = i && i[0]) && void 0 !== n ? n : "";
					}
					function je(t, e) {
						const n = t.substr(e, 2);
						if (((e += n.length), "0b" !== n.toLowerCase())) return "";
						const i = We(t, e);
						return "" === i ? "" : n + i;
					}
					function Xe(t, e) {
						var n;
						const i = t.substr(e).match(/^[0-7]+/);
						return null !== (n = i && i[0]) && void 0 !== n ? n : "";
					}
					function qe(t, e) {
						const n = t.substr(e, 2);
						if (((e += n.length), "0o" !== n.toLowerCase())) return "";
						const i = Xe(t, e);
						return "" === i ? "" : n + i;
					}
					function Ye(t, e) {
						var n;
						const i = t.substr(e).match(/^[0-9a-f]+/i);
						return null !== (n = i && i[0]) && void 0 !== n ? n : "";
					}
					function Ze(t, e) {
						const n = t.substr(e, 2);
						if (((e += n.length), "0x" !== n.toLowerCase())) return "";
						const i = Ye(t, e);
						return "" === i ? "" : n + i;
					}
					const Ke = Oe([je, qe, Ze]),
						Je = Oe([Ke, Ge]);
					function Qe(t, e) {
						const n = Je(t, e);
						return (e += n.length), "" === n ? null : { evaluable: new Pe(n), cursor: e };
					}
					function $e(t, e) {
						const n = t.substr(e, 1);
						if (((e += n.length), "(" !== n)) return null;
						const i = sn(t, e);
						if (!i) return null;
						(e = i.cursor), (e += ze(t, e).length);
						const r = t.substr(e, 1);
						return (e += r.length), ")" !== r ? null : { evaluable: i.evaluable, cursor: e };
					}
					function tn(t, e) {
						return Qe(t, e) || $e(t, e);
					}
					function en(t, e) {
						const n = tn(t, e);
						if (n) return n;
						const i = t.substr(e, 1);
						if (((e += i.length), "+" !== i && "-" !== i && "~" !== i)) return null;
						const r = en(t, e);
						return r ? { cursor: (e = r.cursor), evaluable: new De(i, r.evaluable) } : null;
					}
					function nn(t, e, n) {
						n += ze(e, n).length;
						const i = t.filter((t) => e.startsWith(t, n))[0];
						return i ? ((n += i.length), { cursor: (n += ze(e, n).length), operator: i }) : null;
					}
					function rn(t, e) {
						return (n, i) => {
							const r = t(n, i);
							if (!r) return null;
							i = r.cursor;
							let a = r.evaluable;
							for (;;) {
								const r = nn(e, n, i);
								if (!r) break;
								i = r.cursor;
								const s = t(n, i);
								if (!s) return null;
								(i = s.cursor), (a = new Le(r.operator, a, s.evaluable));
							}
							return a ? { cursor: i, evaluable: a } : null;
						};
					}
					const an = [["**"], ["*", "/", "%"], ["+", "-"], ["<<", ">>>", ">>"], ["&"], ["^"], ["|"]].reduce((t, e) => rn(t, e), en);
					function sn(t, e) {
						return (e += ze(t, e).length), an(t, e);
					}
					function on(t) {
						const e = sn(t, 0);
						return e ? (e.cursor + ze(t, e.cursor).length !== t.length ? null : e.evaluable) : null;
					}
					function ln(t) {
						var e;
						const n = on(t);
						return null !== (e = null == n ? void 0 : n.evaluate()) && void 0 !== e ? e : null;
					}
					function cn(t) {
						if ("number" == typeof t) return t;
						if ("string" == typeof t) {
							const e = ln(t);
							if (!l(e)) return e;
						}
						return 0;
					}
					function un(t) {
						return String(t);
					}
					function hn(t) {
						return (e) => e.toFixed(Math.max(Math.min(t, 20), 0));
					}
					const dn = hn(0);
					function pn(t) {
						return dn(t) + "%";
					}
					function fn(t) {
						return String(t);
					}
					function mn(t) {
						return t;
					}
					function vn(t, e) {
						for (; t.length < e; ) t.push(void 0);
					}
					function gn(t) {
						const e = [];
						return vn(e, t), A(e);
					}
					function bn(t) {
						const e = t.indexOf(void 0);
						return o(e < 0 ? t : t.slice(0, e));
					}
					function xn(t, e) {
						const n = [...bn(t), e];
						return n.length > t.length ? n.splice(0, n.length - t.length) : vn(n, t.length), n;
					}
					function yn({ primary: t, secondary: e, forward: n, backward: i }) {
						let r = !1;
						function a(t) {
							r || ((r = !0), t(), (r = !1));
						}
						t.emitter.on("change", (i) => {
							a(() => {
								e.setRawValue(n(t, e), i.options);
							});
						}),
							e.emitter.on("change", (r) => {
								a(() => {
									t.setRawValue(i(t, e), r.options);
								}),
									a(() => {
										e.setRawValue(n(t, e), r.options);
									});
							}),
							a(() => {
								e.setRawValue(n(t, e), { forceEmit: !1, last: !0 });
							});
					}
					function _n(t, e) {
						const n = t * (e.altKey ? 0.1 : 1) * (e.shiftKey ? 10 : 1);
						return e.upKey ? +n : e.downKey ? -n : 0;
					}
					function wn(t) {
						return { altKey: t.altKey, downKey: "ArrowDown" === t.key, shiftKey: t.shiftKey, upKey: "ArrowUp" === t.key };
					}
					function Mn(t) {
						return { altKey: t.altKey, downKey: "ArrowLeft" === t.key, shiftKey: t.shiftKey, upKey: "ArrowRight" === t.key };
					}
					function Sn(t) {
						return "ArrowUp" === t || "ArrowDown" === t;
					}
					function Tn(t) {
						return Sn(t) || "ArrowLeft" === t || "ArrowRight" === t;
					}
					function En(t, e) {
						const n = e.ownerDocument.defaultView,
							i = e.getBoundingClientRect();
						return { x: t.pageX - (((n && n.scrollX) || 0) + i.left), y: t.pageY - (((n && n.scrollY) || 0) + i.top) };
					}
					class Cn {
						constructor(t) {
							(this.lastTouch_ = null),
								(this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this)),
								(this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this)),
								(this.onMouseDown_ = this.onMouseDown_.bind(this)),
								(this.onTouchEnd_ = this.onTouchEnd_.bind(this)),
								(this.onTouchMove_ = this.onTouchMove_.bind(this)),
								(this.onTouchStart_ = this.onTouchStart_.bind(this)),
								(this.elem_ = t),
								(this.emitter = new f()),
								t.addEventListener("touchstart", this.onTouchStart_),
								t.addEventListener("touchmove", this.onTouchMove_),
								t.addEventListener("touchend", this.onTouchEnd_),
								t.addEventListener("mousedown", this.onMouseDown_);
						}
						computePosition_(t) {
							const e = this.elem_.getBoundingClientRect();
							return { bounds: { width: e.width, height: e.height }, point: t ? { x: t.x, y: t.y } : null };
						}
						onMouseDown_(t) {
							var e;
							t.preventDefault(), null === (e = t.currentTarget) || void 0 === e || e.focus();
							const n = this.elem_.ownerDocument;
							n.addEventListener("mousemove", this.onDocumentMouseMove_), n.addEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("down", { altKey: t.altKey, data: this.computePosition_(En(t, this.elem_)), sender: this, shiftKey: t.shiftKey });
						}
						onDocumentMouseMove_(t) {
							this.emitter.emit("move", { altKey: t.altKey, data: this.computePosition_(En(t, this.elem_)), sender: this, shiftKey: t.shiftKey });
						}
						onDocumentMouseUp_(t) {
							const e = this.elem_.ownerDocument;
							e.removeEventListener("mousemove", this.onDocumentMouseMove_), e.removeEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("up", { altKey: t.altKey, data: this.computePosition_(En(t, this.elem_)), sender: this, shiftKey: t.shiftKey });
						}
						onTouchStart_(t) {
							t.preventDefault();
							const e = t.targetTouches.item(0),
								n = this.elem_.getBoundingClientRect();
							this.emitter.emit("down", { altKey: t.altKey, data: this.computePosition_(e ? { x: e.clientX - n.left, y: e.clientY - n.top } : void 0), sender: this, shiftKey: t.shiftKey }), (this.lastTouch_ = e);
						}
						onTouchMove_(t) {
							const e = t.targetTouches.item(0),
								n = this.elem_.getBoundingClientRect();
							this.emitter.emit("move", { altKey: t.altKey, data: this.computePosition_(e ? { x: e.clientX - n.left, y: e.clientY - n.top } : void 0), sender: this, shiftKey: t.shiftKey }), (this.lastTouch_ = e);
						}
						onTouchEnd_(t) {
							var e;
							const n = null !== (e = t.targetTouches.item(0)) && void 0 !== e ? e : this.lastTouch_,
								i = this.elem_.getBoundingClientRect();
							this.emitter.emit("up", { altKey: t.altKey, data: this.computePosition_(n ? { x: n.clientX - i.left, y: n.clientY - i.top } : void 0), sender: this, shiftKey: t.shiftKey });
						}
					}
					function Pn(t, e, n, i, r) {
						return i + ((t - e) / (n - e)) * (r - i);
					}
					function An(t) {
						return String(t.toFixed(10)).split(".")[1].replace(/0+$/, "").length;
					}
					function Ln(t, e, n) {
						return Math.min(Math.max(t, e), n);
					}
					function Rn(t, e) {
						return ((t % e) + e) % e;
					}
					const Dn = v("txt");
					class On {
						constructor(t, e) {
							(this.onChange_ = this.onChange_.bind(this)), (this.props_ = e.props), this.props_.emitter.on("change", this.onChange_), (this.element = t.createElement("div")), this.element.classList.add(Dn(), Dn(void 0, "num")), e.arrayPosition && this.element.classList.add(Dn(void 0, e.arrayPosition)), e.viewProps.bindClassModifiers(this.element);
							const n = t.createElement("input");
							n.classList.add(Dn("i")), (n.type = "text"), e.viewProps.bindDisabled(n), this.element.appendChild(n), (this.inputElement = n), (this.onDraggingChange_ = this.onDraggingChange_.bind(this)), (this.dragging_ = e.dragging), this.dragging_.emitter.on("change", this.onDraggingChange_), this.element.classList.add(Dn()), this.inputElement.classList.add(Dn("i"));
							const i = t.createElement("div");
							i.classList.add(Dn("k")), this.element.appendChild(i), (this.knobElement = i);
							const r = t.createElementNS(G, "svg");
							r.classList.add(Dn("g")), this.knobElement.appendChild(r);
							const a = t.createElementNS(G, "path");
							a.classList.add(Dn("gb")), r.appendChild(a), (this.guideBodyElem_ = a);
							const s = t.createElementNS(G, "path");
							s.classList.add(Dn("gh")), r.appendChild(s), (this.guideHeadElem_ = s);
							const o = t.createElement("div");
							o.classList.add(v("tt")()), this.knobElement.appendChild(o), (this.tooltipElem_ = o), e.value.emitter.on("change", this.onChange_), (this.value = e.value), this.refresh();
						}
						onDraggingChange_(t) {
							if (null === t.rawValue) return void this.element.classList.remove(Dn(void 0, "drg"));
							this.element.classList.add(Dn(void 0, "drg"));
							const e = t.rawValue / this.props_.get("draggingScale"),
								n = e + (e > 0 ? -1 : e < 0 ? 1 : 0),
								i = Ln(-n, -4, 4);
							this.guideHeadElem_.setAttributeNS(null, "d", [`M ${n + i},0 L${n},4 L${n + i},8`, `M ${e},-1 L${e},9`].join(" ")), this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${e},4`);
							const r = this.props_.get("formatter");
							(this.tooltipElem_.textContent = r(this.value.rawValue)), (this.tooltipElem_.style.left = `${e}px`);
						}
						refresh() {
							const t = this.props_.get("formatter");
							this.inputElement.value = t(this.value.rawValue);
						}
						onChange_() {
							this.refresh();
						}
					}
					class zn {
						constructor(t, e) {
							(this.originRawValue_ = 0),
								(this.onInputChange_ = this.onInputChange_.bind(this)),
								(this.onInputKeyDown_ = this.onInputKeyDown_.bind(this)),
								(this.onInputKeyUp_ = this.onInputKeyUp_.bind(this)),
								(this.onPointerDown_ = this.onPointerDown_.bind(this)),
								(this.onPointerMove_ = this.onPointerMove_.bind(this)),
								(this.onPointerUp_ = this.onPointerUp_.bind(this)),
								(this.baseStep_ = e.baseStep),
								(this.parser_ = e.parser),
								(this.props = e.props),
								(this.value = e.value),
								(this.viewProps = e.viewProps),
								(this.dragging_ = A(null)),
								(this.view = new On(t, { arrayPosition: e.arrayPosition, dragging: this.dragging_, props: this.props, value: this.value, viewProps: this.viewProps })),
								this.view.inputElement.addEventListener("change", this.onInputChange_),
								this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_),
								this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
							const n = new Cn(this.view.knobElement);
							n.emitter.on("down", this.onPointerDown_), n.emitter.on("move", this.onPointerMove_), n.emitter.on("up", this.onPointerUp_);
						}
						onInputChange_(t) {
							const e = o(t.currentTarget).value,
								n = this.parser_(e);
							l(n) || (this.value.rawValue = n), this.view.refresh();
						}
						onInputKeyDown_(t) {
							const e = _n(this.baseStep_, wn(t));
							0 !== e && this.value.setRawValue(this.value.rawValue + e, { forceEmit: !1, last: !1 });
						}
						onInputKeyUp_(t) {
							0 !== _n(this.baseStep_, wn(t)) && this.value.setRawValue(this.value.rawValue, { forceEmit: !0, last: !0 });
						}
						onPointerDown_() {
							(this.originRawValue_ = this.value.rawValue), (this.dragging_.rawValue = 0);
						}
						computeDraggingValue_(t) {
							if (!t.point) return null;
							const e = t.point.x - t.bounds.width / 2;
							return this.originRawValue_ + e * this.props.get("draggingScale");
						}
						onPointerMove_(t) {
							const e = this.computeDraggingValue_(t.data);
							null !== e && (this.value.setRawValue(e, { forceEmit: !1, last: !1 }), (this.dragging_.rawValue = this.value.rawValue - this.originRawValue_));
						}
						onPointerUp_(t) {
							const e = this.computeDraggingValue_(t.data);
							null !== e && (this.value.setRawValue(e, { forceEmit: !0, last: !0 }), (this.dragging_.rawValue = null));
						}
					}
					const In = v("sld");
					class kn {
						constructor(t, e) {
							(this.onChange_ = this.onChange_.bind(this)), (this.props_ = e.props), this.props_.emitter.on("change", this.onChange_), (this.element = t.createElement("div")), this.element.classList.add(In()), e.viewProps.bindClassModifiers(this.element);
							const n = t.createElement("div");
							n.classList.add(In("t")), e.viewProps.bindTabIndex(n), this.element.appendChild(n), (this.trackElement = n);
							const i = t.createElement("div");
							i.classList.add(In("k")), this.trackElement.appendChild(i), (this.knobElement = i), e.value.emitter.on("change", this.onChange_), (this.value = e.value), this.update_();
						}
						update_() {
							const t = Ln(Pn(this.value.rawValue, this.props_.get("minValue"), this.props_.get("maxValue"), 0, 100), 0, 100);
							this.knobElement.style.width = `${t}%`;
						}
						onChange_() {
							this.update_();
						}
					}
					class Nn {
						constructor(t, e) {
							(this.onKeyDown_ = this.onKeyDown_.bind(this)),
								(this.onKeyUp_ = this.onKeyUp_.bind(this)),
								(this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this)),
								(this.onPointerUp_ = this.onPointerUp_.bind(this)),
								(this.baseStep_ = e.baseStep),
								(this.value = e.value),
								(this.viewProps = e.viewProps),
								(this.props = e.props),
								(this.view = new kn(t, { props: this.props, value: this.value, viewProps: this.viewProps })),
								(this.ptHandler_ = new Cn(this.view.trackElement)),
								this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_),
								this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_),
								this.ptHandler_.emitter.on("up", this.onPointerUp_),
								this.view.trackElement.addEventListener("keydown", this.onKeyDown_),
								this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
						}
						handlePointerEvent_(t, e) {
							t.point && this.value.setRawValue(Pn(Ln(t.point.x, 0, t.bounds.width), 0, t.bounds.width, this.props.get("minValue"), this.props.get("maxValue")), e);
						}
						onPointerDownOrMove_(t) {
							this.handlePointerEvent_(t.data, { forceEmit: !1, last: !1 });
						}
						onPointerUp_(t) {
							this.handlePointerEvent_(t.data, { forceEmit: !0, last: !0 });
						}
						onKeyDown_(t) {
							const e = _n(this.baseStep_, Mn(t));
							0 !== e && this.value.setRawValue(this.value.rawValue + e, { forceEmit: !1, last: !1 });
						}
						onKeyUp_(t) {
							0 !== _n(this.baseStep_, Mn(t)) && this.value.setRawValue(this.value.rawValue, { forceEmit: !0, last: !0 });
						}
					}
					const Vn = v("sldtxt");
					class Bn {
						constructor(t, e) {
							(this.element = t.createElement("div")), this.element.classList.add(Vn());
							const n = t.createElement("div");
							n.classList.add(Vn("s")), (this.sliderView_ = e.sliderView), n.appendChild(this.sliderView_.element), this.element.appendChild(n);
							const i = t.createElement("div");
							i.classList.add(Vn("t")), (this.textView_ = e.textView), i.appendChild(this.textView_.element), this.element.appendChild(i);
						}
					}
					class Fn {
						constructor(t, e) {
							(this.value = e.value), (this.viewProps = e.viewProps), (this.sliderC_ = new Nn(t, { baseStep: e.baseStep, props: e.sliderProps, value: e.value, viewProps: this.viewProps })), (this.textC_ = new zn(t, { baseStep: e.baseStep, parser: e.parser, props: e.textProps, value: e.value, viewProps: e.viewProps })), (this.view = new Bn(t, { sliderView: this.sliderC_.view, textView: this.textC_.view }));
						}
						get sliderController() {
							return this.sliderC_;
						}
						get textController() {
							return this.textC_;
						}
					}
					function Un(t, e) {
						t.write(e);
					}
					function Hn(t) {
						const e = k;
						return Array.isArray(t) ? e.required.array(e.required.object({ text: e.required.string, value: e.required.raw }))(t).value : "object" == typeof t ? e.required.raw(t).value : void 0;
					}
					function Gn(t) {
						if ("inline" === t || "popup" === t) return t;
					}
					function Wn(t) {
						const e = k;
						return e.required.object({ max: e.optional.number, min: e.optional.number, step: e.optional.number })(t).value;
					}
					function jn(t) {
						if (Array.isArray(t)) return t;
						const e = [];
						return (
							Object.keys(t).forEach((n) => {
								e.push({ text: n, value: t[n] });
							}),
							e
						);
					}
					function Xn(t) {
						return l(t) ? null : new pe(jn(o(t)));
					}
					function qn(t) {
						const e = t ? de(t, pe) : null;
						return e ? e.options : null;
					}
					function Yn(t) {
						const e = t ? de(t, me) : null;
						return e ? e.step : null;
					}
					function Zn(t, e) {
						const n = t && de(t, me);
						return n ? An(n.step) : Math.max(An(e), 2);
					}
					function Kn(t) {
						const e = Yn(t);
						return null != e ? e : 1;
					}
					function Jn(t, e) {
						var n;
						const i = t && de(t, me),
							r = Math.abs(null !== (n = null == i ? void 0 : i.step) && void 0 !== n ? n : e);
						return 0 === r ? 0.1 : Math.pow(10, Math.floor(Math.log10(r)) - 1);
					}
					const Qn = v("ckb");
					class $n {
						constructor(t, e) {
							(this.onValueChange_ = this.onValueChange_.bind(this)), (this.element = t.createElement("div")), this.element.classList.add(Qn()), e.viewProps.bindClassModifiers(this.element);
							const n = t.createElement("label");
							n.classList.add(Qn("l")), this.element.appendChild(n);
							const i = t.createElement("input");
							i.classList.add(Qn("i")), (i.type = "checkbox"), n.appendChild(i), (this.inputElement = i), e.viewProps.bindDisabled(this.inputElement);
							const r = t.createElement("div");
							r.classList.add(Qn("w")), n.appendChild(r);
							const a = Q(t, "check");
							r.appendChild(a), e.value.emitter.on("change", this.onValueChange_), (this.value = e.value), this.update_();
						}
						update_() {
							this.inputElement.checked = this.value.rawValue;
						}
						onValueChange_() {
							this.update_();
						}
					}
					class ti {
						constructor(t, e) {
							(this.onInputChange_ = this.onInputChange_.bind(this)), (this.value = e.value), (this.viewProps = e.viewProps), (this.view = new $n(t, { value: this.value, viewProps: this.viewProps })), this.view.inputElement.addEventListener("change", this.onInputChange_);
						}
						onInputChange_(t) {
							const e = o(t.currentTarget);
							this.value.rawValue = e.checked;
						}
					}
					function ei(t) {
						const e = [],
							n = Xn(t.options);
						return n && e.push(n), new he(e);
					}
					const ni = {
							id: "input-bool",
							type: "input",
							accept: (t, e) => {
								if ("boolean" != typeof t) return null;
								const n = N(e, { options: k.optional.custom(Hn) });
								return n ? { initialValue: t, params: n } : null;
							},
							binding: { reader: (t) => Ee, constraint: (t) => ei(t.params), writer: (t) => Un },
							controller: (t) => {
								var e;
								const n = t.document,
									i = t.value,
									r = t.constraint;
								return r && de(r, pe) ? new be(n, { props: L.fromObject({ options: null !== (e = qn(r)) && void 0 !== e ? e : [] }), value: i, viewProps: t.viewProps }) : new ti(n, { value: i, viewProps: t.viewProps });
							},
						},
						ii = v("col");
					class ri {
						constructor(t, e) {
							(this.element = t.createElement("div")), this.element.classList.add(ii()), e.foldable.bindExpandedClass(this.element, ii(void 0, "expanded")), y(e.foldable, "completed", w(this.element, ii(void 0, "cpl")));
							const n = t.createElement("div");
							n.classList.add(ii("h")), this.element.appendChild(n);
							const i = t.createElement("div");
							i.classList.add(ii("s")), n.appendChild(i), (this.swatchElement = i);
							const r = t.createElement("div");
							if ((r.classList.add(ii("t")), n.appendChild(r), (this.textElement = r), "inline" === e.pickerLayout)) {
								const e = t.createElement("div");
								e.classList.add(ii("p")), this.element.appendChild(e), (this.pickerElement = e);
							} else this.pickerElement = null;
						}
					}
					function ai(t, e, n) {
						const i = Ln(t / 255, 0, 1),
							r = Ln(e / 255, 0, 1),
							a = Ln(n / 255, 0, 1),
							s = Math.max(i, r, a),
							o = Math.min(i, r, a),
							l = s - o;
						let c = 0,
							u = 0;
						const h = (o + s) / 2;
						return 0 !== l && ((u = l / (1 - Math.abs(s + o - 1))), (c = i === s ? (r - a) / l : r === s ? 2 + (a - i) / l : 4 + (i - r) / l), (c = c / 6 + (c < 0 ? 1 : 0))), [360 * c, 100 * u, 100 * h];
					}
					function si(t, e, n) {
						const i = ((t % 360) + 360) % 360,
							r = Ln(e / 100, 0, 1),
							a = Ln(n / 100, 0, 1),
							s = (1 - Math.abs(2 * a - 1)) * r,
							o = s * (1 - Math.abs(((i / 60) % 2) - 1)),
							l = a - s / 2;
						let c, u, h;
						return ([c, u, h] = i >= 0 && i < 60 ? [s, o, 0] : i >= 60 && i < 120 ? [o, s, 0] : i >= 120 && i < 180 ? [0, s, o] : i >= 180 && i < 240 ? [0, o, s] : i >= 240 && i < 300 ? [o, 0, s] : [s, 0, o]), [255 * (c + l), 255 * (u + l), 255 * (h + l)];
					}
					function oi(t, e, n) {
						const i = Ln(t / 255, 0, 1),
							r = Ln(e / 255, 0, 1),
							a = Ln(n / 255, 0, 1),
							s = Math.max(i, r, a),
							o = s - Math.min(i, r, a);
						let l;
						return (l = 0 === o ? 0 : s === i ? (((((r - a) / o) % 6) + 6) % 6) * 60 : s === r ? 60 * ((a - i) / o + 2) : 60 * ((i - r) / o + 4)), [l, 100 * (0 === s ? 0 : o / s), 100 * s];
					}
					function li(t, e, n) {
						const i = Rn(t, 360),
							r = Ln(e / 100, 0, 1),
							a = Ln(n / 100, 0, 1),
							s = a * r,
							o = s * (1 - Math.abs(((i / 60) % 2) - 1)),
							l = a - s;
						let c, u, h;
						return ([c, u, h] = i >= 0 && i < 60 ? [s, o, 0] : i >= 60 && i < 120 ? [o, s, 0] : i >= 120 && i < 180 ? [0, s, o] : i >= 180 && i < 240 ? [0, o, s] : i >= 240 && i < 300 ? [o, 0, s] : [s, 0, o]), [255 * (c + l), 255 * (u + l), 255 * (h + l)];
					}
					function ci(t, e, n) {
						const i = n + (e * (100 - Math.abs(2 * n - 100))) / 200;
						return [t, 0 !== i ? (e * (100 - Math.abs(2 * n - 100))) / i : 0, n + (e * (100 - Math.abs(2 * n - 100))) / 200];
					}
					function ui(t, e, n) {
						const i = 100 - Math.abs((n * (200 - e)) / 100 - 100);
						return [t, 0 !== i ? (e * n) / i : 0, (n * (200 - e)) / 200];
					}
					function hi(t) {
						return [t[0], t[1], t[2]];
					}
					function di(t, e) {
						return [t[0], t[1], t[2], e];
					}
					const pi = { hsl: { hsl: (t, e, n) => [t, e, n], hsv: ci, rgb: si }, hsv: { hsl: ui, hsv: (t, e, n) => [t, e, n], rgb: li }, rgb: { hsl: ai, hsv: oi, rgb: (t, e, n) => [t, e, n] } };
					function fi(t, e, n) {
						return pi[e][n](...t);
					}
					const mi = {
						hsl: (t) => {
							var e;
							return [Rn(t[0], 360), Ln(t[1], 0, 100), Ln(t[2], 0, 100), Ln(null !== (e = t[3]) && void 0 !== e ? e : 1, 0, 1)];
						},
						hsv: (t) => {
							var e;
							return [Rn(t[0], 360), Ln(t[1], 0, 100), Ln(t[2], 0, 100), Ln(null !== (e = t[3]) && void 0 !== e ? e : 1, 0, 1)];
						},
						rgb: (t) => {
							var e;
							return [Ln(t[0], 0, 255), Ln(t[1], 0, 255), Ln(t[2], 0, 255), Ln(null !== (e = t[3]) && void 0 !== e ? e : 1, 0, 1)];
						},
					};
					function vi(t, e) {
						return "object" == typeof t && !l(t) && e in t && "number" == typeof t[e];
					}
					class gi {
						constructor(t, e) {
							(this.mode_ = e), (this.comps_ = mi[e](t));
						}
						static black() {
							return new gi([0, 0, 0], "rgb");
						}
						static fromObject(t) {
							const e = "a" in t ? [t.r, t.g, t.b, t.a] : [t.r, t.g, t.b];
							return new gi(e, "rgb");
						}
						static toRgbaObject(t) {
							return t.toRgbaObject();
						}
						static isRgbColorObject(t) {
							return vi(t, "r") && vi(t, "g") && vi(t, "b");
						}
						static isRgbaColorObject(t) {
							return this.isRgbColorObject(t) && vi(t, "a");
						}
						static isColorObject(t) {
							return this.isRgbColorObject(t);
						}
						static equals(t, e) {
							if (t.mode_ !== e.mode_) return !1;
							const n = t.comps_,
								i = e.comps_;
							for (let t = 0; t < n.length; t++) if (n[t] !== i[t]) return !1;
							return !0;
						}
						get mode() {
							return this.mode_;
						}
						getComponents(t) {
							return di(fi(hi(this.comps_), this.mode_, t || this.mode_), this.comps_[3]);
						}
						toRgbaObject() {
							const t = this.getComponents("rgb");
							return { r: t[0], g: t[1], b: t[2], a: t[3] };
						}
					}
					const bi = v("colp");
					class xi {
						constructor(t, e) {
							(this.alphaViews_ = null), (this.element = t.createElement("div")), this.element.classList.add(bi());
							const n = t.createElement("div");
							n.classList.add(bi("hsv"));
							const i = t.createElement("div");
							i.classList.add(bi("sv")), (this.svPaletteView_ = e.svPaletteView), i.appendChild(this.svPaletteView_.element), n.appendChild(i);
							const r = t.createElement("div");
							r.classList.add(bi("h")), (this.hPaletteView_ = e.hPaletteView), r.appendChild(this.hPaletteView_.element), n.appendChild(r), this.element.appendChild(n);
							const a = t.createElement("div");
							if ((a.classList.add(bi("rgb")), (this.textView_ = e.textView), a.appendChild(this.textView_.element), this.element.appendChild(a), e.alphaViews)) {
								this.alphaViews_ = { palette: e.alphaViews.palette, text: e.alphaViews.text };
								const n = t.createElement("div");
								n.classList.add(bi("a"));
								const i = t.createElement("div");
								i.classList.add(bi("ap")), i.appendChild(this.alphaViews_.palette.element), n.appendChild(i);
								const r = t.createElement("div");
								r.classList.add(bi("at")), r.appendChild(this.alphaViews_.text.element), n.appendChild(r), this.element.appendChild(n);
							}
						}
						get allFocusableElements() {
							const t = [this.svPaletteView_.element, this.hPaletteView_.element, this.textView_.modeSelectElement, ...this.textView_.textViews.map((t) => t.inputElement)];
							return this.alphaViews_ && t.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement), t;
						}
					}
					function yi(t) {
						const e = k;
						return N(t, { alpha: e.optional.boolean, expanded: e.optional.boolean, picker: e.optional.custom(Gn) });
					}
					function _i(t) {
						return t ? 0.1 : 1;
					}
					function wi(t, e) {
						const n = t.match(/^(.+)%$/);
						return n ? Math.min(0.01 * parseFloat(n[1]) * e, e) : Math.min(parseFloat(t), e);
					}
					const Mi = { deg: (t) => t, grad: (t) => (360 * t) / 400, rad: (t) => (360 * t) / (2 * Math.PI), turn: (t) => 360 * t };
					function Si(t) {
						const e = t.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
						if (!e) return parseFloat(t);
						const n = parseFloat(e[1]),
							i = e[2];
						return Mi[i](n);
					}
					const Ti = {
						"func.rgb": (t) => {
							const e = t.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
							if (!e) return null;
							const n = [wi(e[1], 255), wi(e[2], 255), wi(e[3], 255)];
							return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) ? null : new gi(n, "rgb");
						},
						"func.rgba": (t) => {
							const e = t.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
							if (!e) return null;
							const n = [wi(e[1], 255), wi(e[2], 255), wi(e[3], 255), wi(e[4], 1)];
							return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) || isNaN(n[3]) ? null : new gi(n, "rgb");
						},
						"func.hsl": (t) => {
							const e = t.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
							if (!e) return null;
							const n = [Si(e[1]), wi(e[2], 100), wi(e[3], 100)];
							return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) ? null : new gi(n, "hsl");
						},
						"func.hsla": (t) => {
							const e = t.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
							if (!e) return null;
							const n = [Si(e[1]), wi(e[2], 100), wi(e[3], 100), wi(e[4], 1)];
							return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) || isNaN(n[3]) ? null : new gi(n, "hsl");
						},
						"hex.rgb": (t) => {
							const e = t.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
							if (e) return new gi([parseInt(e[1] + e[1], 16), parseInt(e[2] + e[2], 16), parseInt(e[3] + e[3], 16)], "rgb");
							const n = t.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
							return n ? new gi([parseInt(n[1], 16), parseInt(n[2], 16), parseInt(n[3], 16)], "rgb") : null;
						},
						"hex.rgba": (t) => {
							const e = t.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
							if (e) return new gi([parseInt(e[1] + e[1], 16), parseInt(e[2] + e[2], 16), parseInt(e[3] + e[3], 16), Pn(parseInt(e[4] + e[4], 16), 0, 255, 0, 1)], "rgb");
							const n = t.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
							return n ? new gi([parseInt(n[1], 16), parseInt(n[2], 16), parseInt(n[3], 16), Pn(parseInt(n[4], 16), 0, 255, 0, 1)], "rgb") : null;
						},
					};
					function Ei(t) {
						return Object.keys(Ti).reduce((e, n) => e || ((0, Ti[n])(t) ? n : null), null);
					}
					const Ci = (t) => {
						const e = Ei(t);
						return e ? Ti[e](t) : null;
					};
					function Pi(t) {
						return "func.hsla" === t || "func.rgba" === t || "hex.rgba" === t;
					}
					function Ai(t) {
						if ("string" == typeof t) {
							const e = Ci(t);
							if (e) return e;
						}
						return gi.black();
					}
					function Li(t) {
						const e = Ln(Math.floor(t), 0, 255).toString(16);
						return 1 === e.length ? `0${e}` : e;
					}
					function Ri(t, e = "#") {
						return `${e}${hi(t.getComponents("rgb")).map(Li).join("")}`;
					}
					function Di(t, e = "#") {
						const n = t.getComponents("rgb");
						return `${e}${[n[0], n[1], n[2], 255 * n[3]].map(Li).join("")}`;
					}
					function Oi(t) {
						const e = hn(0);
						return `rgb(${hi(t.getComponents("rgb"))
							.map((t) => e(t))
							.join(", ")})`;
					}
					function zi(t) {
						const e = hn(2),
							n = hn(0);
						return `rgba(${t
							.getComponents("rgb")
							.map((t, i) => (3 === i ? e : n)(t))
							.join(", ")})`;
					}
					function Ii(t) {
						const e = [hn(0), pn, pn];
						return `hsl(${hi(t.getComponents("hsl"))
							.map((t, n) => e[n](t))
							.join(", ")})`;
					}
					function ki(t) {
						const e = [hn(0), pn, pn, hn(2)];
						return `hsla(${t
							.getComponents("hsl")
							.map((t, n) => e[n](t))
							.join(", ")})`;
					}
					const Ni = { "func.hsl": Ii, "func.hsla": ki, "func.rgb": Oi, "func.rgba": zi, "hex.rgb": Ri, "hex.rgba": Di };
					function Vi(t) {
						return Ni[t];
					}
					const Bi = v("apl");
					class Fi {
						constructor(t, e) {
							(this.onValueChange_ = this.onValueChange_.bind(this)), (this.value = e.value), this.value.emitter.on("change", this.onValueChange_), (this.element = t.createElement("div")), this.element.classList.add(Bi()), e.viewProps.bindTabIndex(this.element);
							const n = t.createElement("div");
							n.classList.add(Bi("b")), this.element.appendChild(n);
							const i = t.createElement("div");
							i.classList.add(Bi("c")), n.appendChild(i), (this.colorElem_ = i);
							const r = t.createElement("div");
							r.classList.add(Bi("m")), this.element.appendChild(r), (this.markerElem_ = r);
							const a = t.createElement("div");
							a.classList.add(Bi("p")), this.markerElem_.appendChild(a), (this.previewElem_ = a), this.update_();
						}
						update_() {
							const t = this.value.rawValue,
								e = t.getComponents("rgb"),
								n = new gi([e[0], e[1], e[2], 0], "rgb"),
								i = new gi([e[0], e[1], e[2], 255], "rgb"),
								r = ["to right", zi(n), zi(i)];
							(this.colorElem_.style.background = `linear-gradient(${r.join(",")})`), (this.previewElem_.style.backgroundColor = zi(t));
							const a = Pn(e[3], 0, 1, 0, 100);
							this.markerElem_.style.left = `${a}%`;
						}
						onValueChange_() {
							this.update_();
						}
					}
					class Ui {
						constructor(t, e) {
							(this.onKeyDown_ = this.onKeyDown_.bind(this)),
								(this.onKeyUp_ = this.onKeyUp_.bind(this)),
								(this.onPointerDown_ = this.onPointerDown_.bind(this)),
								(this.onPointerMove_ = this.onPointerMove_.bind(this)),
								(this.onPointerUp_ = this.onPointerUp_.bind(this)),
								(this.value = e.value),
								(this.viewProps = e.viewProps),
								(this.view = new Fi(t, { value: this.value, viewProps: this.viewProps })),
								(this.ptHandler_ = new Cn(this.view.element)),
								this.ptHandler_.emitter.on("down", this.onPointerDown_),
								this.ptHandler_.emitter.on("move", this.onPointerMove_),
								this.ptHandler_.emitter.on("up", this.onPointerUp_),
								this.view.element.addEventListener("keydown", this.onKeyDown_),
								this.view.element.addEventListener("keyup", this.onKeyUp_);
						}
						handlePointerEvent_(t, e) {
							if (!t.point) return;
							const n = t.point.x / t.bounds.width,
								i = this.value.rawValue,
								[r, a, s] = i.getComponents("hsv");
							this.value.setRawValue(new gi([r, a, s, n], "hsv"), e);
						}
						onPointerDown_(t) {
							this.handlePointerEvent_(t.data, { forceEmit: !1, last: !1 });
						}
						onPointerMove_(t) {
							this.handlePointerEvent_(t.data, { forceEmit: !1, last: !1 });
						}
						onPointerUp_(t) {
							this.handlePointerEvent_(t.data, { forceEmit: !0, last: !0 });
						}
						onKeyDown_(t) {
							const e = _n(_i(!0), Mn(t));
							if (0 === e) return;
							const n = this.value.rawValue,
								[i, r, a, s] = n.getComponents("hsv");
							this.value.setRawValue(new gi([i, r, a, s + e], "hsv"), { forceEmit: !1, last: !1 });
						}
						onKeyUp_(t) {
							0 !== _n(_i(!0), Mn(t)) && this.value.setRawValue(this.value.rawValue, { forceEmit: !0, last: !0 });
						}
					}
					const Hi = v("coltxt");
					function Gi(t) {
						const e = t.createElement("select"),
							n = [
								{ text: "RGB", value: "rgb" },
								{ text: "HSL", value: "hsl" },
								{ text: "HSV", value: "hsv" },
							];
						return (
							e.appendChild(
								n.reduce((e, n) => {
									const i = t.createElement("option");
									return (i.textContent = n.text), (i.value = n.value), e.appendChild(i), e;
								}, t.createDocumentFragment())
							),
							e
						);
					}
					class Wi {
						constructor(t, e) {
							(this.element = t.createElement("div")), this.element.classList.add(Hi());
							const n = t.createElement("div");
							n.classList.add(Hi("m")), (this.modeElem_ = Gi(t)), this.modeElem_.classList.add(Hi("ms")), n.appendChild(this.modeSelectElement);
							const i = t.createElement("div");
							i.classList.add(Hi("mm")), i.appendChild(Q(t, "dropdown")), n.appendChild(i), this.element.appendChild(n);
							const r = t.createElement("div");
							r.classList.add(Hi("w")),
								this.element.appendChild(r),
								(this.textsElem_ = r),
								(this.textViews_ = e.textViews),
								this.applyTextViews_(),
								x(e.colorMode, (t) => {
									this.modeElem_.value = t;
								});
						}
						get modeSelectElement() {
							return this.modeElem_;
						}
						get textViews() {
							return this.textViews_;
						}
						set textViews(t) {
							(this.textViews_ = t), this.applyTextViews_();
						}
						applyTextViews_() {
							et(this.textsElem_);
							const t = this.element.ownerDocument;
							this.textViews_.forEach((e) => {
								const n = t.createElement("div");
								n.classList.add(Hi("c")), n.appendChild(e.element), this.textsElem_.appendChild(n);
							});
						}
					}
					const ji = hn(0),
						Xi = { rgb: () => new fe({ min: 0, max: 255 }), hsl: (t) => new fe(0 === t ? { min: 0, max: 360 } : { min: 0, max: 100 }), hsv: (t) => new fe(0 === t ? { min: 0, max: 360 } : { min: 0, max: 100 }) };
					function qi(t, e, n) {
						return new zn(t, { arrayPosition: 0 === n ? "fst" : 2 === n ? "lst" : "mid", baseStep: _i(!1), parser: e.parser, props: L.fromObject({ draggingScale: 1, formatter: ji }), value: A(0, { constraint: Xi[e.colorMode](n) }), viewProps: e.viewProps });
					}
					class Yi {
						constructor(t, e) {
							(this.onModeSelectChange_ = this.onModeSelectChange_.bind(this)), (this.parser_ = e.parser), (this.value = e.value), (this.viewProps = e.viewProps), (this.colorMode = A(this.value.rawValue.mode)), (this.ccs_ = this.createComponentControllers_(t)), (this.view = new Wi(t, { colorMode: this.colorMode, textViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view] })), this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_);
						}
						createComponentControllers_(t) {
							const e = { colorMode: this.colorMode.rawValue, parser: this.parser_, viewProps: this.viewProps },
								n = [qi(t, e, 0), qi(t, e, 1), qi(t, e, 2)];
							return (
								n.forEach((t, e) => {
									yn({
										primary: this.value,
										secondary: t.value,
										forward: (t) => t.rawValue.getComponents(this.colorMode.rawValue)[e],
										backward: (t, n) => {
											const i = this.colorMode.rawValue,
												r = t.rawValue.getComponents(i);
											return (r[e] = n.rawValue), new gi(di(hi(r), r[3]), i);
										},
									});
								}),
								n
							);
						}
						onModeSelectChange_(t) {
							const e = t.currentTarget;
							(this.colorMode.rawValue = e.value), (this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument)), (this.view.textViews = [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view]);
						}
					}
					const Zi = v("hpl");
					class Ki {
						constructor(t, e) {
							(this.onValueChange_ = this.onValueChange_.bind(this)), (this.value = e.value), this.value.emitter.on("change", this.onValueChange_), (this.element = t.createElement("div")), this.element.classList.add(Zi()), e.viewProps.bindTabIndex(this.element);
							const n = t.createElement("div");
							n.classList.add(Zi("c")), this.element.appendChild(n);
							const i = t.createElement("div");
							i.classList.add(Zi("m")), this.element.appendChild(i), (this.markerElem_ = i), this.update_();
						}
						update_() {
							const t = this.value.rawValue,
								[e] = t.getComponents("hsv");
							this.markerElem_.style.backgroundColor = Oi(new gi([e, 100, 100], "hsv"));
							const n = Pn(e, 0, 360, 0, 100);
							this.markerElem_.style.left = `${n}%`;
						}
						onValueChange_() {
							this.update_();
						}
					}
					class Ji {
						constructor(t, e) {
							(this.onKeyDown_ = this.onKeyDown_.bind(this)),
								(this.onKeyUp_ = this.onKeyUp_.bind(this)),
								(this.onPointerDown_ = this.onPointerDown_.bind(this)),
								(this.onPointerMove_ = this.onPointerMove_.bind(this)),
								(this.onPointerUp_ = this.onPointerUp_.bind(this)),
								(this.value = e.value),
								(this.viewProps = e.viewProps),
								(this.view = new Ki(t, { value: this.value, viewProps: this.viewProps })),
								(this.ptHandler_ = new Cn(this.view.element)),
								this.ptHandler_.emitter.on("down", this.onPointerDown_),
								this.ptHandler_.emitter.on("move", this.onPointerMove_),
								this.ptHandler_.emitter.on("up", this.onPointerUp_),
								this.view.element.addEventListener("keydown", this.onKeyDown_),
								this.view.element.addEventListener("keyup", this.onKeyUp_);
						}
						handlePointerEvent_(t, e) {
							if (!t.point) return;
							const n = Pn(t.point.x, 0, t.bounds.width, 0, 360),
								i = this.value.rawValue,
								[, r, a, s] = i.getComponents("hsv");
							this.value.setRawValue(new gi([n, r, a, s], "hsv"), e);
						}
						onPointerDown_(t) {
							this.handlePointerEvent_(t.data, { forceEmit: !1, last: !1 });
						}
						onPointerMove_(t) {
							this.handlePointerEvent_(t.data, { forceEmit: !1, last: !1 });
						}
						onPointerUp_(t) {
							this.handlePointerEvent_(t.data, { forceEmit: !0, last: !0 });
						}
						onKeyDown_(t) {
							const e = _n(_i(!1), Mn(t));
							if (0 === e) return;
							const n = this.value.rawValue,
								[i, r, a, s] = n.getComponents("hsv");
							this.value.setRawValue(new gi([i + e, r, a, s], "hsv"), { forceEmit: !1, last: !1 });
						}
						onKeyUp_(t) {
							0 !== _n(_i(!1), Mn(t)) && this.value.setRawValue(this.value.rawValue, { forceEmit: !0, last: !0 });
						}
					}
					const Qi = v("svp"),
						$i = 64;
					class tr {
						constructor(t, e) {
							(this.onValueChange_ = this.onValueChange_.bind(this)), (this.value = e.value), this.value.emitter.on("change", this.onValueChange_), (this.element = t.createElement("div")), this.element.classList.add(Qi()), e.viewProps.bindTabIndex(this.element);
							const n = t.createElement("canvas");
							(n.height = $i), (n.width = $i), n.classList.add(Qi("c")), this.element.appendChild(n), (this.canvasElement = n);
							const i = t.createElement("div");
							i.classList.add(Qi("m")), this.element.appendChild(i), (this.markerElem_ = i), this.update_();
						}
						update_() {
							const t = K(this.canvasElement);
							if (!t) return;
							const e = this.value.rawValue.getComponents("hsv"),
								n = this.canvasElement.width,
								i = this.canvasElement.height,
								r = t.getImageData(0, 0, n, i),
								a = r.data;
							for (let t = 0; t < i; t++)
								for (let r = 0; r < n; r++) {
									const s = Pn(r, 0, n, 0, 100),
										o = Pn(t, 0, i, 100, 0),
										l = li(e[0], s, o),
										c = 4 * (t * n + r);
									(a[c] = l[0]), (a[c + 1] = l[1]), (a[c + 2] = l[2]), (a[c + 3] = 255);
								}
							t.putImageData(r, 0, 0);
							const s = Pn(e[1], 0, 100, 0, 100);
							this.markerElem_.style.left = `${s}%`;
							const o = Pn(e[2], 0, 100, 100, 0);
							this.markerElem_.style.top = `${o}%`;
						}
						onValueChange_() {
							this.update_();
						}
					}
					class er {
						constructor(t, e) {
							(this.onKeyDown_ = this.onKeyDown_.bind(this)),
								(this.onKeyUp_ = this.onKeyUp_.bind(this)),
								(this.onPointerDown_ = this.onPointerDown_.bind(this)),
								(this.onPointerMove_ = this.onPointerMove_.bind(this)),
								(this.onPointerUp_ = this.onPointerUp_.bind(this)),
								(this.value = e.value),
								(this.viewProps = e.viewProps),
								(this.view = new tr(t, { value: this.value, viewProps: this.viewProps })),
								(this.ptHandler_ = new Cn(this.view.element)),
								this.ptHandler_.emitter.on("down", this.onPointerDown_),
								this.ptHandler_.emitter.on("move", this.onPointerMove_),
								this.ptHandler_.emitter.on("up", this.onPointerUp_),
								this.view.element.addEventListener("keydown", this.onKeyDown_),
								this.view.element.addEventListener("keyup", this.onKeyUp_);
						}
						handlePointerEvent_(t, e) {
							if (!t.point) return;
							const n = Pn(t.point.x, 0, t.bounds.width, 0, 100),
								i = Pn(t.point.y, 0, t.bounds.height, 100, 0),
								[r, , , a] = this.value.rawValue.getComponents("hsv");
							this.value.setRawValue(new gi([r, n, i, a], "hsv"), e);
						}
						onPointerDown_(t) {
							this.handlePointerEvent_(t.data, { forceEmit: !1, last: !1 });
						}
						onPointerMove_(t) {
							this.handlePointerEvent_(t.data, { forceEmit: !1, last: !1 });
						}
						onPointerUp_(t) {
							this.handlePointerEvent_(t.data, { forceEmit: !0, last: !0 });
						}
						onKeyDown_(t) {
							Tn(t.key) && t.preventDefault();
							const [e, n, i, r] = this.value.rawValue.getComponents("hsv"),
								a = _i(!1),
								s = _n(a, Mn(t)),
								o = _n(a, wn(t));
							(0 === s && 0 === o) || this.value.setRawValue(new gi([e, n + s, i + o, r], "hsv"), { forceEmit: !1, last: !1 });
						}
						onKeyUp_(t) {
							const e = _i(!1),
								n = _n(e, Mn(t)),
								i = _n(e, wn(t));
							(0 === n && 0 === i) || this.value.setRawValue(this.value.rawValue, { forceEmit: !0, last: !0 });
						}
					}
					class nr {
						constructor(t, e) {
							(this.value = e.value),
								(this.viewProps = e.viewProps),
								(this.hPaletteC_ = new Ji(t, { value: this.value, viewProps: this.viewProps })),
								(this.svPaletteC_ = new er(t, { value: this.value, viewProps: this.viewProps })),
								(this.alphaIcs_ = e.supportsAlpha ? { palette: new Ui(t, { value: this.value, viewProps: this.viewProps }), text: new zn(t, { parser: ln, baseStep: 0.1, props: L.fromObject({ draggingScale: 0.01, formatter: hn(2) }), value: A(0, { constraint: new fe({ min: 0, max: 1 }) }), viewProps: this.viewProps }) } : null),
								this.alphaIcs_ &&
									yn({
										primary: this.value,
										secondary: this.alphaIcs_.text.value,
										forward: (t) => t.rawValue.getComponents()[3],
										backward: (t, e) => {
											const n = t.rawValue.getComponents();
											return (n[3] = e.rawValue), new gi(n, t.rawValue.mode);
										},
									}),
								(this.textC_ = new Yi(t, { parser: ln, value: this.value, viewProps: this.viewProps })),
								(this.view = new xi(t, { alphaViews: this.alphaIcs_ ? { palette: this.alphaIcs_.palette.view, text: this.alphaIcs_.text.view } : null, hPaletteView: this.hPaletteC_.view, supportsAlpha: e.supportsAlpha, svPaletteView: this.svPaletteC_.view, textView: this.textC_.view }));
						}
						get textController() {
							return this.textC_;
						}
					}
					const ir = v("colsw");
					class rr {
						constructor(t, e) {
							(this.onValueChange_ = this.onValueChange_.bind(this)), e.value.emitter.on("change", this.onValueChange_), (this.value = e.value), (this.element = t.createElement("div")), this.element.classList.add(ir()), e.viewProps.bindClassModifiers(this.element);
							const n = t.createElement("div");
							n.classList.add(ir("sw")), this.element.appendChild(n), (this.swatchElem_ = n);
							const i = t.createElement("button");
							i.classList.add(ir("b")), e.viewProps.bindDisabled(i), this.element.appendChild(i), (this.buttonElement = i), this.update_();
						}
						update_() {
							const t = this.value.rawValue;
							this.swatchElem_.style.backgroundColor = Di(t);
						}
						onValueChange_() {
							this.update_();
						}
					}
					class ar {
						constructor(t, e) {
							(this.value = e.value), (this.viewProps = e.viewProps), (this.view = new rr(t, { value: this.value, viewProps: this.viewProps }));
						}
					}
					class sr {
						constructor(t, e) {
							(this.onButtonBlur_ = this.onButtonBlur_.bind(this)), (this.onButtonClick_ = this.onButtonClick_.bind(this)), (this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this)), (this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this)), (this.value = e.value), (this.viewProps = e.viewProps), (this.foldable_ = ht.create(e.expanded)), (this.swatchC_ = new ar(t, { value: this.value, viewProps: this.viewProps }));
							const n = this.swatchC_.view.buttonElement;
							n.addEventListener("blur", this.onButtonBlur_),
								n.addEventListener("click", this.onButtonClick_),
								(this.textC_ = new Se(t, { parser: e.parser, props: L.fromObject({ formatter: e.formatter }), value: this.value, viewProps: this.viewProps })),
								(this.view = new ri(t, { foldable: this.foldable_, pickerLayout: e.pickerLayout })),
								this.view.swatchElement.appendChild(this.swatchC_.view.element),
								this.view.textElement.appendChild(this.textC_.view.element),
								(this.popC_ = "popup" === e.pickerLayout ? new _e(t, { viewProps: this.viewProps }) : null);
							const i = new nr(t, { supportsAlpha: e.supportsAlpha, value: this.value, viewProps: this.viewProps });
							i.view.allFocusableElements.forEach((t) => {
								t.addEventListener("blur", this.onPopupChildBlur_), t.addEventListener("keydown", this.onPopupChildKeydown_);
							}),
								(this.pickerC_ = i),
								this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(i.view.element), yn({ primary: this.foldable_.value("expanded"), secondary: this.popC_.shows, forward: (t) => t.rawValue, backward: (t, e) => e.rawValue })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), ft(this.foldable_, this.view.pickerElement));
						}
						get textController() {
							return this.textC_;
						}
						onButtonBlur_(t) {
							if (!this.popC_) return;
							const e = this.view.element,
								n = o(t.relatedTarget);
							(n && e.contains(n)) || (this.popC_.shows.rawValue = !1);
						}
						onButtonClick_() {
							this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus();
						}
						onPopupChildBlur_(t) {
							if (!this.popC_) return;
							const e = this.popC_.view.element,
								n = it(t);
							(n && e.contains(n)) || (n && n === this.swatchC_.view.buttonElement && !X(e.ownerDocument)) || (this.popC_.shows.rawValue = !1);
						}
						onPopupChildKeydown_(t) {
							this.popC_ ? "Escape" === t.key && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && "Escape" === t.key && this.swatchC_.view.buttonElement.focus();
						}
					}
					function or(t) {
						return gi.isColorObject(t) ? gi.fromObject(t) : gi.black();
					}
					function lr(t) {
						return hi(t.getComponents("rgb")).reduce((t, e) => (t << 8) | (255 & Math.floor(e)), 0);
					}
					function cr(t) {
						return t.getComponents("rgb").reduce((t, e, n) => (t << 8) | (255 & Math.floor(3 === n ? 255 * e : e)), 0) >>> 0;
					}
					function ur(t) {
						return new gi([(t >> 16) & 255, (t >> 8) & 255, 255 & t], "rgb");
					}
					function hr(t) {
						return new gi([(t >> 24) & 255, (t >> 16) & 255, (t >> 8) & 255, Pn(255 & t, 0, 255, 0, 1)], "rgb");
					}
					function dr(t) {
						return "number" != typeof t ? gi.black() : ur(t);
					}
					function pr(t) {
						return "number" != typeof t ? gi.black() : hr(t);
					}
					function fr(t) {
						const e = Vi(t);
						return (t, n) => {
							Un(t, e(n));
						};
					}
					function mr(t) {
						const e = t ? cr : lr;
						return (t, n) => {
							Un(t, e(n));
						};
					}
					function vr(t, e) {
						const n = e.toRgbaObject();
						t.writeProperty("r", n.r), t.writeProperty("g", n.g), t.writeProperty("b", n.b), t.writeProperty("a", n.a);
					}
					function gr(t, e) {
						const n = e.toRgbaObject();
						t.writeProperty("r", n.r), t.writeProperty("g", n.g), t.writeProperty("b", n.b);
					}
					function br(t) {
						return t ? vr : gr;
					}
					function xr(t) {
						return "alpha" in t && !0 === t.alpha;
					}
					function yr(t) {
						return t ? (t) => Di(t, "0x") : (t) => Ri(t, "0x");
					}
					const _r = {
						id: "input-color-number",
						type: "input",
						accept: (t, e) => {
							if ("number" != typeof t) return null;
							if (!("view" in e)) return null;
							if ("color" !== e.view) return null;
							const n = yi(e);
							return n ? { initialValue: t, params: n } : null;
						},
						binding: { reader: (t) => (xr(t.params) ? pr : dr), equals: gi.equals, writer: (t) => mr(xr(t.params)) },
						controller: (t) => {
							const e = xr(t.params),
								n = "expanded" in t.params ? t.params.expanded : void 0,
								i = "picker" in t.params ? t.params.picker : void 0;
							return new sr(t.document, { expanded: null != n && n, formatter: yr(e), parser: Ci, pickerLayout: null != i ? i : "popup", supportsAlpha: e, value: t.value, viewProps: t.viewProps });
						},
					};
					function wr(t) {
						return gi.isRgbaColorObject(t);
					}
					const Mr = {
							id: "input-color-object",
							type: "input",
							accept: (t, e) => {
								if (!gi.isColorObject(t)) return null;
								const n = yi(e);
								return n ? { initialValue: t, params: n } : null;
							},
							binding: { reader: (t) => or, equals: gi.equals, writer: (t) => br(wr(t.initialValue)) },
							controller: (t) => {
								const e = gi.isRgbaColorObject(t.initialValue),
									n = "expanded" in t.params ? t.params.expanded : void 0,
									i = "picker" in t.params ? t.params.picker : void 0,
									r = e ? Di : Ri;
								return new sr(t.document, { expanded: null != n && n, formatter: r, parser: Ci, pickerLayout: null != i ? i : "popup", supportsAlpha: e, value: t.value, viewProps: t.viewProps });
							},
						},
						Sr = {
							id: "input-color-string",
							type: "input",
							accept: (t, e) => {
								if ("string" != typeof t) return null;
								if ("view" in e && "text" === e.view) return null;
								if (!Ei(t)) return null;
								const n = yi(e);
								return n ? { initialValue: t, params: n } : null;
							},
							binding: {
								reader: (t) => Ai,
								equals: gi.equals,
								writer: (t) => {
									const e = Ei(t.initialValue);
									if (!e) throw h.shouldNeverHappen();
									return fr(e);
								},
							},
							controller: (t) => {
								const e = Ei(t.initialValue);
								if (!e) throw h.shouldNeverHappen();
								const n = Vi(e),
									i = "expanded" in t.params ? t.params.expanded : void 0,
									r = "picker" in t.params ? t.params.picker : void 0;
								return new sr(t.document, { expanded: null != i && i, formatter: n, parser: Ci, pickerLayout: null != r ? r : "popup", supportsAlpha: Pi(e), value: t.value, viewProps: t.viewProps });
							},
						};
					class Tr {
						constructor(t) {
							(this.components = t.components), (this.asm_ = t.assembly);
						}
						constrain(t) {
							const e = this.asm_.toComponents(t).map((t, e) => {
								var n, i;
								return null !== (i = null === (n = this.components[e]) || void 0 === n ? void 0 : n.constrain(t)) && void 0 !== i ? i : t;
							});
							return this.asm_.fromComponents(e);
						}
					}
					const Er = v("pndtxt");
					class Cr {
						constructor(t, e) {
							(this.textViews = e.textViews),
								(this.element = t.createElement("div")),
								this.element.classList.add(Er()),
								this.textViews.forEach((e) => {
									const n = t.createElement("div");
									n.classList.add(Er("a")), n.appendChild(e.element), this.element.appendChild(n);
								});
						}
					}
					function Pr(t, e, n) {
						return new zn(t, { arrayPosition: 0 === n ? "fst" : n === e.axes.length - 1 ? "lst" : "mid", baseStep: e.axes[n].baseStep, parser: e.parser, props: e.axes[n].textProps, value: A(0, { constraint: e.axes[n].constraint }), viewProps: e.viewProps });
					}
					class Ar {
						constructor(t, e) {
							(this.value = e.value),
								(this.viewProps = e.viewProps),
								(this.acs_ = e.axes.map((n, i) => Pr(t, e, i))),
								this.acs_.forEach((t, n) => {
									yn({
										primary: this.value,
										secondary: t.value,
										forward: (t) => e.assembly.toComponents(t.rawValue)[n],
										backward: (t, i) => {
											const r = e.assembly.toComponents(t.rawValue);
											return (r[n] = i.rawValue), e.assembly.fromComponents(r);
										},
									});
								}),
								(this.view = new Cr(t, { textViews: this.acs_.map((t) => t.view) }));
						}
					}
					function Lr(t) {
						return "step" in t && !l(t.step) ? new me(t.step) : null;
					}
					function Rr(t) {
						return ("max" in t && !l(t.max)) || ("min" in t && !l(t.min)) ? new fe({ max: t.max, min: t.min }) : null;
					}
					function Dr(t) {
						const e = [],
							n = Lr(t);
						n && e.push(n);
						const i = Rr(t);
						i && e.push(i);
						const r = Xn(t.options);
						return r && e.push(r), new he(e);
					}
					function Or(t) {
						const e = t ? de(t, fe) : null;
						return e ? [e.minValue, e.maxValue] : [void 0, void 0];
					}
					function zr(t) {
						const [e, n] = Or(t);
						return [null != e ? e : 0, null != n ? n : 100];
					}
					const Ir = {
						id: "input-number",
						type: "input",
						accept: (t, e) => {
							if ("number" != typeof t) return null;
							const n = k,
								i = N(e, { format: n.optional.function, max: n.optional.number, min: n.optional.number, options: n.optional.custom(Hn), step: n.optional.number });
							return i ? { initialValue: t, params: i } : null;
						},
						binding: { reader: (t) => cn, constraint: (t) => Dr(t.params), writer: (t) => Un },
						controller: (t) => {
							var e, n;
							const i = t.value,
								r = t.constraint;
							if (r && de(r, pe)) return new be(t.document, { props: L.fromObject({ options: null !== (e = qn(r)) && void 0 !== e ? e : [] }), value: i, viewProps: t.viewProps });
							const a = null !== (n = "format" in t.params ? t.params.format : void 0) && void 0 !== n ? n : hn(Zn(r, i.rawValue));
							if (r && de(r, fe)) {
								const [e, n] = zr(r);
								return new Fn(t.document, { baseStep: Kn(r), parser: ln, sliderProps: L.fromObject({ maxValue: n, minValue: e }), textProps: L.fromObject({ draggingScale: Jn(r, i.rawValue), formatter: a }), value: i, viewProps: t.viewProps });
							}
							return new zn(t.document, { baseStep: Kn(r), parser: ln, props: L.fromObject({ draggingScale: Jn(r, i.rawValue), formatter: a }), value: i, viewProps: t.viewProps });
						},
					};
					class kr {
						constructor(t = 0, e = 0) {
							(this.x = t), (this.y = e);
						}
						getComponents() {
							return [this.x, this.y];
						}
						static isObject(t) {
							if (l(t)) return !1;
							const e = t.x,
								n = t.y;
							return "number" == typeof e && "number" == typeof n;
						}
						static equals(t, e) {
							return t.x === e.x && t.y === e.y;
						}
						toObject() {
							return { x: this.x, y: this.y };
						}
					}
					const Nr = { toComponents: (t) => t.getComponents(), fromComponents: (t) => new kr(...t) },
						Vr = v("p2d");
					class Br {
						constructor(t, e) {
							(this.element = t.createElement("div")), this.element.classList.add(Vr()), e.viewProps.bindClassModifiers(this.element), x(e.expanded, w(this.element, Vr(void 0, "expanded")));
							const n = t.createElement("div");
							n.classList.add(Vr("h")), this.element.appendChild(n);
							const i = t.createElement("button");
							i.classList.add(Vr("b")), i.appendChild(Q(t, "p2dpad")), e.viewProps.bindDisabled(i), n.appendChild(i), (this.buttonElement = i);
							const r = t.createElement("div");
							if ((r.classList.add(Vr("t")), n.appendChild(r), (this.textElement = r), "inline" === e.pickerLayout)) {
								const e = t.createElement("div");
								e.classList.add(Vr("p")), this.element.appendChild(e), (this.pickerElement = e);
							} else this.pickerElement = null;
						}
					}
					const Fr = v("p2dp");
					class Ur {
						constructor(t, e) {
							(this.onFoldableChange_ = this.onFoldableChange_.bind(this)), (this.onValueChange_ = this.onValueChange_.bind(this)), (this.invertsY_ = e.invertsY), (this.maxValue_ = e.maxValue), (this.element = t.createElement("div")), this.element.classList.add(Fr()), "popup" === e.layout && this.element.classList.add(Fr(void 0, "p"));
							const n = t.createElement("div");
							n.classList.add(Fr("p")), e.viewProps.bindTabIndex(n), this.element.appendChild(n), (this.padElement = n);
							const i = t.createElementNS(G, "svg");
							i.classList.add(Fr("g")), this.padElement.appendChild(i), (this.svgElem_ = i);
							const r = t.createElementNS(G, "line");
							r.classList.add(Fr("ax")), r.setAttributeNS(null, "x1", "0"), r.setAttributeNS(null, "y1", "50%"), r.setAttributeNS(null, "x2", "100%"), r.setAttributeNS(null, "y2", "50%"), this.svgElem_.appendChild(r);
							const a = t.createElementNS(G, "line");
							a.classList.add(Fr("ax")), a.setAttributeNS(null, "x1", "50%"), a.setAttributeNS(null, "y1", "0"), a.setAttributeNS(null, "x2", "50%"), a.setAttributeNS(null, "y2", "100%"), this.svgElem_.appendChild(a);
							const s = t.createElementNS(G, "line");
							s.classList.add(Fr("l")), s.setAttributeNS(null, "x1", "50%"), s.setAttributeNS(null, "y1", "50%"), this.svgElem_.appendChild(s), (this.lineElem_ = s);
							const o = t.createElement("div");
							o.classList.add(Fr("m")), this.padElement.appendChild(o), (this.markerElem_ = o), e.value.emitter.on("change", this.onValueChange_), (this.value = e.value), this.update_();
						}
						get allFocusableElements() {
							return [this.padElement];
						}
						update_() {
							const [t, e] = this.value.rawValue.getComponents(),
								n = this.maxValue_,
								i = Pn(t, -n, +n, 0, 100),
								r = Pn(e, -n, +n, 0, 100),
								a = this.invertsY_ ? 100 - r : r;
							this.lineElem_.setAttributeNS(null, "x2", `${i}%`), this.lineElem_.setAttributeNS(null, "y2", `${a}%`), (this.markerElem_.style.left = `${i}%`), (this.markerElem_.style.top = `${a}%`);
						}
						onValueChange_() {
							this.update_();
						}
						onFoldableChange_() {
							this.update_();
						}
					}
					function Hr(t, e, n) {
						return [_n(e[0], Mn(t)), _n(e[1], wn(t)) * (n ? 1 : -1)];
					}
					class Gr {
						constructor(t, e) {
							(this.onPadKeyDown_ = this.onPadKeyDown_.bind(this)),
								(this.onPadKeyUp_ = this.onPadKeyUp_.bind(this)),
								(this.onPointerDown_ = this.onPointerDown_.bind(this)),
								(this.onPointerMove_ = this.onPointerMove_.bind(this)),
								(this.onPointerUp_ = this.onPointerUp_.bind(this)),
								(this.value = e.value),
								(this.viewProps = e.viewProps),
								(this.baseSteps_ = e.baseSteps),
								(this.maxValue_ = e.maxValue),
								(this.invertsY_ = e.invertsY),
								(this.view = new Ur(t, { invertsY: this.invertsY_, layout: e.layout, maxValue: this.maxValue_, value: this.value, viewProps: this.viewProps })),
								(this.ptHandler_ = new Cn(this.view.padElement)),
								this.ptHandler_.emitter.on("down", this.onPointerDown_),
								this.ptHandler_.emitter.on("move", this.onPointerMove_),
								this.ptHandler_.emitter.on("up", this.onPointerUp_),
								this.view.padElement.addEventListener("keydown", this.onPadKeyDown_),
								this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
						}
						handlePointerEvent_(t, e) {
							if (!t.point) return;
							const n = this.maxValue_,
								i = Pn(t.point.x, 0, t.bounds.width, -n, +n),
								r = Pn(this.invertsY_ ? t.bounds.height - t.point.y : t.point.y, 0, t.bounds.height, -n, +n);
							this.value.setRawValue(new kr(i, r), e);
						}
						onPointerDown_(t) {
							this.handlePointerEvent_(t.data, { forceEmit: !1, last: !1 });
						}
						onPointerMove_(t) {
							this.handlePointerEvent_(t.data, { forceEmit: !1, last: !1 });
						}
						onPointerUp_(t) {
							this.handlePointerEvent_(t.data, { forceEmit: !0, last: !0 });
						}
						onPadKeyDown_(t) {
							Tn(t.key) && t.preventDefault();
							const [e, n] = Hr(t, this.baseSteps_, this.invertsY_);
							(0 === e && 0 === n) || this.value.setRawValue(new kr(this.value.rawValue.x + e, this.value.rawValue.y + n), { forceEmit: !1, last: !1 });
						}
						onPadKeyUp_(t) {
							const [e, n] = Hr(t, this.baseSteps_, this.invertsY_);
							(0 === e && 0 === n) || this.value.setRawValue(this.value.rawValue, { forceEmit: !0, last: !0 });
						}
					}
					class Wr {
						constructor(t, e) {
							var n, i;
							(this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this)), (this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this)), (this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this)), (this.onPadButtonClick_ = this.onPadButtonClick_.bind(this)), (this.value = e.value), (this.viewProps = e.viewProps), (this.foldable_ = ht.create(e.expanded)), (this.popC_ = "popup" === e.pickerLayout ? new _e(t, { viewProps: this.viewProps }) : null);
							const r = new Gr(t, { baseSteps: [e.axes[0].baseStep, e.axes[1].baseStep], invertsY: e.invertsY, layout: e.pickerLayout, maxValue: e.maxValue, value: this.value, viewProps: this.viewProps });
							r.view.allFocusableElements.forEach((t) => {
								t.addEventListener("blur", this.onPopupChildBlur_), t.addEventListener("keydown", this.onPopupChildKeydown_);
							}),
								(this.pickerC_ = r),
								(this.textC_ = new Ar(t, { assembly: Nr, axes: e.axes, parser: e.parser, value: this.value, viewProps: this.viewProps })),
								(this.view = new Br(t, { expanded: this.foldable_.value("expanded"), pickerLayout: e.pickerLayout, viewProps: this.viewProps })),
								this.view.textElement.appendChild(this.textC_.view.element),
								null === (n = this.view.buttonElement) || void 0 === n || n.addEventListener("blur", this.onPadButtonBlur_),
								null === (i = this.view.buttonElement) || void 0 === i || i.addEventListener("click", this.onPadButtonClick_),
								this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(this.pickerC_.view.element), yn({ primary: this.foldable_.value("expanded"), secondary: this.popC_.shows, forward: (t) => t.rawValue, backward: (t, e) => e.rawValue })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), ft(this.foldable_, this.view.pickerElement));
						}
						onPadButtonBlur_(t) {
							if (!this.popC_) return;
							const e = this.view.element,
								n = o(t.relatedTarget);
							(n && e.contains(n)) || (this.popC_.shows.rawValue = !1);
						}
						onPadButtonClick_() {
							this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus();
						}
						onPopupChildBlur_(t) {
							if (!this.popC_) return;
							const e = this.popC_.view.element,
								n = it(t);
							(n && e.contains(n)) || (n && n === this.view.buttonElement && !X(e.ownerDocument)) || (this.popC_.shows.rawValue = !1);
						}
						onPopupChildKeydown_(t) {
							this.popC_ ? "Escape" === t.key && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && "Escape" === t.key && this.view.buttonElement.focus();
						}
					}
					function jr(t) {
						return kr.isObject(t) ? new kr(t.x, t.y) : new kr();
					}
					function Xr(t, e) {
						t.writeProperty("x", e.x), t.writeProperty("y", e.y);
					}
					function qr(t) {
						if (!t) return;
						const e = [];
						return l(t.step) || e.push(new me(t.step)), (l(t.max) && l(t.min)) || e.push(new fe({ max: t.max, min: t.min })), new he(e);
					}
					function Yr(t) {
						return new Tr({ assembly: Nr, components: [qr("x" in t ? t.x : void 0), qr("y" in t ? t.y : void 0)] });
					}
					function Zr(t, e) {
						const n = t && de(t, fe);
						if (n) return Math.max(Math.abs(n.minValue || 0), Math.abs(n.maxValue || 0));
						const i = Kn(t);
						return Math.max(10 * Math.abs(i), 10 * Math.abs(e));
					}
					function Kr(t, e) {
						const n = e instanceof Tr ? e.components[0] : void 0,
							i = e instanceof Tr ? e.components[1] : void 0,
							r = Zr(n, t.x),
							a = Zr(i, t.y);
						return Math.max(r, a);
					}
					function Jr(t, e) {
						return { baseStep: Kn(e), constraint: e, textProps: L.fromObject({ draggingScale: Jn(e, t), formatter: hn(Zn(e, t)) }) };
					}
					function Qr(t) {
						if (!("y" in t)) return !1;
						const e = t.y;
						return !!e && "inverted" in e && !!e.inverted;
					}
					const $r = {
						id: "input-point2d",
						type: "input",
						accept: (t, e) => {
							if (!kr.isObject(t)) return null;
							const n = k,
								i = N(e, { expanded: n.optional.boolean, picker: n.optional.custom(Gn), x: n.optional.custom(Wn), y: n.optional.object({ inverted: n.optional.boolean, max: n.optional.number, min: n.optional.number, step: n.optional.number }) });
							return i ? { initialValue: t, params: i } : null;
						},
						binding: { reader: (t) => jr, constraint: (t) => Yr(t.params), equals: kr.equals, writer: (t) => Xr },
						controller: (t) => {
							const e = t.document,
								n = t.value,
								i = t.constraint;
							if (!(i instanceof Tr)) throw h.shouldNeverHappen();
							const r = "expanded" in t.params ? t.params.expanded : void 0,
								a = "picker" in t.params ? t.params.picker : void 0;
							return new Wr(e, { axes: [Jr(n.rawValue.x, i.components[0]), Jr(n.rawValue.y, i.components[1])], expanded: null != r && r, invertsY: Qr(t.params), maxValue: Kr(n.rawValue, i), parser: ln, pickerLayout: null != a ? a : "popup", value: n, viewProps: t.viewProps });
						},
					};
					class ta {
						constructor(t = 0, e = 0, n = 0) {
							(this.x = t), (this.y = e), (this.z = n);
						}
						getComponents() {
							return [this.x, this.y, this.z];
						}
						static isObject(t) {
							if (l(t)) return !1;
							const e = t.x,
								n = t.y,
								i = t.z;
							return "number" == typeof e && "number" == typeof n && "number" == typeof i;
						}
						static equals(t, e) {
							return t.x === e.x && t.y === e.y && t.z === e.z;
						}
						toObject() {
							return { x: this.x, y: this.y, z: this.z };
						}
					}
					const ea = { toComponents: (t) => t.getComponents(), fromComponents: (t) => new ta(...t) };
					function na(t) {
						return ta.isObject(t) ? new ta(t.x, t.y, t.z) : new ta();
					}
					function ia(t, e) {
						t.writeProperty("x", e.x), t.writeProperty("y", e.y), t.writeProperty("z", e.z);
					}
					function ra(t) {
						if (!t) return;
						const e = [];
						return l(t.step) || e.push(new me(t.step)), (l(t.max) && l(t.min)) || e.push(new fe({ max: t.max, min: t.min })), new he(e);
					}
					function aa(t) {
						return new Tr({ assembly: ea, components: [ra("x" in t ? t.x : void 0), ra("y" in t ? t.y : void 0), ra("z" in t ? t.z : void 0)] });
					}
					function sa(t, e) {
						return { baseStep: Kn(e), constraint: e, textProps: L.fromObject({ draggingScale: Jn(e, t), formatter: hn(Zn(e, t)) }) };
					}
					const oa = {
						id: "input-point3d",
						type: "input",
						accept: (t, e) => {
							if (!ta.isObject(t)) return null;
							const n = k,
								i = N(e, { x: n.optional.custom(Wn), y: n.optional.custom(Wn), z: n.optional.custom(Wn) });
							return i ? { initialValue: t, params: i } : null;
						},
						binding: { reader: (t) => na, constraint: (t) => aa(t.params), equals: ta.equals, writer: (t) => ia },
						controller: (t) => {
							const e = t.value,
								n = t.constraint;
							if (!(n instanceof Tr)) throw h.shouldNeverHappen();
							return new Ar(t.document, { assembly: ea, axes: [sa(e.rawValue.x, n.components[0]), sa(e.rawValue.y, n.components[1]), sa(e.rawValue.z, n.components[2])], parser: ln, value: e, viewProps: t.viewProps });
						},
					};
					class la {
						constructor(t = 0, e = 0, n = 0, i = 0) {
							(this.x = t), (this.y = e), (this.z = n), (this.w = i);
						}
						getComponents() {
							return [this.x, this.y, this.z, this.w];
						}
						static isObject(t) {
							if (l(t)) return !1;
							const e = t.x,
								n = t.y,
								i = t.z,
								r = t.w;
							return "number" == typeof e && "number" == typeof n && "number" == typeof i && "number" == typeof r;
						}
						static equals(t, e) {
							return t.x === e.x && t.y === e.y && t.z === e.z && t.w === e.w;
						}
						toObject() {
							return { x: this.x, y: this.y, z: this.z, w: this.w };
						}
					}
					const ca = { toComponents: (t) => t.getComponents(), fromComponents: (t) => new la(...t) };
					function ua(t) {
						return la.isObject(t) ? new la(t.x, t.y, t.z, t.w) : new la();
					}
					function ha(t, e) {
						t.writeProperty("x", e.x), t.writeProperty("y", e.y), t.writeProperty("z", e.z), t.writeProperty("w", e.w);
					}
					function da(t) {
						if (!t) return;
						const e = [];
						return l(t.step) || e.push(new me(t.step)), (l(t.max) && l(t.min)) || e.push(new fe({ max: t.max, min: t.min })), new he(e);
					}
					function pa(t) {
						return new Tr({ assembly: ca, components: [da("x" in t ? t.x : void 0), da("y" in t ? t.y : void 0), da("z" in t ? t.z : void 0), da("w" in t ? t.w : void 0)] });
					}
					function fa(t, e) {
						return { baseStep: Kn(e), constraint: e, textProps: L.fromObject({ draggingScale: Jn(e, t), formatter: hn(Zn(e, t)) }) };
					}
					const ma = {
						id: "input-point4d",
						type: "input",
						accept: (t, e) => {
							if (!la.isObject(t)) return null;
							const n = k,
								i = N(e, { x: n.optional.custom(Wn), y: n.optional.custom(Wn), z: n.optional.custom(Wn), w: n.optional.custom(Wn) });
							return i ? { initialValue: t, params: i } : null;
						},
						binding: { reader: (t) => ua, constraint: (t) => pa(t.params), equals: la.equals, writer: (t) => ha },
						controller: (t) => {
							const e = t.value,
								n = t.constraint;
							if (!(n instanceof Tr)) throw h.shouldNeverHappen();
							return new Ar(t.document, { assembly: ca, axes: e.rawValue.getComponents().map((t, e) => fa(t, n.components[e])), parser: ln, value: e, viewProps: t.viewProps });
						},
					};
					function va(t) {
						const e = [],
							n = Xn(t.options);
						return n && e.push(n), new he(e);
					}
					const ga = {
							id: "input-string",
							type: "input",
							accept: (t, e) => {
								if ("string" != typeof t) return null;
								const n = N(e, { options: k.optional.custom(Hn) });
								return n ? { initialValue: t, params: n } : null;
							},
							binding: { reader: (t) => fn, constraint: (t) => va(t.params), writer: (t) => Un },
							controller: (t) => {
								var e;
								const n = t.document,
									i = t.value,
									r = t.constraint;
								return r && de(r, pe) ? new be(n, { props: L.fromObject({ options: null !== (e = qn(r)) && void 0 !== e ? e : [] }), value: i, viewProps: t.viewProps }) : new Se(n, { parser: (t) => t, props: L.fromObject({ formatter: mn }), value: i, viewProps: t.viewProps });
							},
						},
						ba = { monitor: { defaultInterval: 200, defaultLineCount: 3 } },
						xa = v("mll");
					class ya {
						constructor(t, e) {
							(this.onValueUpdate_ = this.onValueUpdate_.bind(this)), (this.formatter_ = e.formatter), (this.element = t.createElement("div")), this.element.classList.add(xa()), e.viewProps.bindClassModifiers(this.element);
							const n = t.createElement("textarea");
							n.classList.add(xa("i")), (n.style.height = `calc(var(--bld-us) * ${e.lineCount})`), (n.readOnly = !0), e.viewProps.bindDisabled(n), this.element.appendChild(n), (this.textareaElem_ = n), e.value.emitter.on("change", this.onValueUpdate_), (this.value = e.value), this.update_();
						}
						update_() {
							const t = this.textareaElem_,
								e = t.scrollTop === t.scrollHeight - t.clientHeight,
								n = [];
							this.value.rawValue.forEach((t) => {
								void 0 !== t && n.push(this.formatter_(t));
							}),
								(t.textContent = n.join("\n")),
								e && (t.scrollTop = t.scrollHeight);
						}
						onValueUpdate_() {
							this.update_();
						}
					}
					class _a {
						constructor(t, e) {
							(this.value = e.value), (this.viewProps = e.viewProps), (this.view = new ya(t, { formatter: e.formatter, lineCount: e.lineCount, value: this.value, viewProps: this.viewProps }));
						}
					}
					const wa = v("sgl");
					class Ma {
						constructor(t, e) {
							(this.onValueUpdate_ = this.onValueUpdate_.bind(this)), (this.formatter_ = e.formatter), (this.element = t.createElement("div")), this.element.classList.add(wa()), e.viewProps.bindClassModifiers(this.element);
							const n = t.createElement("input");
							n.classList.add(wa("i")), (n.readOnly = !0), (n.type = "text"), e.viewProps.bindDisabled(n), this.element.appendChild(n), (this.inputElement = n), e.value.emitter.on("change", this.onValueUpdate_), (this.value = e.value), this.update_();
						}
						update_() {
							const t = this.value.rawValue,
								e = t[t.length - 1];
							this.inputElement.value = void 0 !== e ? this.formatter_(e) : "";
						}
						onValueUpdate_() {
							this.update_();
						}
					}
					class Sa {
						constructor(t, e) {
							(this.value = e.value), (this.viewProps = e.viewProps), (this.view = new Ma(t, { formatter: e.formatter, value: this.value, viewProps: this.viewProps }));
						}
					}
					const Ta = {
						id: "monitor-bool",
						type: "monitor",
						accept: (t, e) => {
							if ("boolean" != typeof t) return null;
							const n = N(e, { lineCount: k.optional.number });
							return n ? { initialValue: t, params: n } : null;
						},
						binding: { reader: (t) => Ee },
						controller: (t) => {
							var e;
							return 1 === t.value.rawValue.length ? new Sa(t.document, { formatter: Ce, value: t.value, viewProps: t.viewProps }) : new _a(t.document, { formatter: Ce, lineCount: null !== (e = t.params.lineCount) && void 0 !== e ? e : ba.monitor.defaultLineCount, value: t.value, viewProps: t.viewProps });
						},
					};
					class Ea {
						constructor() {
							(this.emitter = new f()), (this.index_ = -1);
						}
						get index() {
							return this.index_;
						}
						set index(t) {
							this.index_ !== t && ((this.index_ = t), this.emitter.emit("change", { index: t, sender: this }));
						}
					}
					const Ca = v("grl");
					class Pa {
						constructor(t, e) {
							(this.onCursorChange_ = this.onCursorChange_.bind(this)), (this.onValueUpdate_ = this.onValueUpdate_.bind(this)), (this.element = t.createElement("div")), this.element.classList.add(Ca()), e.viewProps.bindClassModifiers(this.element), (this.formatter_ = e.formatter), (this.minValue_ = e.minValue), (this.maxValue_ = e.maxValue), (this.cursor_ = e.cursor), this.cursor_.emitter.on("change", this.onCursorChange_);
							const n = t.createElementNS(G, "svg");
							n.classList.add(Ca("g")), (n.style.height = `calc(var(--bld-us) * ${e.lineCount})`), this.element.appendChild(n), (this.svgElem_ = n);
							const i = t.createElementNS(G, "polyline");
							this.svgElem_.appendChild(i), (this.lineElem_ = i);
							const r = t.createElement("div");
							r.classList.add(Ca("t"), v("tt")()), this.element.appendChild(r), (this.tooltipElem_ = r), e.value.emitter.on("change", this.onValueUpdate_), (this.value = e.value), this.update_();
						}
						get graphElement() {
							return this.svgElem_;
						}
						update_() {
							const t = this.svgElem_.getBoundingClientRect(),
								e = this.value.rawValue.length - 1,
								n = this.minValue_,
								i = this.maxValue_,
								r = [];
							this.value.rawValue.forEach((a, s) => {
								if (void 0 === a) return;
								const o = Pn(s, 0, e, 0, t.width),
									l = Pn(a, n, i, t.height, 0);
								r.push([o, l].join(","));
							}),
								this.lineElem_.setAttributeNS(null, "points", r.join(" "));
							const a = this.tooltipElem_,
								s = this.value.rawValue[this.cursor_.index];
							if (void 0 === s) return void a.classList.remove(Ca("t", "a"));
							const o = Pn(this.cursor_.index, 0, e, 0, t.width),
								l = Pn(s, n, i, t.height, 0);
							(a.style.left = `${o}px`), (a.style.top = `${l}px`), (a.textContent = `${this.formatter_(s)}`), a.classList.contains(Ca("t", "a")) || (a.classList.add(Ca("t", "a"), Ca("t", "in")), W(a), a.classList.remove(Ca("t", "in")));
						}
						onValueUpdate_() {
							this.update_();
						}
						onCursorChange_() {
							this.update_();
						}
					}
					class Aa {
						constructor(t, e) {
							if (
								((this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this)),
								(this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this)),
								(this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this)),
								(this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this)),
								(this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this)),
								(this.value = e.value),
								(this.viewProps = e.viewProps),
								(this.cursor_ = new Ea()),
								(this.view = new Pa(t, { cursor: this.cursor_, formatter: e.formatter, lineCount: e.lineCount, maxValue: e.maxValue, minValue: e.minValue, value: this.value, viewProps: this.viewProps })),
								X(t))
							) {
								const t = new Cn(this.view.element);
								t.emitter.on("down", this.onGraphPointerDown_), t.emitter.on("move", this.onGraphPointerMove_), t.emitter.on("up", this.onGraphPointerUp_);
							} else this.view.element.addEventListener("mousemove", this.onGraphMouseMove_), this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
						}
						onGraphMouseLeave_() {
							this.cursor_.index = -1;
						}
						onGraphMouseMove_(t) {
							const e = this.view.element.getBoundingClientRect();
							this.cursor_.index = Math.floor(Pn(t.offsetX, 0, e.width, 0, this.value.rawValue.length));
						}
						onGraphPointerDown_(t) {
							this.onGraphPointerMove_(t);
						}
						onGraphPointerMove_(t) {
							t.data.point ? (this.cursor_.index = Math.floor(Pn(t.data.point.x, 0, t.data.bounds.width, 0, this.value.rawValue.length))) : (this.cursor_.index = -1);
						}
						onGraphPointerUp_() {
							this.cursor_.index = -1;
						}
					}
					function La(t) {
						return "format" in t && !l(t.format) ? t.format : hn(2);
					}
					function Ra(t) {
						var e;
						return 1 === t.value.rawValue.length ? new Sa(t.document, { formatter: La(t.params), value: t.value, viewProps: t.viewProps }) : new _a(t.document, { formatter: La(t.params), lineCount: null !== (e = t.params.lineCount) && void 0 !== e ? e : ba.monitor.defaultLineCount, value: t.value, viewProps: t.viewProps });
					}
					function Da(t) {
						var e, n, i;
						return new Aa(t.document, { formatter: La(t.params), lineCount: null !== (e = t.params.lineCount) && void 0 !== e ? e : ba.monitor.defaultLineCount, maxValue: null !== (n = "max" in t.params ? t.params.max : null) && void 0 !== n ? n : 100, minValue: null !== (i = "min" in t.params ? t.params.min : null) && void 0 !== i ? i : 0, value: t.value, viewProps: t.viewProps });
					}
					function Oa(t) {
						return "view" in t && "graph" === t.view;
					}
					const za = {
							id: "monitor-number",
							type: "monitor",
							accept: (t, e) => {
								if ("number" != typeof t) return null;
								const n = k,
									i = N(e, { format: n.optional.function, lineCount: n.optional.number, max: n.optional.number, min: n.optional.number, view: n.optional.string });
								return i ? { initialValue: t, params: i } : null;
							},
							binding: { defaultBufferSize: (t) => (Oa(t) ? 64 : 1), reader: (t) => cn },
							controller: (t) => (Oa(t.params) ? Da(t) : Ra(t)),
						},
						Ia = {
							id: "monitor-string",
							type: "monitor",
							accept: (t, e) => {
								if ("string" != typeof t) return null;
								const n = k,
									i = N(e, { lineCount: n.optional.number, multiline: n.optional.boolean });
								return i ? { initialValue: t, params: i } : null;
							},
							binding: { reader: (t) => fn },
							controller: (t) => {
								var e;
								const n = t.value;
								return n.rawValue.length > 1 || ("multiline" in t.params && t.params.multiline) ? new _a(t.document, { formatter: mn, lineCount: null !== (e = t.params.lineCount) && void 0 !== e ? e : ba.monitor.defaultLineCount, value: n, viewProps: t.viewProps }) : new Sa(t.document, { formatter: mn, value: n, viewProps: t.viewProps });
							},
						};
					class ka {
						constructor(t) {
							(this.onValueChange_ = this.onValueChange_.bind(this)), (this.reader = t.reader), (this.writer = t.writer), (this.emitter = new f()), (this.value = t.value), this.value.emitter.on("change", this.onValueChange_), (this.target = t.target), this.read();
						}
						read() {
							const t = this.target.read();
							void 0 !== t && (this.value.rawValue = this.reader(t));
						}
						write_(t) {
							this.writer(this.target, t);
						}
						onValueChange_(t) {
							this.write_(t.rawValue), this.emitter.emit("change", { options: t.options, rawValue: t.rawValue, sender: this });
						}
					}
					function Na(t, e) {
						const n = t.accept(e.target.read(), e.params);
						if (l(n)) return null;
						const i = k,
							r = { target: e.target, initialValue: n.initialValue, params: n.params },
							a = t.binding.reader(r),
							s = t.binding.constraint ? t.binding.constraint(r) : void 0,
							o = A(a(n.initialValue), { constraint: s, equals: t.binding.equals }),
							c = new ka({ reader: a, target: e.target, value: o, writer: t.binding.writer(r) }),
							u = i.optional.boolean(e.params.disabled).value,
							h = i.optional.boolean(e.params.hidden).value,
							d = t.controller({ constraint: s, document: e.document, initialValue: n.initialValue, params: n.params, value: c.value, viewProps: Jt.create({ disabled: u, hidden: h }) }),
							p = i.optional.string(e.params.label).value;
						return new wt(e.document, { binding: c, blade: ut(), props: L.fromObject({ label: p || e.target.key }), valueController: d });
					}
					class Va {
						constructor(t) {
							(this.onTick_ = this.onTick_.bind(this)), (this.reader_ = t.reader), (this.target = t.target), (this.emitter = new f()), (this.value = t.value), (this.ticker = t.ticker), this.ticker.emitter.on("tick", this.onTick_), this.read();
						}
						dispose() {
							this.ticker.dispose();
						}
						read() {
							const t = this.target.read();
							if (void 0 === t) return;
							const e = this.value.rawValue,
								n = this.reader_(t);
							(this.value.rawValue = xn(e, n)), this.emitter.emit("update", { rawValue: n, sender: this });
						}
						onTick_(t) {
							this.read();
						}
					}
					function Ba(t, e) {
						return 0 === e ? new ce() : new ue(t, null != e ? e : ba.monitor.defaultInterval);
					}
					function Fa(t, e) {
						var n, i, r;
						const a = k,
							s = t.accept(e.target.read(), e.params);
						if (l(s)) return null;
						const o = { target: e.target, initialValue: s.initialValue, params: s.params },
							c = t.binding.reader(o),
							u = null !== (i = null !== (n = a.optional.number(e.params.bufferSize).value) && void 0 !== n ? n : t.binding.defaultBufferSize && t.binding.defaultBufferSize(s.params)) && void 0 !== i ? i : 1,
							h = a.optional.number(e.params.interval).value,
							d = new Va({ reader: c, target: e.target, ticker: Ba(e.document, h), value: gn(u) }),
							p = a.optional.boolean(e.params.disabled).value,
							f = a.optional.boolean(e.params.hidden).value,
							m = t.controller({ document: e.document, params: s.params, value: d.value, viewProps: Jt.create({ disabled: p, hidden: f }) }),
							v = null !== (r = a.optional.string(e.params.label).value) && void 0 !== r ? r : e.target.key;
						return new St(e.document, { binding: d, blade: ut(), props: L.fromObject({ label: v }), valueController: m });
					}
					class Ua {
						constructor() {
							this.pluginsMap_ = { blades: [], inputs: [], monitors: [] };
						}
						getAll() {
							return [...this.pluginsMap_.blades, ...this.pluginsMap_.inputs, ...this.pluginsMap_.monitors];
						}
						register(t) {
							"blade" === t.type ? this.pluginsMap_.blades.unshift(t) : "input" === t.type ? this.pluginsMap_.inputs.unshift(t) : "monitor" === t.type && this.pluginsMap_.monitors.unshift(t);
						}
						createInput(t, e, n) {
							if (l(e.read())) throw new h({ context: { key: e.key }, type: "nomatchingcontroller" });
							const i = this.pluginsMap_.inputs.reduce((i, r) => i || Na(r, { document: t, target: e, params: n }), null);
							if (i) return i;
							throw new h({ context: { key: e.key }, type: "nomatchingcontroller" });
						}
						createMonitor(t, e, n) {
							const i = this.pluginsMap_.monitors.reduce((i, r) => i || Fa(r, { document: t, params: n, target: e }), null);
							if (i) return i;
							throw new h({ context: { key: e.key }, type: "nomatchingcontroller" });
						}
						createBlade(t, e) {
							const n = this.pluginsMap_.blades.reduce((n, i) => n || le(i, { document: t, params: e }), null);
							if (!n) throw new h({ type: "nomatchingview", context: { params: e } });
							return n;
						}
						createBladeApi(t) {
							if (t instanceof wt) return new _t(t);
							if (t instanceof St) return new Mt(t);
							if (t instanceof Vt) return new Pt(t, this);
							const e = this.pluginsMap_.blades.reduce((e, n) => e || n.api({ controller: t, pool: this }), null);
							if (!e) throw h.shouldNeverHappen();
							return e;
						}
					}
					function Ha() {
						const t = new Ua();
						return (
							[$r, oa, ma, ga, Ir, Sr, Mr, _r, ni, Ta, Ia, za, lt, Ht, Yt, oe].forEach((e) => {
								t.register(e);
							}),
							t
						);
					}
					class Ga extends n {
						constructor(t) {
							super(t),
								(this.emitter_ = new f()),
								this.controller_.valueController.value.emitter.on("change", (t) => {
									this.emitter_.emit("change", { event: new r(this, t.rawValue) });
								});
						}
						get label() {
							return this.controller_.props.get("label");
						}
						set label(t) {
							this.controller_.props.set("label", t);
						}
						get options() {
							return this.controller_.valueController.props.get("options");
						}
						set options(t) {
							this.controller_.valueController.props.set("options", t);
						}
						get value() {
							return this.controller_.valueController.value.rawValue;
						}
						set value(t) {
							this.controller_.valueController.value.rawValue = t;
						}
						on(t, e) {
							const n = e.bind(this);
							return (
								this.emitter_.on(t, (t) => {
									n(t.event);
								}),
								this
							);
						}
					}
					class Wa extends n {
						constructor(t) {
							super(t),
								(this.emitter_ = new f()),
								this.controller_.valueController.value.emitter.on("change", (t) => {
									this.emitter_.emit("change", { event: new r(this, t.rawValue) });
								});
						}
						get label() {
							return this.controller_.props.get("label");
						}
						set label(t) {
							this.controller_.props.set("label", t);
						}
						get maxValue() {
							return this.controller_.valueController.sliderController.props.get("maxValue");
						}
						set maxValue(t) {
							this.controller_.valueController.sliderController.props.set("maxValue", t);
						}
						get minValue() {
							return this.controller_.valueController.sliderController.props.get("minValue");
						}
						set minValue(t) {
							this.controller_.valueController.sliderController.props.set("minValue", t);
						}
						get value() {
							return this.controller_.valueController.value.rawValue;
						}
						set value(t) {
							this.controller_.valueController.value.rawValue = t;
						}
						on(t, e) {
							const n = e.bind(this);
							return (
								this.emitter_.on(t, (t) => {
									n(t.event);
								}),
								this
							);
						}
					}
					class ja extends n {
						constructor(t) {
							super(t),
								(this.emitter_ = new f()),
								this.controller_.valueController.value.emitter.on("change", (t) => {
									this.emitter_.emit("change", { event: new r(this, t.rawValue) });
								});
						}
						get label() {
							return this.controller_.props.get("label");
						}
						set label(t) {
							this.controller_.props.set("label", t);
						}
						get formatter() {
							return this.controller_.valueController.props.get("formatter");
						}
						set formatter(t) {
							this.controller_.valueController.props.set("formatter", t);
						}
						get value() {
							return this.controller_.valueController.value.rawValue;
						}
						set value(t) {
							this.controller_.valueController.value.rawValue = t;
						}
						on(t, e) {
							const n = e.bind(this);
							return (
								this.emitter_.on(t, (t) => {
									n(t.event);
								}),
								this
							);
						}
					}
					const Xa = {
						id: "list",
						type: "blade",
						accept(t) {
							const e = k,
								n = N(t, { options: e.required.custom(Hn), value: e.required.raw, view: e.required.constant("list"), label: e.optional.string });
							return n ? { params: n } : null;
						},
						controller(t) {
							const e = new be(t.document, { props: L.fromObject({ options: jn(t.params.options) }), value: A(t.params.value), viewProps: t.viewProps });
							return new Gt(t.document, { blade: t.blade, props: L.fromObject({ label: t.params.label }), valueController: e });
						},
						api: (t) => (t.controller instanceof Gt && t.controller.valueController instanceof be ? new Ga(t.controller) : null),
					};
					function qa(t) {
						return t.reduce((t, e) => Object.assign(t, { [e.presetKey]: e.read() }), {});
					}
					function Ya(t, e) {
						t.forEach((t) => {
							const n = e[t.presetKey];
							void 0 !== n && t.write(n);
						});
					}
					class Za extends At {
						constructor(t, e) {
							super(t, e);
						}
						get element() {
							return this.controller_.view.element;
						}
						importPreset(t) {
							Ya(
								this.controller_.rackController.rack.find(wt).map((t) => t.binding.target),
								t
							),
								this.refresh();
						}
						exportPreset() {
							return qa(this.controller_.rackController.rack.find(wt).map((t) => t.binding.target));
						}
						refresh() {
							this.controller_.rackController.rack.find(wt).forEach((t) => {
								t.binding.read();
							}),
								this.controller_.rackController.rack.find(St).forEach((t) => {
									t.binding.read();
								});
						}
					}
					class Ka extends Ut {
						constructor(t, e) {
							super(t, { expanded: e.expanded, blade: e.blade, props: e.props, root: !0, viewProps: e.viewProps });
						}
					}
					const Ja = {
							id: "slider",
							type: "blade",
							accept(t) {
								const e = k,
									n = N(t, { max: e.required.number, min: e.required.number, view: e.required.constant("slider"), format: e.optional.function, label: e.optional.string, value: e.optional.number });
								return n ? { params: n } : null;
							},
							controller(t) {
								var e, n;
								const i = null !== (e = t.params.value) && void 0 !== e ? e : 0,
									r = new Fn(t.document, { baseStep: 1, parser: ln, sliderProps: L.fromObject({ maxValue: t.params.max, minValue: t.params.min }), textProps: L.fromObject({ draggingScale: Jn(void 0, i), formatter: null !== (n = t.params.format) && void 0 !== n ? n : un }), value: A(i), viewProps: t.viewProps });
								return new Gt(t.document, { blade: t.blade, props: L.fromObject({ label: t.params.label }), valueController: r });
							},
							api: (t) => (t.controller instanceof Gt && t.controller.valueController instanceof Fn ? new Wa(t.controller) : null),
						},
						Qa = {
							id: "text",
							type: "blade",
							accept(t) {
								const e = k,
									n = N(t, { parse: e.required.function, value: e.required.raw, view: e.required.constant("text"), format: e.optional.function, label: e.optional.string });
								return n ? { params: n } : null;
							},
							controller(t) {
								var e;
								const n = new Se(t.document, { parser: t.params.parse, props: L.fromObject({ formatter: null !== (e = t.params.format) && void 0 !== e ? e : (t) => String(t) }), value: A(t.params.value), viewProps: t.viewProps });
								return new Gt(t.document, { blade: t.blade, props: L.fromObject({ label: t.params.label }), valueController: n });
							},
							api: (t) => (t.controller instanceof Gt && t.controller.valueController instanceof Se ? new ja(t.controller) : null),
						};
					function $a(t) {
						const e = t.createElement("div");
						return e.classList.add(v("dfw")()), t.body && t.body.appendChild(e), e;
					}
					function ts(t, e, n) {
						if (t.querySelector(`style[data-tp-style=${e}]`)) return;
						const i = t.createElement("style");
						(i.dataset.tpStyle = e), (i.textContent = n), t.head.appendChild(i);
					}
					class es extends Za {
						constructor(t) {
							var e;
							const n = t || {},
								i = null !== (e = n.document) && void 0 !== e ? e : Y(),
								r = Ha();
							super(new Ka(i, { expanded: n.expanded, blade: ut(), props: L.fromObject({ title: n.title }), viewProps: Jt.create() }), r), (this.pool_ = r), (this.containerElem_ = n.container || $a(i)), this.containerElem_.appendChild(this.element), (this.doc_ = i), (this.usesDefaultWrapper_ = !n.container), this.setUpDefaultPlugins_();
						}
						get document() {
							if (!this.doc_) throw h.alreadyDisposed();
							return this.doc_;
						}
						dispose() {
							const t = this.containerElem_;
							if (!t) throw h.alreadyDisposed();
							if (this.usesDefaultWrapper_) {
								const e = t.parentElement;
								e && e.removeChild(t);
							}
							(this.containerElem_ = null), (this.doc_ = null), super.dispose();
						}
						registerPlugin(t) {
							("plugin" in t ? [t.plugin] : "plugins" in t ? t.plugins : []).forEach((t) => {
								this.pool_.register(t), this.embedPluginStyle_(t);
							});
						}
						embedPluginStyle_(t) {
							t.css && ts(this.document, `plugin-${t.id}`, t.css);
						}
						setUpDefaultPlugins_() {
							ts(
								this.document,
								"default",
								".tp-lstv_s,.tp-btnv_b,.tp-p2dv_b,.tp-colswv_sw,.tp-p2dpv_p,.tp-txtv_i,.tp-grlv_g,.tp-sglv_i,.tp-mllv_i,.tp-fldv_b,.tp-rotv_b,.tp-ckbv_i,.tp-coltxtv_ms,.tp-tbiv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-lstv_s,.tp-btnv_b,.tp-p2dv_b{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-lstv_s:hover,.tp-btnv_b:hover,.tp-p2dv_b:hover{background-color:var(--btn-bg-h)}.tp-lstv_s:focus,.tp-btnv_b:focus,.tp-p2dv_b:focus{background-color:var(--btn-bg-f)}.tp-lstv_s:active,.tp-btnv_b:active,.tp-p2dv_b:active{background-color:var(--btn-bg-a)}.tp-lstv_s:disabled,.tp-btnv_b:disabled,.tp-p2dv_b:disabled{opacity:0.5}.tp-colswv_sw,.tp-p2dpv_p,.tp-txtv_i{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-colswv_sw:hover,.tp-p2dpv_p:hover,.tp-txtv_i:hover{background-color:var(--in-bg-h)}.tp-colswv_sw:focus,.tp-p2dpv_p:focus,.tp-txtv_i:focus{background-color:var(--in-bg-f)}.tp-colswv_sw:active,.tp-p2dpv_p:active,.tp-txtv_i:active{background-color:var(--in-bg-a)}.tp-colswv_sw:disabled,.tp-p2dpv_p:disabled,.tp-txtv_i:disabled{opacity:0.5}.tp-grlv_g,.tp-sglv_i,.tp-mllv_i{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);width:100%}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono,Source Code Pro,Menlo,Courier,monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, #2f3137);--bs-sh: var(--tp-base-shadow-color, rgba(0,0,0,0.2));--btn-bg: var(--tp-button-background-color, #adafb8);--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, #2f3137);--cnt-bg: var(--tp-container-background-color, rgba(187,188,196,0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187,188,196,0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187,188,196,0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187,188,196,0.15));--cnt-fg: var(--tp-container-foreground-color, #bbbcc4);--in-bg: var(--tp-input-background-color, rgba(0,0,0,0.2));--in-bg-a: var(--tp-input-background-color-active, rgba(0,0,0,0.35));--in-bg-f: var(--tp-input-background-color-focus, rgba(0,0,0,0.3));--in-bg-h: var(--tp-input-background-color-hover, rgba(0,0,0,0.25));--in-fg: var(--tp-input-foreground-color, #bbbcc4);--lbl-fg: var(--tp-label-foreground-color, rgba(187,188,196,0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0,0,0,0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187,188,196,0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(0,0,0,0.2))}.tp-fldv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-rotv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1 * var(--cnt-v-p))}.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-fldv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-rotv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-fldv_c>.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv{margin-left:4px}.tp-fldv_c>.tp-fldv>.tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-fldv_c .tp-fldv>.tp-fldv_c,.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-fldv_c>.tp-tabv>.tp-tabv_i,.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_i{border-top-left-radius:var(--elm-br)}.tp-fldv_c .tp-tabv>.tp-tabv_c,.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-fldv_b,.tp-rotv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:calc(var(--cnt-h-p) + 8px);padding-right:calc(2px * 2 + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-fldv_b:hover,.tp-rotv_b:hover{background-color:var(--cnt-bg-h)}.tp-fldv_b:focus,.tp-rotv_b:focus{background-color:var(--cnt-bg-f)}.tp-fldv_b:active,.tp-rotv_b:active{background-color:var(--cnt-bg-a)}.tp-fldv_b:disabled,.tp-rotv_b:disabled{opacity:0.5}.tp-fldv_m,.tp-rotv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:'';display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px) / 2 - 2px);margin:auto;opacity:0.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m,.tp-rotv.tp-rotv-expanded .tp-rotv_m{transform:none}.tp-fldv_c,.tp-rotv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c,.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c{display:none}.tp-fldv.tp-fldv-expanded>.tp-fldv_c,.tp-rotv.tp-rotv-expanded .tp-rotv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-coltxtv_m,.tp-lstv{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-coltxtv_mm,.tp-lstv_m{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-coltxtv_mm svg,.tp-lstv_m svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-coltxtv_mm svg path,.tp-lstv_m svg path{fill:currentColor}.tp-coltxtv_w,.tp-pndtxtv{display:flex}.tp-coltxtv_c,.tp-pndtxtv_a{width:100%}.tp-coltxtv_c+.tp-coltxtv_c,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-pndtxtv_a{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:0.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1 * var(--cnt-h-p));right:calc(-1 * var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a:before{background-color:var(--grv-fg);content:'';height:2px;left:calc(-1 * var(--cnt-h-p));position:absolute;right:calc(-1 * var(--cnt-h-p));top:0}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us) * 4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,0.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0,0,0,0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,0.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,0.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,0.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,0.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br)}.tp-colswv.tp-v-disabled{opacity:0.5}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,0.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:'';display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_c{border-left:var(--cnt-bg) solid 4px}.tp-fldv_b:hover+.tp-fldv_c{border-left-color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_c{border-left-color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_c{border-left-color:var(--cnt-bg-a)}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us) * 3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left 0.05s, top 0.05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:0.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:0.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:0.5}.tp-mllv_i{display:block;height:calc(var(--bld-us) * 3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:0.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1 * var(--cnt-h-p));right:calc(-1 * var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:0.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:0.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sldv.tp-v-disabled{opacity:0.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:'';display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:'';display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:'';display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv.tp-v-disabled{opacity:0.5}.tp-tabv_i{align-items:flex-end;display:flex;overflow:hidden}.tp-tabv.tp-tabv-nop .tp-tabv_i{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_i::before{background-color:var(--cnt-bg);bottom:0;content:'';height:2px;left:0;position:absolute;right:0}.tp-tabv_c{border-left:var(--cnt-bg) solid 4px;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p)}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv::before{background-color:var(--cnt-bg);bottom:0;content:'';height:2px;left:-2px;position:absolute;width:2px}.tp-tbiv_b{background-color:var(--cnt-bg);display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);width:100%}.tp-tbiv_b:hover{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active{background-color:var(--cnt-bg-a)}.tp-tbiv_b:disabled{opacity:0.5}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:0.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:0.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:'';height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:0.1;position:absolute;top:0;transition:border-radius 0.1s, height 0.1s, transform 0.1s, width 0.1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) transparent transparent transparent;border-style:solid;border-width:2px;box-sizing:border-box;content:'';font-size:0.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(2px * 2 + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c,.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1 * var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1 * var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_i{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}"
							),
								this.pool_.getAll().forEach((t) => {
									this.embedPluginStyle_(t);
								}),
								this.registerPlugin({ plugins: [Ja, Xa, oe, Qa] });
						}
					}
					const ns = new e("3.0.5");
					(t.BladeApi = n), (t.ButtonApi = p), (t.FolderApi = At), (t.InputBindingApi = _t), (t.ListApi = Ga), (t.MonitorBindingApi = Mt), (t.Pane = es), (t.SeparatorApi = Wt), (t.SliderApi = Wa), (t.TabApi = ie), (t.TabPageApi = ne), (t.TextApi = ja), (t.TpChangeEvent = r), (t.VERSION = ns), Object.defineProperty(t, "__esModule", { value: !0 });
				})(e);
			},
			7462: (t) => {
				"use strict";
				t.exports =
					"precision highp float;\n#define GLSLIFY 1\n// #define PI 3.14159265359\n\n// #pragma glslify: curlNoise = require('glsl-curl-noise')\n\n// uniform float time;\nuniform float delta;\nuniform float timeScale;\n\nvec3 damp(vec3 start, vec3 end, float l, float dt) {\n    return mix(start, end, 1. - exp(-l * dt));\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec4 tVelocity = texture2D(textureVelocity, uv);\n    vec4 tPosition = texture2D(texturePosition, uv);\n\n    vec3 selfPosition = tPosition.xyz;\n    vec3 selfVelocity = tVelocity.xyz;\n    vec3 position = vec3(0);\n\n    position = selfPosition + (selfVelocity) * max(0.001, timeScale);\n\n    // position = damp(selfPosition, selfPosition + (selfVelocity), max(0.001, timeScale), delta);\n\n    gl_FragColor = vec4(position, 1.);\n}\n";
			},
			5837: (t) => {
				"use strict";
				t.exports =
					"precision highp float;\n#define GLSLIFY 1\n#define PI 3.14159265359\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvec3 snoiseVec3( vec3 x ){\n\n  float s  = snoise(vec3( x ));\n  float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n  float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n  vec3 c = vec3( s , s1 , s2 );\n  return c;\n\n}\n\nvec3 curlNoise( vec3 p ){\n  \n  const float e = .1;\n  vec3 dx = vec3( e   , 0.0 , 0.0 );\n  vec3 dy = vec3( 0.0 , e   , 0.0 );\n  vec3 dz = vec3( 0.0 , 0.0 , e   );\n\n  vec3 p_x0 = snoiseVec3( p - dx );\n  vec3 p_x1 = snoiseVec3( p + dx );\n  vec3 p_y0 = snoiseVec3( p - dy );\n  vec3 p_y1 = snoiseVec3( p + dy );\n  vec3 p_z0 = snoiseVec3( p - dz );\n  vec3 p_z1 = snoiseVec3( p + dz );\n\n  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n\n  const float divisor = 1.0 / ( 2.0 * e );\n  return normalize( vec3( x , y , z ) * divisor );\n\n}\n\nuniform sampler2D noise;\nuniform sampler2D textureParticle;\n\nuniform float time;\nuniform float delta;\nuniform float lambda;\nuniform float minSpeed;\nuniform float maxSpeed;\nuniform float repulsion;\nuniform float repulsionForce;\nuniform float minVelocity;\nuniform float maxVelocity;\nuniform float noiseIntensity;\nuniform float groundOffset;\nuniform float timeScale;\nuniform float attractionForce;\nuniform float goWild;\n\nuniform vec3 gravity;\nuniform vec3 velocity;\nuniform vec3 pointer;\nuniform vec3 damppointer;\nuniform vec3 ground;\nuniform vec3 pointerPosition;\nuniform vec2 uvPointer;\n\nvec3 minLength(vec3 _v, float _min) {\n    float len = length(_v);\n\n    return (_v / len) * (max(_min, len));\n}\n\n// uniform bool isDown;\n\nvec3 damp(vec3 start, vec3 end, float l, float dt) {\n    return mix(start, end, 1. - exp(-l * dt));\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec3 newVelocity = vec3(0);\n\n    vec4 tVelocity = texture2D( textureVelocity, uv );\n    vec4 tPosition = texture2D( texturePosition, uv );\n\n    vec3 selfVelocity = tVelocity.xyz;\n    vec3 selfPosition = tPosition.xyz;\n    float rand = tVelocity.a;\n\n    float attrForce = attractionForce;\n    float repForce = mix(repulsionForce, 0., goWild);\n    float rep = mix(repulsion, 0., goWild);\n\n    float minForce = mix(minSpeed, 0.3, goWild);\n    float maxForce = maxSpeed; //mix(maxSpeed, 3., goWild);\n\n    vec3 distancePosition = pointerPosition - selfPosition;// + n * noiseIntensity;\n    vec3 groundDistPosition = ground - selfPosition;\n    float d = dot(distancePosition, distancePosition);\n    float gd = dot(groundDistPosition, groundDistPosition);\n\n    vec3 selfDirection = normalize(selfVelocity);\n    vec3 n = curlNoise(selfPosition * noiseIntensity + rand * 0.07);\n    vec3 direction = normalize(distancePosition + n);\n    float strength = attrForce * clamp(d, minForce, minForce + maxForce);\n    float gStrength = repForce * clamp(gd, minForce, minForce + maxForce);\n\n    vec3 force = direction * mix(strength, strength + 3., goWild);\n    // force += n * (sin(time + rand * 3025.) * 0.5 + 0.5) * 0.04;\n\n    if (d <= rep * rep) {\n\n        force += reflect(selfDirection + n * 0.1, -direction) * strength * repulsionForce;\n    }\n\n    if (selfPosition.y < ground.y + groundOffset) {\n        // force.y = abs(force.y) * gStrength; //vec3(force.x, force.y * gStrength, force.z);\n        force += reflect(selfDirection + n * 0.3, vec3(0, 1, 0)) * gStrength * 4.;\n    }\n\n    force += gravity;\n\n    newVelocity = selfVelocity + force;\n    newVelocity = minLength(newVelocity, 2.5);\n    newVelocity *= mix(lambda, 0.7, goWild);\n\n    newVelocity = damp(selfVelocity, newVelocity, timeScale, delta);\n\n    gl_FragColor = vec4(newVelocity, rand);\n}\n";
			},
			1089: (t) => {
				"use strict";
				t.exports = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\nvarying float vRand;\nvarying float vShade;\nvarying float vSizeVariation;\n\nvoid main() {\n    vec2 uv = gl_PointCoord.xy - 0.5;\n    vec3 color = vColor + 0.5;\n\n    float c = 0.04 / length(uv) - 0.2;\n    float alpha = c * (vRand * 0.4 + 0.6) * vShade * (vSizeVariation * 0.5 + 0.5);\n\n    if (alpha <= 0.) discard;\n\n    color *= alpha;\n\n    gl_FragColor = vec4(color, alpha);\n}\n";
			},
			2934: (t) => {
				"use strict";
				t.exports =
					"#define GLSLIFY 1\n// #pragma glslify: noise3D = require('glsl-noise/simplex/3d')\n\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nattribute vec3 position;\nattribute float size;\nattribute float rand;\nattribute float stagger;\nattribute vec3 aColor;\n\nuniform float time;\nuniform vec3 cameraPosition;\nuniform vec3 pointer;\nuniform float changeStars;\n\nvarying vec3 vColor;\nvarying float vRand;\nvarying float vShade;\nvarying float vSizeVariation;\n\nfloat remap(float value, float start1, float stop1, float start2, float stop2) {\n    return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));\n}\n\nvoid main() {\n    vec3 transformed = position;\n\n    transformed.x += cos(time * 0.006 * rand + rand * 512.) * 5.;\n    transformed.y += sin(time * 0.01 * rand + rand * 1545.) * 3.;\n    transformed.z += sin(time * 0.005 * rand + rand * 512.) * 4.;\n\n    vec3 pointerPos = pointer - transformed;\n    // transformed = mix(transformed, transformed + pointerPos, changeStars * remap(changeStars + rand * stagger, 0., 1. + rand * stagger, 0., 1.));\n\n    vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n    vec3 worldPos = vec3(modelMatrix * vec4(transformed, 1.0));\n\n    float sizeVariation = sin(time * 0.01 * rand + rand * 1545.) * 0.5 + 0.5;\n    float finalSize = size + sizeVariation * 10.;\n\n    gl_PointSize = (finalSize) * ( 300.0 / -mvPosition.z );\n\n    vColor = aColor;\n    vRand = rand;\n\n    float distanceFromCamera = distance(worldPos, cameraPosition);\n\n    vShade = smoothstep(500., 150., distanceFromCamera);\n    vSizeVariation = sizeVariation;\n\n    gl_Position = projectionMatrix * mvPosition;\n}\n";
			},
			7570: (t) => {
				"use strict";
				t.exports =
					"precision highp float;\n#define GLSLIFY 1\n\nuniform vec3 cameraPosition;\n\n// varying vec2 vUv;\nvarying vec3 vColor;\nvarying vec3 vCameraDirection;\nvarying float vCameraDistance;\nvarying float vProgress;\nvarying float vAlpha;\nvarying vec3 vAltColor;\nvarying float vAltColorDist;\n\nuniform vec3 pointer;\n\nuniform float mulValue;\n// uniform float darkness;\nuniform float powerValue;\n// uniform bool isBloomPass;\n\nfloat getScatter(vec3 cameraPos, vec3 dir, vec3 lightPos, float d) {\n    // Light to Ray Origin\n    vec3 q = cameraPos - lightPos;\n\n    // Coefficients\n    float b = dot(dir, q);\n    float c = dot(q, q);\n\n    // Evaluate integral\n    float t = c - b*b;\n    float s = 1. / sqrt(max(.0001, t));\n    float l = s * (atan((d+b) * s) - atan(b*s));\n\n    // Maybe tweak those values to change the effect?\n    return pow(max(0., l * mulValue), powerValue);\n}\n\nvoid main() {\n    vec3 color = mix(vColor, vAltColor, vAltColorDist);\n    float spine = vProgress;\n\n    float scatter = clamp(getScatter(cameraPosition, vCameraDirection, pointer, vCameraDistance), 0., 1.);\n    float alpha = exp(1. - spine) * vAlpha;\n\n    color = mix(color, vec3(1), smoothstep(0.94, 0.95, spine)) * scatter;\n\n    // color = isBloomPass ? vec3(0) : color;\n\n    // color = mix(vColor, vec3(0), 1. - alpha);\n    // color *= mix(1., scatter, darkness);\n    // color = mix(color, vec3(1), 1. - smoothstep(.97, .5, spine));\n\n    if (alpha <= 0.001) discard;\n\n    color *= alpha;\n\n    gl_FragColor = vec4(color, alpha);\n}\n";
			},
			263: (t) => {
				"use strict";
				t.exports =
					"#define GLSLIFY 1\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n// #pragma glslify: curlNoise = require('glsl-curl-noise')\n\n#define PI 3.14159265359\n#define TAU 6.28318530718\n#define saturate(t) clamp(t, 0., 1.)\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nattribute vec2 aRef;\nattribute float aProgress;\n\nuniform vec3 cameraPosition;\n\nuniform float time;\nuniform float delta;\nuniform sampler2D texturePrevPosition;\nuniform sampler2D texturePosition;\nuniform sampler2D textureVelocity;\nuniform sampler2D textureParticle;\nuniform float minVelocity;\nuniform float maxVelocity;\nuniform vec3 pointer;\nuniform float timeScale;\n\nattribute mat4 instanceMatrix;\nattribute vec3 instanceColor;\nattribute vec3 aAltColor;\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec3 vAltColor;\nvarying vec3 vColor;\nvarying vec3 vCameraDirection;\nvarying float vCameraDistance;\n// varying vec2 vUv;\nvarying float vProgress;\nvarying float vAlpha;\nvarying float vAltColorDist;\n\nmat4 r3D(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n\t\toc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.,\n\t\t0.0,                                0.0,                                0.0,                                1.0\n\t);\n}\n\nmat4 t3D(vec3 t) {\n  return mat4(1., 0., 0., t.x,\n              0., 1., 0., t.y,\n              0., 0., 1., t.z,\n              0., 0., 0., 1.\n  );\n}\n\nfloat snoise(vec3 n);\nvec3 curlNoise(vec3 n);\n\nvoid main() {\n    vec4 tPrevPosition = texture2D(texturePrevPosition, aRef);\n\tvec4 tPosition     = texture2D(texturePosition, aRef);\n\tvec4 tVelocity     = texture2D(textureVelocity, aRef);\n\tvec2 tParticle     = texture2D(textureParticle, aRef).ba;\n\n\tfloat scaleY   = clamp(dot(tVelocity, tVelocity), 1., 2.);\n\tvec3 translate = tPosition.xyz;\n\tvec3 prevPos   = tPrevPosition.xyz;\n    // vec3 dir       = (translate - pointer) - (prevPos - pointer);\n\n    vec3 posToPointer = pointer - translate;\n\tvec3 direction = normalize(translate - prevPos);\n    vec3 pointerDirection = normalize(posToPointer);\n    float pointerDistanceSq = length(posToPointer);\n    vec3 desiredDirection = normalize(pointerDirection - direction);\n    // float speed = smoothstep(minVelocity, maxVelocity, length(tVelocity));\n\tfloat angle = acos(direction.y);\n    float desiredAngle = acos(desiredDirection.y) * smoothstep(40., 10., pointerDistanceSq);\n\tvec3 axis   = normalize(vec3(direction.z, 0., -direction.x));\n    // vec3 biAxis = cross(pointerDirection, direction);\n    vec3 biAxis = normalize(vec3(pointerDirection.z, 0., -pointerDirection.x));\n    // biAxis = cross(biAxis, axis);\n    float n = snoise(translate * 0.1 + direction * 2. + time * 0.03) * 0.5 + 0.5;\n\n    mat4 rotationMat    = r3D(axis, angle) * r3D(biAxis, (aProgress * desiredAngle * 0.3));\n\tmat4 translationMat = t3D(translate);\n\n    vColor = instanceColor;\n    // vUv = uv;\n    vec3 transformed = position;\n    // transformed.xz *= sin((aProgress) * PI * 2.) * 0.2 + 0.8 + aProgress * .2;\n    // transformed += n * pow(1. - aProgress, 3.);\n\n    // transformed.y *= scaleY;\n\n    vec4 worldPosition = vec4( transformed, 1.0 );\n    worldPosition = worldPosition * rotationMat * translationMat;\n\n    gl_Position = projectionMatrix * modelViewMatrix * worldPosition;\n\n    vec3 camWorld = worldPosition.xyz - cameraPosition;\n\n    float worldDist = length(worldPosition.xyz - pointer);\n\n    vAltColor = aAltColor;\n    vProgress = aProgress;\n    vAlpha = smoothstep(800., 500., worldDist);\n    vAltColorDist = n;\n\n    vCameraDirection = normalize(camWorld);\n    vCameraDistance  = length(camWorld);\n}\n";
			},
			881: (t) => {
				"use strict";
				t.exports =
					"#define GLSLIFY 1\n#define saturate(t) clamp(t, 0., 1.)\n\nuniform vec3 color;\nuniform vec2 resolution;\n\nuniform sampler2D tDiffuse;\nuniform sampler2D tWaterNormal0;\nuniform sampler2D tWaterNormal1;\nuniform float time;\nuniform float timeScale;\nuniform float delta;\nuniform float normalScale;\nuniform vec3 pointer;\n\nvarying vec3 vNormal;\nvarying vec4 vUv;\nvarying vec2 v2vUv;\nvarying vec3 vViewDirection;\n// varying vec3 vLightDirection;\nvarying vec3 vWorldPosition;\nvarying float vLightDist;\n\nvarying vec4 vViewPointer;\n// varying vec4 vViewPosition;\n\n// varying vec3 vCameraDirection;\n// varying float vCameraDistance;\n\nuniform float mulValue;\nuniform float powerValue;\n\n// uniform bool isBloomPass;\n\n// float getScatter(vec3 cameraPos, vec3 dir, vec3 lightPos, float d) {\n//     // Light to Ray Origin\n//     vec3 q = cameraPos - lightPos;\n\n//     // Coefficients\n//     float b = dot(dir, q);\n//     float c = dot(q, q);\n\n//     // Evaluate integral\n//     float t = c - b*b;\n//     float s = 1. / sqrt(max(.0001, t));\n//     float l = s * (atan((d+b) * s) - atan(b*s));\n\n//     // Maybe tweak those values to change the effect?\n//     return pow(max(0., l * mulValue), powerValue);\n// }\n\n#include <logdepthbuf_pars_fragment>\n\nfloat blendOverlay( float base, float blend ) {\n\n    return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n}\n\nvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n    return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n}\n\nvoid main() {\n    #include <logdepthbuf_fragment>\n    vec3 finalColor = vec3(0);\n    vec2 st = gl_FragCoord.xy / resolution;\n\n    // determine flow direction\n    vec2 flow = vec2(0.8, 0.1);\n\n    float scale = normalScale;\n\n    // sample normal maps (distort uvs with flowdata)\n    vec4 normalColor0 = texture2D( tWaterNormal0, ( v2vUv )    * scale - flow * time * 0.01);\n    vec4 normalColor1 = texture2D( tWaterNormal0, ( v2vUv.yx ) * scale + flow * time * 0.012);\n\n    // linear interpolate to get the final normal color\n    // float flowLerp = abs( 0.5 - flowMapOffset0 ) / 0.5;\n    vec4 normalColor = min( normalColor0, normalColor1 ) * normalScale;\n\n    // vec3 normalDistortion = texture2D(tWaterNormal0, v2vUv).rgb;\n    // normalColor = normalize( vec4( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0, 1.) );\n\n    vec3 normal = normalize(vNormal + normalColor.xyz);\n    float screenDepth = saturate(((pointer.z - vWorldPosition.z + 250.) / vViewPointer.w));\n\n    float theta = smoothstep(.3, 1.5, max( dot( -vViewDirection, normal ), 0.0 )) * screenDepth;\n\n    vec3 lightDist = (vWorldPosition - normalColor.xyz) - pointer;\n    vec3 lightDirection = normalize(lightDist);\n\n    // float scatter = getScatter(cameraPosition, vCameraDirection, pointer, vCameraDistance);\n\n    float light = pow((max( dot(-lightDirection, normal), .0) * 10.) / vLightDist, 2.);\n\n    vec4 base = texture2DProj( tDiffuse, vUv + normalColor);\n\n    finalColor += base.rgb;\n\n    finalColor += light;\n\n    finalColor *= theta;\n\n    finalColor = blendOverlay( finalColor, color );\n\n    // finalColor = vec3(max(0., (vViewPosition - vViewPointer).b / (pow(resolution.y, 2.))));\n\n    gl_FragColor = vec4(finalColor, 1.);\n}\n";
			},
			8157: (t) => {
				"use strict";
				t.exports =
					"#define GLSLIFY 1\nuniform mat4 textureMatrix;\nuniform sampler2D tWaterNormal0;\nuniform sampler2D tWaterNormal1;\nuniform float time;\nuniform vec3 pointer;\n\n// varying vec3 vCameraDirection;\n// varying float vCameraDistance;\n\nvarying vec4 vUv;\nvarying vec3 vNormal;\nvarying vec2 v2vUv;\nvarying vec3 vViewDirection;\nvarying vec3 vWorldPosition;\n// varying vec3 vLightDirection;\nvarying float vLightDist;\nvarying vec4 vViewPointer;\n\n#include <common>\n#include <logdepthbuf_pars_vertex>\n\nvoid main() {\n\n    vUv = textureMatrix * vec4( position, 1.0 );\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n\n    vNormal = vec3(modelMatrix * vec4(normal, 0.));\n    v2vUv = uv;\n\n    vec4 worldPos = modelMatrix * vec4( position, 1.0 );\n\n    vWorldPosition = worldPos.xyz;\n\n    vec3 lightDist = worldPos.xyz - pointer;\n    vLightDist = length(lightDist);\n    // vLightDirection = normalize(lightDist);\n    vViewDirection = normalize(worldPos.xyz - cameraPosition);\n\n    // vec3 camWorld = worldPos.xyz - cameraPosition;\n\n    // vCameraDirection = normalize(camWorld);\n    // vCameraDistance  = length(camWorld);\n    vViewPointer = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n\n    #include <logdepthbuf_vertex>\n}\n";
			},
		},
		e = {};
	function n(i) {
		var r = e[i];
		if (void 0 !== r) return r.exports;
		var a = (e[i] = { exports: {} });
		return t[i].call(a.exports, a, a.exports, n), a.exports;
	}
	(n.n = (t) => {
		var e = t && t.__esModule ? () => t.default : () => t;
		return n.d(e, { a: e }), e;
	}),
		(n.d = (t, e) => {
			for (var i in e) n.o(e, i) && !n.o(t, i) && Object.defineProperty(t, i, { enumerable: !0, get: e[i] });
		}),
		(n.g = (function () {
			if ("object" == typeof globalThis) return globalThis;
			try {
				return this || new Function("return this")();
			} catch (t) {
				if ("object" == typeof window) return window;
			}
		})()),
		(n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e));
	n(1416);
})();